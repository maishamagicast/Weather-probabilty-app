{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js", "../../@arcgis/core/chunks/LineCallout.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.33/esri/copyright.txt for details.\n*/\nimport{ReadDepth as e}from\"../output/ReadDepth.glsl.js\";import{glsl as t}from\"../../shaderModules/glsl.js\";import{Texture2DBindUniform as o}from\"../../shaderModules/Texture2DBindUniform.js\";function r(r){r.include(e),r.uniforms.add(new o(\"geometryDepthTexture\",(e=>e.geometryDepth?.attachment))),r.code.add(t`bool geometryDepthTest(vec2 pos, float elementDepth) {\nfloat geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos);\nreturn (elementDepth < (geometryDepth - 1.0));\n}`)}export{r as multipassGeometryTest};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.33/esri/copyright.txt for details.\n*/\nimport{set as e}from\"../core/libs/gl-matrix-2/math/vec2.js\";import{create as i}from\"../core/libs/gl-matrix-2/factories/vec2f64.js\";import{ZEROS as r}from\"../core/libs/gl-matrix-2/factories/vec4f64.js\";import{RejectBySlice as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{AlignPixel as t}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";import{HUD as n}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";import{HUDVisibility as a}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUDVisibility.glsl.js\";import{multipassGeometryTest as l}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";import{addScreenSizePerspectiveAlignment as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";import{Float2BindUniform as s}from\"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";import{Float2PassUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4BindUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Float4BindUniform.js\";import{Float4PassUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{If as v,glsl as S}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{VertexAttribute as m}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{ShaderBuilder as w}from\"../views/webgl/ShaderBuilder.js\";function h(i){const h=new w,{vertex:b,fragment:z}=h,{terrainDepthTest:x}=i;return b.include(t),h.include(n,i),h.vertex.include(o,i),h.attributes.add(m.UV0,\"vec2\"),b.uniforms.add(new p(\"viewport\",(e=>e.camera.fullViewport)),new f(\"lineSize\",((e,i)=>e.size>0?Math.max(1,e.size)*i.camera.pixelRatio:0)),new s(\"pixelToNDC\",(i=>e(u,2/i.camera.fullViewport[2],2/i.camera.fullViewport[3]))),new f(\"borderSize\",((e,i)=>e.borderColor?i.camera.pixelRatio:0)),new c(\"screenOffset\",((i,r)=>e(u,i.horizontalScreenOffset*r.camera.pixelRatio,0)))),h.varyings.add(\"coverageSampling\",\"vec4\"),h.varyings.add(\"lineSizes\",\"vec2\"),x&&h.varyings.add(\"depth\",\"float\"),i.occlusionTestEnabled&&h.include(a),i.hasScreenSizePerspective&&d(b),b.main.add(S`\n    ProjectHUDAux projectAux;\n    vec4 endPoint = projectPositionHUD(projectAux);\n\n    vec3 vpos = projectAux.posModel;\n    if (rejectBySlice(vpos)) {\n      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n      return;\n    }\n    ${v(i.occlusionTestEnabled,S`if (!testHUDVisibility(endPoint)) {\n             gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n             return;\n           }`)}\n\n    ${i.hasScreenSizePerspective?S`vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n               vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);`:\"vec2 screenOffsetScaled = screenOffset;\"}\n    // Add view dependent polygon offset to get exact same original starting point. This is mostly used to get the\n    // correct depth value\n    vec3 posView = (view * vec4(position, 1.0)).xyz;\n    ${v(x,\"depth = posView.z;\")}\n\n    applyHUDViewDependentPolygonOffset(centerOffsetAndDistance.w, projectAux.absCosAngle, posView);\n    vec4 startPoint = proj * vec4(posView, 1.0);\n\n    // Apply screen offset to both start and end point\n    vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n    startPoint.xy += screenOffsetNorm * startPoint.w;\n    endPoint.xy += screenOffsetNorm * endPoint.w;\n\n    // Align start and end to pixel origin\n    vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n    vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${v(i.hudDepth,i.hudDepthAlignStart?\"endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\":\"startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\")}\n    vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n\n    // The direction of the line in screen space\n    vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n    vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${i.hasScreenSizePerspective?S`float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n               float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);`:S`float lineSizeScaled = lineSize;\n               float borderSizeScaled = borderSize;`}\n    float halfPixelSize = lineSizeScaled * 0.5;\n\n    // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n    float padding = 1.0 + borderSizeScaled;\n    vec2 ndcOffset = (-halfPixelSize - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n    // Offset x/y from the center of the line in screen space\n    projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n    // Compute a coverage varying which we can use in the fragment shader to determine\n    // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n    // This works by computing two coordinates that can be linearly interpolated and then\n    // subtracted to find out how far away from the line edge we are.\n    float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n    float halfBorderSize = 0.5 * borderSizeScaled;\n    float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n    float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n    float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n    coverageSampling = vec4(\n      // Edge coordinate\n      outerEdgeCoverageSampler,\n\n      // Border edge coordinate\n      outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n      // Line offset\n      halfPixelSize - 0.5,\n\n      // Border offset\n      halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n    );\n\n    lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n    gl_Position = projectedPosition;`),z.uniforms.add(new g(\"uColor\",(e=>e.color??r)),new g(\"borderColor\",(e=>e.borderColor??r))),x&&(z.include(l,i),z.uniforms.add(new s(\"inverseViewport\",(e=>e.inverseViewport)))),z.main.add(S`\n    ${v(x,\"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\")}\n\n    vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n    float borderAlpha = uColor.a * borderColor.a * coverage.y;\n    float colorAlpha = uColor.a * coverage.x;\n\n    float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n    ${v(!i.hudDepth,S`vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);\n           fragColor = vec4(finalRgb, finalAlpha);`)}`),h}const u=i(),b=Object.freeze(Object.defineProperty({__proto__:null,build:h},Symbol.toStringTag,{value:\"Module\"}));export{b as L,h as b};\n"],
  "mappings": "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",
  "names": ["r", "o", "e", "n", "i", "h", "b", "o", "e", "u", "r", "n"]
}
