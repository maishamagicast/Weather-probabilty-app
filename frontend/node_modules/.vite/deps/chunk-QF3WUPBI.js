import {
  e
} from "./chunk-3FFCJ4YU.js";
import {
  l as l6
} from "./chunk-B4FIB5U5.js";
import {
  v
} from "./chunk-GYTX5GXS.js";
import {
  l as l4,
  l2 as l5,
  t as t2
} from "./chunk-ATT4LH5S.js";
import {
  l as l3
} from "./chunk-LBDNG364.js";
import {
  n
} from "./chunk-FV6ZNHFI.js";
import {
  r as r3
} from "./chunk-APMQAZ5Z.js";
import {
  O
} from "./chunk-PRTJ3U75.js";
import {
  t
} from "./chunk-EU64TE5C.js";
import {
  a as a3
} from "./chunk-QDOFETFN.js";
import {
  n as n2
} from "./chunk-R7YP6EQJ.js";
import {
  n as n3,
  r as r4
} from "./chunk-QUZZIDFR.js";
import {
  a as a4
} from "./chunk-CBCDVQSA.js";
import {
  l as l2
} from "./chunk-XNUSHDFN.js";
import {
  V
} from "./chunk-74GULGYB.js";
import {
  o as o2
} from "./chunk-VNQUG2TO.js";
import {
  p as p2
} from "./chunk-TOCH3L2K.js";
import {
  s as s3
} from "./chunk-67AKDROO.js";
import {
  H,
  i2,
  p
} from "./chunk-POWGZO3T.js";
import {
  o as o3
} from "./chunk-NJZD7WM5.js";
import {
  r as r2
} from "./chunk-CL7VLXUR.js";
import {
  l
} from "./chunk-FCX4ZA3Z.js";
import {
  b as b2,
  m2 as m
} from "./chunk-2ZPU5IZX.js";
import {
  a2
} from "./chunk-S62CSPIH.js";
import {
  w,
  x
} from "./chunk-X26VPODZ.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import {
  b,
  s as s2,
  u2 as u
} from "./chunk-N626Y23H.js";
import {
  a,
  i3 as i,
  s2 as s
} from "./chunk-TJPLHZCD.js";
import {
  o
} from "./chunk-KLFJ5V5G.js";

// node_modules/@arcgis/core/ground/NavigationConstraint.js
var p3;
var c = p3 = class extends l {
  constructor(o4) {
    super(o4), this.type = "none";
  }
  clone() {
    return new p3({ type: this.type });
  }
};
r([r3({ none: "none", stayAbove: "stay-above" }), m({ json: { write: { isRequired: true } } })], c.prototype, "type", void 0), c = p3 = r([a2("esri.ground.NavigationConstraint")], c);

// node_modules/@arcgis/core/support/groundInstanceUtils.js
var n4 = Symbol("GroundInstance");

// node_modules/@arcgis/core/Ground.js
var C;
var I;
var _a;
var L = I = (_a = class extends l.JSONSupportMixin(p2) {
  constructor(r5) {
    super(r5), this[C] = true, this.opacity = 1, this.surfaceColor = null, this.navigationConstraint = null, this.layers = new V();
    const e2 = (r6) => {
      r6.parent && r6.parent !== this && "remove" in r6.parent && r6.parent.remove(r6), r6.parent = this, "elevation" !== r6.type && "base-elevation" !== r6.type && i.getLogger(this).error(`Layer '${r6.title}, id:${r6.id}' of type '${r6.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`);
    }, t4 = (r6) => {
      r6.parent = null;
    };
    this.addHandles([this.layers.on("after-add", ((r6) => e2(r6.item))), this.layers.on("after-remove", ((r6) => t4(r6.item)))]);
  }
  initialize() {
    this.when().catch(((r5) => {
      b(r5) || i.getLogger(this).error("#load()", "Failed to load ground", r5);
    })), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    const r5 = this.layers.removeAll();
    for (const e2 of r5) u(e2);
    this.layers.destroy();
  }
  normalizeCtorArgs(r5) {
    return r5 && "resourceInfo" in r5 && (this._set("resourceInfo", r5.resourceInfo), delete (r5 = { ...r5 }).resourceInfo), r5;
  }
  get layers() {
    return this._get("layers");
  }
  set layers(r5) {
    this._set("layers", n2(r5, this._get("layers")));
  }
  writeLayers(r5, e2, o4, t4) {
    const i5 = [];
    r5 ? (t4 = { ...t4, layerContainerType: "ground" }, r5.forEach(((r6) => {
      if ("write" in r6) {
        const e3 = {};
        o(r6)().write(e3, t4) && i5.push(e3);
      } else t4?.messages && t4.messages.push(new s("layer:unsupported", `Layers (${r6.title}, ${r6.id}) of type '${r6.declaredClass}' cannot be persisted in the ground`, { layer: r6 }));
    })), e2.layers = i5) : e2.layers = i5;
  }
  load(r5) {
    return this.addResolvingPromise(this._loadFromSource(r5)), Promise.resolve(this);
  }
  loadAll() {
    return t(this, ((r5) => {
      r5(this.layers);
    }));
  }
  async queryElevation(r5, e2) {
    await this.load({ signal: e2?.signal });
    const { ElevationQuery: o4 } = await import("./ElevationQuery-PWELXOUG.js");
    s2(e2);
    const t4 = new o4(), s4 = this.layers.filter(A).toArray();
    return t4.queryAll(s4, r5, e2);
  }
  async createElevationSampler(r5, e2) {
    await this.load({ signal: e2?.signal });
    const { ElevationQuery: o4 } = await import("./ElevationQuery-PWELXOUG.js");
    s2(e2);
    const t4 = new o4(), s4 = this.layers.filter(A).toArray();
    return t4.createSamplerAll(s4, r5, e2);
  }
  clone() {
    const r5 = { opacity: this.opacity, surfaceColor: a(this.surfaceColor), navigationConstraint: a(this.navigationConstraint), layers: this.layers.slice() };
    return this.loaded && (r5.loadStatus = "loaded"), new I({ resourceInfo: this.resourceInfo }).set(r5);
  }
  read(r5, e2) {
    this.resourceInfo || this._set("resourceInfo", { data: r5, context: e2 }), super.read(r5, e2);
  }
  _loadFromSource(r5) {
    const e2 = this.resourceInfo;
    return e2 ? this._loadLayersFromJSON(e2.data, e2.context, r5) : Promise.resolve();
  }
  async _loadLayersFromJSON(r5, e2, o4) {
    const t4 = e2?.origin || "web-scene", s4 = e2?.portal || null, a6 = e2?.url || null, { populateOperationalLayers: i5 } = await import("./layersCreator-6Q4HCPCJ.js");
    s2(o4);
    const n5 = [];
    if (r5.layers && Array.isArray(r5.layers)) {
      const e3 = { context: { origin: t4, url: a6, portal: s4, layerContainerType: "ground" }, defaultLayerType: "ArcGISTiledElevationServiceLayer" };
      n5.push(i5(this.layers, r5.layers, e3));
    }
    await Promise.allSettled(n5);
  }
}, C = n4, _a);
function b3(r5) {
  return r5 && "createElevationSampler" in r5;
}
function A(r5) {
  return "elevation" === r5.type || b3(r5);
}
r([m({ json: { read: false, write: { isRequired: true } } })], L.prototype, "layers", null), r([r2("layers")], L.prototype, "writeLayers", null), r([m({ readOnly: true })], L.prototype, "resourceInfo", void 0), r([m({ type: Number, nonNullable: true, range: { min: 0, max: 1 }, json: { type: x, read: { reader: r4, source: "transparency" }, write: { writer: (r5, e2) => {
  e2.transparency = n3(r5);
}, target: "transparency" } } })], L.prototype, "opacity", void 0), r([m({ type: l2, json: { type: [x], write: (r5, e2) => {
  e2.surfaceColor = r5.toJSON().slice(0, 3);
} } })], L.prototype, "surfaceColor", void 0), r([m({ type: c, json: { write: true } })], L.prototype, "navigationConstraint", void 0), L = I = r([a2("esri.Ground")], L);
var E = L;

// node_modules/@arcgis/core/effects/FocusAreaOutline.js
var i3 = class extends a4.ClonableMixin(l) {
  constructor(o4) {
    super(o4), this.color = null;
  }
};
r([m({ type: l2, json: { type: [x], write: true } })], i3.prototype, "color", void 0), i3 = r([a2("esri.effects.FocusAreaOutline")], i3);
var m2 = i3;

// node_modules/@arcgis/core/effects/FocusArea.js
var u2 = class extends l.JSONSupportMixin(a4) {
  constructor(e2) {
    super(e2), this.id = `focusarea-${n()}`, this.title = null, this.enabled = true, this.outline = null, this.geometries = new l6();
  }
  readGeometries(e2, o4, r5) {
    Array.isArray(e2) ? this.geometries = l6.fromJSON(e2, r5) : r5.hooks?.onAfterLoad?.((() => this._loadGeometries(p(e2, r5), r5)));
  }
  async _loadGeometries(e2, r5) {
    const t4 = await H(e2, { responseType: "json" });
    this.geometries = l6.fromJSON(t4.data, r5);
  }
};
r([m({ type: String, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } } }), m()], u2.prototype, "id", void 0), r([m({ type: String, json: { write: true } })], u2.prototype, "title", void 0), r([m({ type: Boolean, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } } })], u2.prototype, "enabled", void 0), r([m({ type: m2, json: { write: true } })], u2.prototype, "outline", void 0), r([m({ type: l6, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } }, clonable: (e2) => new l6(e2.items.map(((e3) => e3.clone()))) }), v({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "geometries", contentAddressed: true })], u2.prototype, "geometries", void 0), r([o3(["web-scene", "portal-item"], "geometries")], u2.prototype, "readGeometries", null), u2 = r([a2("esri.effects.FocusArea")], u2);
var d = u2;

// node_modules/@arcgis/core/effects/FocusAreas.js
var c2 = class extends l.JSONSupportMixin(a4) {
  constructor(o4) {
    super(o4), this.areas = new V(), this.style = "bright";
  }
};
r([m({ type: V.ofType(d), nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } }, clonable: (o4) => new V(o4.items.map(((o5) => o5.clone()))) })], c2.prototype, "areas", void 0), r([m({ type: ["bright", "dark"], nonNullable: true, json: { write: true } })], c2.prototype, "style", void 0), c2 = r([a2("esri.effects.FocusAreas")], c2);
var a5 = c2;

// node_modules/@arcgis/core/support/basemapEnsureType.js
var f = () => i.getLogger("esri.support.basemapUtils");
function p4() {
  return {};
}
function l7(e2) {
  for (const r5 in e2) {
    const s4 = e2[r5];
    u(s4), delete e2[r5];
  }
}
function m3(r5, s4) {
  let o4;
  if ("string" == typeof r5) {
    const n5 = r5 in a3, a6 = !n5 && r5.includes("/");
    if (!n5 && !a6) {
      if (i2()) f().warn(`Unable to find basemap definition for: ${r5}. See available styles at https://developers.arcgis.com/rest/basemap-styles/`);
      else {
        const e2 = Object.entries(a3).filter((([e3, r6]) => r6.classic || r6.is3d)).map((([e3]) => `"${e3}"`)).sort().join(", ");
        f().warn(`Unable to find basemap definition for: ${r5}. Try one of these: ${e2}`);
      }
      return null;
    }
    s4 && (o4 = s4[r5]), o4 || (o4 = n5 ? O.fromId(r5) : new O({ style: { id: r5 } }), s4 && (s4[r5] = o4));
  } else o4 = w(O, r5);
  return o4?.destroyed && (f().warn("The provided basemap is already destroyed", { basemap: o4 }), o4 = null), o4;
}

// node_modules/@arcgis/core/support/groundUtils.js
var i4 = { "world-elevation": { id: "worldElevation", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" }, "world-topobathymetry": { id: "worldTopoBathymetry", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/TopoBathy3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" } };
function t3(t4) {
  let a6 = null;
  if ("string" == typeof t4) if (t4 in i4) {
    const r5 = i4[t4];
    a6 = new E({ resourceInfo: { data: { layers: [r5] } } });
  } else i.getLogger("esri.support.groundUtils").warn(`Unable to find ground definition for: ${t4}. Try "world-elevation"`);
  else a6 = w(E, t4);
  return a6;
}

// node_modules/@arcgis/core/Map.js
var g = class extends l5(l4(o2.EventedMixin(b2))) {
  constructor(e2) {
    super(e2), this.allLayers = new l3({ getCollections: () => [this.basemap?.baseLayers, this.ground?.layers, this.layers, this.basemap?.referenceLayers], getChildrenFunction: (e3) => "layers" in e3 ? e3.layers : null }), this.focusAreas = new a5(), this.allTables = t2(this), this.basemap = null, this.editableLayers = new l3({ getCollections: () => [this.allLayers], itemFilterFunction: e }), this.ground = new E(), this._basemapCache = p4();
  }
  destroy() {
    l7(this._basemapCache), this._basemapCache = null, this.focusAreas.destroy(), this.allLayers.destroy(), this.allTables.destroy(), this.editableLayers.destroy(), this.basemap = u(this.basemap), u(this.ground), this._set("ground", null);
  }
  castBasemap(e2) {
    return m3(e2, this._basemapCache);
  }
  castGround(e2) {
    const s4 = t3(e2);
    return s4 ?? this._get("ground");
  }
  findLayerById(e2) {
    return this.allLayers.find(((s4) => s4.id === e2));
  }
  findTableById(e2) {
    return this.allTables.find(((s4) => s4.id === e2));
  }
};
r([m({ readOnly: true, dependsOn: [] })], g.prototype, "allLayers", void 0), r([m({ type: a5, nonNullable: true, json: { write: { overridePolicy: (e2) => ({ enabled: e2.areas.length > 0, ignoreOrigin: true }) } } })], g.prototype, "focusAreas", void 0), r([m({ readOnly: true })], g.prototype, "allTables", void 0), r([m({ type: O, json: { read: { source: "baseMap" }, write: { target: "baseMap" } } })], g.prototype, "basemap", void 0), r([s3("basemap")], g.prototype, "castBasemap", null), r([m({ readOnly: true })], g.prototype, "editableLayers", void 0), r([m({ type: E, nonNullable: true })], g.prototype, "ground", void 0), r([s3("ground")], g.prototype, "castGround", null), r([m()], g.prototype, "undoRedo", void 0), g = r([a2("esri.Map")], g);
var L2 = g;

export {
  L2 as L
};
//# sourceMappingURL=chunk-QF3WUPBI.js.map
