import {
  E2 as E4,
  F,
  P as P3,
  Q as Q2,
  R as R4,
  a as a8,
  c as c9,
  e2 as e7,
  e3 as e8,
  h as h5,
  k as k4,
  p as p2,
  t as t5,
  t2 as t6,
  w as w4,
  y as y3
} from "./chunk-X4UNNCRM.js";
import {
  E as E3,
  H2 as H,
  J2 as J,
  R as R3,
  V as V3,
  r as r5
} from "./chunk-WHBC3CR5.js";
import {
  R as R5,
  j as j9
} from "./chunk-PBT7TYWA.js";
import {
  c as c8,
  l2 as l5
} from "./chunk-IRTIVNQB.js";
import {
  M as M3,
  R as R2,
  T,
  j as j8,
  x as x2
} from "./chunk-CTLJVZXG.js";
import {
  t as t4
} from "./chunk-YKE7YQGP.js";
import {
  Et,
  It,
  Le,
  N as N3,
  Zt,
  ge,
  gt,
  qt,
  yt
} from "./chunk-BUFMNTUX.js";
import {
  E as E2,
  c as c7,
  h as h4
} from "./chunk-37USNU2Q.js";
import {
  N as N2,
  j as j7
} from "./chunk-YERTKO74.js";
import {
  t as t3
} from "./chunk-ELIP33PA.js";
import {
  a as a7,
  d as d4,
  f as f4,
  h as h3,
  j as j6,
  o as o5
} from "./chunk-OG7E7GTZ.js";
import {
  c as c6
} from "./chunk-YGPPU7AB.js";
import {
  E,
  a as a6,
  b as b2,
  j as j5,
  m as m3,
  p,
  u as u6
} from "./chunk-WHNSSW5C.js";
import {
  k as k3,
  x
} from "./chunk-HWK5FYIC.js";
import {
  K,
  W
} from "./chunk-YMHW3NBN.js";
import {
  n as n3
} from "./chunk-4LDLOXAQ.js";
import {
  e as e5
} from "./chunk-RHVCSVQD.js";
import {
  y as y2
} from "./chunk-FFY3IMAS.js";
import {
  t
} from "./chunk-DTPLSS5W.js";
import {
  L as L3,
  R
} from "./chunk-KX3QNWMZ.js";
import {
  e as e4
} from "./chunk-HPADPQJ7.js";
import {
  a as a5,
  i as i2
} from "./chunk-ZG3HABK4.js";
import {
  c as c5
} from "./chunk-CY6GSCRR.js";
import {
  c as c3,
  u as u2
} from "./chunk-YGAODLX5.js";
import {
  c as c2
} from "./chunk-Q5OUGHHK.js";
import {
  o as o6
} from "./chunk-3ZLXURTQ.js";
import {
  e as e6,
  t as t2
} from "./chunk-OB2KZAI3.js";
import {
  l as l4
} from "./chunk-BDYPDR3Y.js";
import {
  u as u5
} from "./chunk-QNRDEVXA.js";
import {
  M as M2,
  e as e3,
  f as f3,
  j as j4,
  k as k2,
  l as l3,
  o as o3,
  u as u3
} from "./chunk-BNQMKYX6.js";
import {
  A,
  I,
  P as P2,
  Q,
  _ as _2,
  c as c4,
  g as g2,
  o as o4,
  s as s2,
  u as u4,
  w as w3
} from "./chunk-K3VYMAVM.js";
import {
  h as h2
} from "./chunk-FPALEK52.js";
import {
  D,
  g
} from "./chunk-S5G7D7MX.js";
import {
  d as d2
} from "./chunk-YVMULGDJ.js";
import {
  O
} from "./chunk-CJDZN5K5.js";
import {
  d as d3
} from "./chunk-PBKE5BCM.js";
import {
  V
} from "./chunk-74GULGYB.js";
import {
  a as a3,
  n,
  r as r4
} from "./chunk-RKF6WUZT.js";
import {
  P,
  m as m2,
  y
} from "./chunk-RMRI4NYS.js";
import {
  M,
  a as a4,
  z as z2
} from "./chunk-YYLIW24Q.js";
import {
  n as n2
} from "./chunk-B7BH33JH.js";
import {
  U,
  j,
  l as l2,
  w as w2
} from "./chunk-HYAO4PVV.js";
import {
  o as o2
} from "./chunk-VNQUG2TO.js";
import {
  S,
  _,
  j as j3
} from "./chunk-SMO33YG7.js";
import {
  f
} from "./chunk-LCBAL6ER.js";
import {
  N,
  V as V2,
  Z,
  ae,
  ee,
  j as j2,
  oe,
  r as r2,
  re,
  s2 as s,
  z
} from "./chunk-6JCZVSRM.js";
import {
  c,
  f as f2
} from "./chunk-4AKMPOG7.js";
import {
  r as r3
} from "./chunk-ZJQPHR3K.js";
import {
  b,
  i3 as i,
  m2 as m
} from "./chunk-2ZPU5IZX.js";
import {
  a2
} from "./chunk-S62CSPIH.js";
import {
  w
} from "./chunk-X26VPODZ.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import {
  L as L2,
  d,
  e,
  e2,
  k,
  l2 as l,
  o4 as o,
  u2 as u
} from "./chunk-N626Y23H.js";
import {
  a
} from "./chunk-TJPLHZCD.js";
import {
  L,
  h
} from "./chunk-KLFJ5V5G.js";

// node_modules/@arcgis/core/views/interactive/ManipulatorCollection.js
var a9;
!(function(t10) {
  t10[t10.WhenToolEditable = 0] = "WhenToolEditable", t10[t10.WhenToolNotEditable = 1] = "WhenToolNotEditable", t10[t10.Always = 2] = "Always";
})(a9 || (a9 = {}));
var i3 = class {
  constructor() {
    this._isToolEditable = true, this._manipulators = new V(), this._resourceContexts = { manipulator3D: {} }, this._attached = false;
  }
  set isToolEditable(t10) {
    this._isToolEditable = t10;
  }
  get length() {
    return this._manipulators.length;
  }
  add(t10, i9 = a9.WhenToolEditable) {
    this.addMany([t10], i9);
  }
  addMany(t10, i9 = a9.WhenToolEditable) {
    for (const a12 of t10) {
      const t11 = { manipulator: a12, visibilityPredicate: i9, attached: false };
      this._manipulators.add(t11), this._attached && this._updateManipulatorAttachment(t11);
    }
  }
  remove(t10) {
    for (let a12 = 0; a12 < this._manipulators.length; a12++) if (this._manipulators.at(a12).manipulator === t10) {
      const t11 = this._manipulators.splice(a12, 1)[0];
      this._detachManipulator(t11);
      break;
    }
  }
  removeAll() {
    this._manipulators.forEach(((t10) => {
      this._detachManipulator(t10);
    })), this._manipulators.removeAll();
  }
  attach() {
    this._manipulators.forEach(((t10) => {
      this._updateManipulatorAttachment(t10);
    })), this._attached = true;
  }
  detach() {
    this._manipulators.forEach(((t10) => {
      this._detachManipulator(t10);
    })), this._attached = false;
  }
  destroy() {
    this.detach(), this._manipulators.forEach((({ manipulator: t10 }) => t10.destroy())), this._manipulators.destroy(), this._resourceContexts = null;
  }
  on(t10, a12) {
    return this._manipulators.on(t10, ((t11) => {
      a12(t11);
    }));
  }
  forEach(t10) {
    for (const a12 of this._manipulators.items) t10(a12);
  }
  some(t10) {
    return this._manipulators.items.some(t10);
  }
  toArray() {
    const t10 = [];
    return this.forEach(((a12) => t10.push(a12.manipulator))), t10;
  }
  intersect(t10, a12) {
    let i9 = null, e13 = Number.MAX_VALUE;
    return this._manipulators.forEach((({ manipulator: o8, attached: s3 }) => {
      if (!s3 || !o8.interactive) return;
      const r8 = o8.intersectionDistance(t10, a12);
      null != r8 && r8 < e13 && (e13 = r8, i9 = o8);
    })), i9;
  }
  _updateManipulatorAttachment(t10) {
    this._isManipulatorItemVisible(t10) ? this._attachManipulator(t10) : this._detachManipulator(t10);
  }
  _attachManipulator(t10) {
    t10.attached || (t10.manipulator.attach && t10.manipulator.attach(this._resourceContexts), t10.attached = true);
  }
  _detachManipulator(t10) {
    if (!t10.attached) return;
    const a12 = t10.manipulator;
    a12.grabbing = false, a12.dragging = false, a12.hovering = false, a12.selected = false, a12.detach && a12.detach(this._resourceContexts), t10.attached = false;
  }
  _isManipulatorItemVisible(t10) {
    return t10.visibilityPredicate === a9.Always || (this._isToolEditable ? t10.visibilityPredicate === a9.WhenToolEditable : t10.visibilityPredicate === a9.WhenToolNotEditable);
  }
};

// node_modules/@arcgis/core/views/interactive/InteractiveToolBase.js
var n4 = class extends o2.EventedAccessor {
  constructor(t10) {
    super(t10), this.manipulators = new i3(), this.automaticManipulatorSelection = true, this.hasGrabbedManipulators = false, this.hasHoveredManipulators = false, this.firstGrabbedManipulator = null, this.created = false, this.removeIncompleteOnCancel = true, this._editableFlags = /* @__PURE__ */ new Map([[o6.MANAGER, true], [o6.USER, true]]), this._creationFinishedResolver = L2();
  }
  get active() {
    return null != this.view && this.view.activeTool === this;
  }
  set visible(t10) {
    this._get("visible") !== t10 && (this._set("visible", t10), this._syncVisible());
  }
  get editable() {
    return this.getEditableFlag(o6.USER);
  }
  set editable(t10) {
    this.setEditableFlag(o6.USER, t10);
  }
  get updating() {
    return false;
  }
  get cursor() {
    return null;
  }
  get hasFocusedManipulators() {
    return this.hasGrabbedManipulators || this.hasHoveredManipulators;
  }
  destroy() {
    this.manipulators.destroy(), this._set("view", null);
  }
  onAdd() {
    this._syncVisible();
  }
  activate() {
    null != this.view && (this.view.focus(), this.onActivate());
  }
  deactivate() {
    this.onDeactivate();
  }
  cancel() {
    this.emit("cancel");
  }
  handleInputEvent(t10) {
    this.onInputEvent(t10);
  }
  handleInputEventAfter(t10) {
    this.onInputEventAfter(t10);
  }
  setEditableFlag(t10, e13) {
    this._editableFlags.set(t10, e13), this.manipulators.isToolEditable = this.internallyEditable, this._updateManipulatorAttachment(), t10 === o6.USER && this.notifyChange("editable"), this.onEditableChange(), this.onManipulatorSelectionChanged();
  }
  getEditableFlag(t10) {
    return this._editableFlags.get(t10) ?? false;
  }
  endDrag() {
    const t10 = this.view.inputManager.latestPointerLocation;
    if (!t10) return;
    let e13 = false;
    this.manipulators.forEach((({ manipulator: i9 }) => {
      i9.dragging && (e13 = true, i9.events.emit("drag", { action: "end", start: t10, screenPoint: t10 }));
    })), e13 && (this.view.toolViewManager.activeTool = null);
  }
  whenCreated() {
    return this._creationFinishedResolver.promise;
  }
  onManipulatorSelectionChanged() {
  }
  onActivate() {
  }
  onDeactivate() {
  }
  onShow() {
  }
  onHide() {
  }
  onEditableChange() {
  }
  onInputEvent(t10) {
  }
  onInputEventAfter(t10) {
  }
  get internallyEditable() {
    return this.getEditableFlag(o6.USER) && this.getEditableFlag(o6.MANAGER);
  }
  finishToolCreation() {
    this.created || this._creationFinishedResolver.resolve(this), this._set("created", true);
  }
  _syncVisible() {
    if (this.initialized) {
      if (this.visible) this._show();
      else if (this._hide(), this.active) return void (this.view.activeTool = null);
    }
  }
  _show() {
    this._updateManipulatorAttachment(), this.onShow();
  }
  _hide() {
    this._updateManipulatorAttachment(), this.onHide();
  }
  _updateManipulatorAttachment() {
    this.visible ? this.manipulators.attach() : this.manipulators.detach();
  }
};
r([m({ constructOnly: true })], n4.prototype, "view", void 0), r([m({ readOnly: true })], n4.prototype, "active", null), r([m({ value: true })], n4.prototype, "visible", null), r([m({ value: true })], n4.prototype, "editable", null), r([m({ readOnly: true })], n4.prototype, "manipulators", void 0), r([m({ readOnly: true })], n4.prototype, "updating", null), r([m()], n4.prototype, "cursor", null), r([m({ readOnly: true })], n4.prototype, "automaticManipulatorSelection", void 0), r([m()], n4.prototype, "hasFocusedManipulators", null), r([m()], n4.prototype, "hasGrabbedManipulators", void 0), r([m()], n4.prototype, "hasHoveredManipulators", void 0), r([m()], n4.prototype, "firstGrabbedManipulator", void 0), r([m({ readOnly: true })], n4.prototype, "created", void 0), r([m({ readOnly: true })], n4.prototype, "removeIncompleteOnCancel", void 0), n4 = r([a2("esri.views.interactive.InteractiveToolBase")], n4);

// node_modules/@arcgis/core/undoredo/OperationStatus.js
var e9;
!(function(e13) {
  e13[e13.NeverApplied = 0] = "NeverApplied", e13[e13.Applied = 1] = "Applied", e13[e13.Undone = 2] = "Undone";
})(e9 || (e9 = {}));

// node_modules/@arcgis/core/undoredo/UndoRedoError.js
var r6;
!(function(r8) {
  r8.UndoRedoUpdating = "UndoRedoUpdating", r8.UndoInvalidError = "UndoInvalidError", r8.RedoInvalidError = "RedoInvalidError", r8.ApplyInvalidError = "ApplyInvalidError";
})(r6 || (r6 = {}));
var o7 = { [r6.UndoRedoUpdating]: "Cannot perform operation whilst undo redo is updating", [r6.UndoInvalidError]: "There are no items to Undo", [r6.RedoInvalidError]: "There are no items to Redo", [r6.ApplyInvalidError]: "Cannot apply an item that is already applied" };
var d5 = class extends Error {
  constructor() {
    super(o7[r6.UndoRedoUpdating]), this.type = "undo-redo-updating-error";
  }
};
var n5 = class extends Error {
  constructor() {
    super(o7[r6.UndoInvalidError]), this.type = "undo-redo-undo-error";
  }
};
var e10 = class extends Error {
  constructor() {
    super(o7[r6.RedoInvalidError]), this.type = "undo-redo-redo-error";
  }
};
var t7 = class extends Error {
  constructor() {
    super(o7[r6.ApplyInvalidError]), this.type = "undo-redo-apply-error";
  }
};

// node_modules/@arcgis/core/undoredo/UndoableOperation.js
var a10;
!(function(t10) {
  t10[t10.Apply = 0] = "Apply", t10[t10.Undo = 1] = "Undo", t10[t10.Redo = 2] = "Redo";
})(a10 || (a10 = {}));
var n6 = class extends b {
  constructor() {
    super(...arguments), this.name = "", this.tag = Symbol(), this.status = e9.NeverApplied;
  }
  get canUndo() {
    return this.status === e9.Applied;
  }
  get canRedo() {
    return this.status === e9.Undone;
  }
  async executeUndoRedoOperation(t10) {
    switch (t10) {
      case a10.Apply:
        if (this.status !== e9.NeverApplied) throw new t7();
        return await this.apply(), void (this.status = e9.Applied);
      case a10.Undo:
        if (this.status !== e9.Applied) throw new n5();
        return await this.undo(), void (this.status = e9.Undone);
      case a10.Redo:
        if (this.status !== e9.Undone) throw new n5();
        return await this.redo(), void (this.status = e9.Applied);
    }
  }
};
r([m()], n6.prototype, "name", void 0), r([m()], n6.prototype, "tag", void 0), n6 = r([a2("esri.undoredo.UndoableOperation")], n6);

// node_modules/@arcgis/core/UndoRedo.js
var u7 = class extends b {
  constructor() {
    super(...arguments), this._stack = new V(), this._stackPosition = -1, this._updatingHandles = new h2();
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get canUndo() {
    return this.hasUndo && !this.updating;
  }
  get hasUndo() {
    return this._stackPosition >= 0;
  }
  get canRedo() {
    return this.hasRedo && !this.updating;
  }
  get hasRedo() {
    return this._stackPosition < this._stack.length - 1;
  }
  _truncateForwardStack() {
    this._stack.splice(this._stackPosition + 1, this._stack.length - this._stackPosition).forEach(((t10) => t10.destroy()));
  }
  _drainStack() {
    this._stack.drain(((t10) => t10.destroy())), this._stackPosition = -1;
  }
  async undo() {
    if (!this.hasUndo) throw new n5();
    if (this.updating) throw new d5();
    const t10 = this._stack.getItemAt(this._stackPosition);
    t10 && await this._updatingHandles.addPromise((async () => {
      await t10.executeUndoRedoOperation(a10.Undo), --this._stackPosition, t10.canRedo || this._truncateForwardStack();
    })());
  }
  async redo() {
    if (!this.hasRedo) throw new e10();
    if (this.updating) throw new d5();
    const t10 = this._stack.getItemAt(this._stackPosition + 1);
    if (!t10) throw new e10();
    await this._updatingHandles.addPromise((async () => {
      await t10.executeUndoRedoOperation(a10.Redo), ++this._stackPosition;
    })());
  }
  peekUndo() {
    if (this.canUndo) return this._stack.getItemAt(this._stackPosition);
  }
  peekRedo() {
    if (this.canRedo) return this._stack.getItemAt(this._stackPosition + 1);
  }
  async inject(t10) {
    if (this.updating) throw new d5();
    await this._updatingHandles.addPromise((async () => {
      t10.status === e9.NeverApplied && await t10.executeUndoRedoOperation(a10.Apply), t10.canUndo ? (this._stack.splice(this._stackPosition + 1, 0, t10), this._stackPosition++) : this._stackPosition > -1 && (this._stack.splice(0, this._stackPosition + 1).forEach(((t11) => t11.destroy())), this._stackPosition = -1);
    })());
  }
  async add(t10) {
    if (this.updating) throw new d5();
    await this._updatingHandles.addPromise((async () => {
      t10.status === e9.NeverApplied && await t10.executeUndoRedoOperation(a10.Apply), this._stackPosition >= -1 && this._truncateForwardStack(), t10.canUndo ? (this._stack.push(t10), this._stackPosition = this._stack.length - 1) : this._drainStack();
    })());
  }
  async removeTagged(t10, s3 = false) {
    if (this.updating && !s3) return;
    await j((() => !this.updating));
    const a12 = new V();
    for (let i9 = 0; i9 < this._stack.length; i9++) {
      const s4 = this._stack.getItemAt(i9);
      s4 && (s4.tag === t10 ? (s4.destroy(), i9 === this._stackPosition && (this._stackPosition = a12.length - 1)) : a12.push(s4));
    }
    this._stack = a12, this._stackPosition > a12.length - 1 && (this._stackPosition = a12.length - 1);
  }
  async clear(t10 = false) {
    if (this.updating && !t10) throw new d5();
    await j((() => !this.updating)), this._drainStack();
  }
};
r([m()], u7.prototype, "_stack", void 0), r([m()], u7.prototype, "_stackPosition", void 0), r([m()], u7.prototype, "updating", null), r([m({ readOnly: true })], u7.prototype, "canUndo", null), r([m({ readOnly: true })], u7.prototype, "hasUndo", null), r([m({ readOnly: true })], u7.prototype, "canRedo", null), r([m({ readOnly: true })], u7.prototype, "hasRedo", null), u7 = r([a2("esri.UndoRedo")], u7);

// node_modules/@arcgis/core/views/draw/support/CreateOperationGeometry.js
var l6 = class {
  constructor() {
    this.committedVertices = null, this.cursorVertex = null, this.full = null, this.outline = null, this.cursorEdge = null, this.circle = null, this.rectangle = null;
  }
};

// node_modules/@arcgis/core/geometry/Circle.js
var f5;
var g3 = f5 = class extends P {
  constructor(e13) {
    super(e13), this.center = null, this.geodesic = false, this.numberOfPoints = 60, this.radius = 1e3, this.radiusUnit = "meters";
  }
  initialize() {
    const e13 = this.center, o8 = this.numberOfPoints;
    if (this.hasZ = e13?.hasZ ?? false, 0 !== this.rings.length || !e13) return;
    const c14 = j2(this.radius, this.radiusUnit, "meters"), n8 = e13.spatialReference;
    let p7, l9 = "geographic";
    if (n8.isWebMercator ? l9 = "webMercator" : (null != (n8.wkid && r2[n8.wkid]) || (n8.wkt2 || n8.wkt) && oe(n8.wkt2 || n8.wkt)) && (l9 = "projected"), this.geodesic) {
      let r8;
      switch (l9) {
        case "webMercator":
          r8 = S(e13);
          break;
        case "projected":
          console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");
          break;
        case "geographic":
          r8 = e13;
      }
      p7 = this._createGeodesicCircle(r8, c14, o8), "webMercator" === l9 && (p7 = j3(p7));
    } else {
      let r8;
      "webMercator" === l9 || "projected" === l9 ? r8 = c14 / ee(e13.spatialReference) : "geographic" === l9 && (r8 = z(c14, "meters", s(e13.spatialReference).radius)), p7 = this._createPlanarCircle(e13, r8, o8);
    }
    this.spatialReference = p7.spatialReference, this.addRing(p7.rings[0]);
  }
  clone() {
    const { center: e13, numberOfPoints: r8, radius: t10, radiusUnit: s3, geodesic: i9 } = this;
    return new f5({ center: e13?.clone(), numberOfPoints: r8, radius: t10, radiusUnit: s3, geodesic: i9 });
  }
  _createGeodesicCircle(e13, r8, t10) {
    const s3 = [], i9 = [e13.x, e13.y];
    for (let o8 = 0; o8 < 360; o8 += 360 / t10) {
      const t11 = this.hasZ ? [0, 0, e13.z ?? 0] : [0, 0];
      j7(t11, i9, o8, r8, f.WGS84), s3.push(t11);
    }
    return s3.push(s3[0]), new P({ rings: [s3] });
  }
  _createPlanarCircle(e13, r8, t10) {
    const s3 = [], i9 = 2 * Math.PI / t10;
    for (let o8 = 0; o8 < t10; ++o8) {
      const t11 = i9 * o8, c14 = [e13.x + Math.cos(-t11) * r8, e13.y + Math.sin(-t11) * r8];
      this.hasZ && c14.push(e13.z ?? 0), s3.push(c14);
    }
    return s3.push(s3[0]), new P({ spatialReference: e13.spatialReference, rings: [s3] });
  }
};
r([m({ type: _ })], g3.prototype, "center", void 0), r([m()], g3.prototype, "geodesic", void 0), r([m()], g3.prototype, "numberOfPoints", void 0), r([m()], g3.prototype, "radius", void 0), r([m()], g3.prototype, "radiusUnit", void 0), g3 = f5 = r([a2("esri.geometry.Circle")], g3);
var b3 = g3;

// node_modules/@arcgis/core/views/draw/support/surfaceCoordinateSystems.js
function g4(t10, r8, e13 = null) {
  return null != e13 ? [t10, r8, e13] : [t10, r8];
}
function w5(t10, r8, e13 = null) {
  return null != e13 ? { x: t10, y: r8, z: e13 } : { x: t10, y: r8 };
}
var R6 = class {
  constructor(t10) {
    this.spatialReference = t10;
  }
  mapToLocalMultiple(r8) {
    return r8.map(((t10) => this.mapToLocal(t10))).filter(L);
  }
  get doUnnormalization() {
    return false;
  }
};
var v = class extends R6 {
  constructor(t10, a12, o8 = null) {
    super(a12), this._defaultZ = o8, this.transform = e6(), this.transformInv = e6(), this.transform = t2(t10), u5(this.transformInv, this.transform);
  }
  makeMapPoint(t10, r8) {
    return g4(t10, r8, this._defaultZ);
  }
  mapToLocal(t10) {
    return w5(this.transform[0] * t10[0] + this.transform[2] * t10[1] + this.transform[4], this.transform[1] * t10[0] + this.transform[3] * t10[1] + this.transform[5]);
  }
  localToMap(t10) {
    return g4(this.transformInv[0] * t10.x + this.transformInv[2] * t10.y + this.transformInv[4], this.transformInv[1] * t10.x + this.transformInv[3] * t10.y + this.transformInv[5], this._defaultZ);
  }
};
var W2 = class extends R6 {
  constructor(t10, r8) {
    super(t10.spatialReference), this.view = t10, this.defaultZ = null, this.pWS = n(), this.tangentFrameUpWS = n(), this.tangentFrameRightWS = n(), this.tangentFrameForwardWS = n(), this.localFrameRightWS = n(), this.localFrameUpWS = n(), this.worldToLocalTransform = e4(), this.localToWorldTransform = e4(), this.scale = 1, this.scale = t10.resolution, this.referenceMapPoint = r8, this.defaultZ = r8.hasZ ? r8.z : null;
    const e13 = t10.state.camera.viewRight;
    this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint, this.pWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n2.X, this.tangentFrameRightWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n2.Y, this.tangentFrameUpWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n2.Z, this.tangentFrameForwardWS);
    const s3 = n();
    g2(s3, this.tangentFrameForwardWS, P2(e13, this.tangentFrameForwardWS)), c4(this.localFrameRightWS, e13, s3), A(this.localFrameRightWS, this.localFrameRightWS), _2(this.localFrameUpWS, this.tangentFrameForwardWS, this.localFrameRightWS), R(this.worldToLocalTransform, this.localFrameRightWS, this.tangentFrameRightWS), L3(this.localToWorldTransform, this.worldToLocalTransform);
  }
  get doUnnormalization() {
    return "global" === this.view.viewingMode;
  }
  makeMapPoint(t10, r8) {
    return g4(t10, r8, this.defaultZ);
  }
  mapToLocal(t10) {
    const r8 = n();
    this.view.renderCoordsHelper.toRenderCoords(new _({ x: t10[0], y: t10[1], spatialReference: this.spatialReference }), r8), Q(r8, r8, this.worldToLocalTransform);
    const e13 = this.view.renderCoordsHelper.fromRenderCoords(r8, new _({ spatialReference: this.view.spatialReference }));
    return null != e13 ? w5(e13.x / this.scale, e13.y / this.scale) : null;
  }
  localToMap(t10) {
    const r8 = n();
    this.view.renderCoordsHelper.toRenderCoords(new _({ x: t10.x * this.scale, y: t10.y * this.scale, spatialReference: this.spatialReference }), r8), Q(r8, r8, this.localToWorldTransform);
    const e13 = this.view.renderCoordsHelper.fromRenderCoords(r8, new _({ spatialReference: this.view.spatialReference }));
    return null != e13 ? g4(e13.x, e13.y, this.defaultZ) : null;
  }
};
function F2(t10, r8) {
  if ("2d" === t10.type) return new v(t10.state.transform, t10.spatialReference, r8.length > 2 ? r8[2] : null);
  if ("3d" === t10.type) {
    const e13 = r8.length > 2 ? new _({ x: r8[0], y: r8[1], z: r8[2], spatialReference: t10.spatialReference }) : new _({ x: r8[0], y: r8[1], spatialReference: t10.spatialReference });
    return new W2(t10, e13);
  }
  return null;
}

// node_modules/@arcgis/core/views/draw/support/createUtils.js
function d6(t10, e13) {
  const o8 = new _({ x: t10[0], y: t10[1], spatialReference: e13 });
  return t10.length > 2 && (o8.z = t10[2]), o8;
}
function R7(t10, e13) {
  return new m2({ points: t10, spatialReference: e13 });
}
function j10(t10, e13, o8) {
  const n8 = new y({ paths: t10, spatialReference: e13 });
  return o8 && M(n8), n8;
}
function T2(t10, n8, r8, a12 = true) {
  const l9 = a(t10);
  l9.forEach(((t11) => {
    const o8 = t11[0], n9 = t11[t11.length - 1];
    h(o8, n9) && 1 !== t11.length || t11.push(t11[0]);
  }));
  let s3 = new P({ rings: l9, spatialReference: n8 });
  return s3.rings.forEach(((t11) => {
    a4(t11) || t11.reverse();
  })), r8 && M(s3), a12 && !c3(s3) && N(n8) && (s3 = u2(s3) || s3), s3;
}
function b4(e13, o8, n8) {
  const r8 = o8.mapToLocalMultiple(e13), a12 = [], l9 = { x: r8[0].x, y: r8[0].y }, s3 = { x: r8[1].x, y: r8[1].y }, i9 = Math.round(s3.x - l9.x), c14 = Math.round(s3.y - l9.y), p7 = Math.max(Math.abs(i9), Math.abs(c14));
  if (n8) {
    const t10 = { x: l9.x + p7, y: l9.y + p7 }, e14 = { x: l9.x - p7, y: l9.y - p7 };
    a12.push(w5(t10.x, e14.y), w5(e14.x, e14.y), w5(e14.x, t10.y), w5(t10.x, t10.y));
  } else {
    const t10 = { x: i9 > 0 ? l9.x + p7 : l9.x - p7, y: c14 > 0 ? l9.y + p7 : l9.y - p7 };
    a12.push(w5(l9.x, l9.y), w5(t10.x, l9.y), w5(t10.x, t10.y), w5(l9.x, t10.y));
  }
  return P4(T2([a12.map(((t10) => o8.localToMap(t10))).filter(L)], o8.spatialReference, o8.doUnnormalization, true), a12, o8);
}
function U2(e13, o8, n8) {
  let r8 = o8.mapToLocalMultiple(e13);
  if (1 === r8.length) {
    const t10 = 48, e14 = r8[0];
    r8 = [w5(e14.x - t10, e14.y + t10), w5(e14.x + t10, e14.y - t10), w5(e14.x + t10, e14.y - t10), w5(e14.x - t10, e14.y + t10)];
  }
  const a12 = [], l9 = { x: r8[0].x, y: r8[0].y }, s3 = { x: r8[1].x, y: r8[1].y };
  if (n8) {
    const t10 = Math.round(s3.x - l9.x), e14 = Math.round(s3.y - l9.y);
    a12.push(w5(l9.x - t10, l9.y - e14), w5(s3.x, l9.y - e14), w5(s3.x, s3.y), w5(l9.x - t10, s3.y));
  } else a12.push(w5(l9.x, l9.y), w5(s3.x, l9.y), w5(s3.x, s3.y), w5(l9.x, s3.y));
  return P4(T2([a12.map(((t10) => o8.localToMap(t10))).filter(L)], o8.spatialReference, o8.doUnnormalization, true), a12, o8);
}
function P4(t10, e13, o8) {
  const n8 = z3(e13[3], e13[2], o8), r8 = z3(e13[1], e13[2], o8), a12 = z3(e13[0], e13[1], o8), l9 = z3(e13[0], e13[3], o8);
  return { geometry: t10, midpoints: null != n8 && null != r8 && null != a12 && null != l9 ? { top: n8, right: r8, bottom: a12, left: l9 } : null };
}
function z3(t10, e13, o8) {
  I2[0] = t10.x, I2[1] = t10.y, I2[2] = 0, L4[0] = e13.x, L4[1] = e13.y, L4[2] = 0, I(I2, I2, L4, 0.5), w6.x = I2[0], w6.y = L4[1], w6.z = L4[2];
  const n8 = o8.localToMap(w6);
  return null != n8 ? d6(n8, o8.spatialReference) : null;
}
var w6 = w5(0, 0, 0);
var I2 = n();
var L4 = n();
function k5(t10, e13, o8, r8) {
  const a12 = e13.mapToLocalMultiple(t10);
  let s3 = null, i9 = null;
  if (o8) s3 = a12[0], i9 = a12[1];
  else {
    const t11 = a12[0], e14 = a12[1], o9 = Math.round(e14.x - t11.x), n8 = Math.round(e14.y - t11.y), r9 = Math.max(Math.abs(o9), Math.abs(n8));
    s3 = w5(o9 > 0 ? t11.x + r9 / 2 : t11.x - r9 / 2, n8 > 0 ? t11.y + r9 / 2 : t11.y - r9 / 2), i9 = w5(Math.abs(o9) > Math.abs(n8) ? s3.x - r9 / 2 : s3.x, Math.abs(o9) > Math.abs(n8) ? s3.y : s3.y - r9 / 2);
  }
  const c14 = e13.localToMap(s3), p7 = e13.localToMap(i9);
  if (null == c14 || null == p7) return null;
  e13.doUnnormalization && z2([[c14, p7]], e13.spatialReference);
  const u9 = d6(c14, e13.spatialReference), m7 = d6(p7, e13.spatialReference), x5 = Z(e13.spatialReference);
  let h9 = 0;
  if (N(e13.spatialReference)) h9 = x5 * c2(u9, m7);
  else {
    const t11 = s3.x - i9.x, e14 = s3.y - i9.y;
    h9 = x5 * Math.sqrt(t11 * t11 + e14 * e14) * (r8 || 1);
  }
  const R11 = new b3({ center: u9, radius: h9, radiusUnit: "meters", spatialReference: e13.spatialReference });
  return { geometry: T2(R11.rings, R11.spatialReference, false), center: u9, edge: m7 };
}
function v2(e13, o8, n8) {
  const r8 = o8.mapToLocalMultiple(e13), a12 = r8[0], l9 = r8[1], s3 = Math.round(l9.x - a12.x), i9 = Math.round(l9.y - a12.y), c14 = w5(n8 ? a12.x : a12.x + s3 / 2, n8 ? a12.y : a12.y + i9 / 2), p7 = n8 ? s3 : s3 / 2, y6 = n8 ? i9 : i9 / 2, u9 = 60, m7 = [], f9 = 2 * Math.PI / u9;
  function x5(t10) {
    const e14 = Math.cos(t10), o9 = Math.sin(t10);
    return w5(p7 * e14 + c14.x, y6 * o9 + c14.y);
  }
  for (let t10 = 0; t10 < u9; t10++) m7.push(x5(t10 * f9));
  m7.push(m7[0]);
  const { spatialReference: h9, doUnnormalization: M6 } = o8, R11 = T2([m7.map(((t10) => o8.localToMap(t10))).filter(L)], h9, M6, false), j13 = o8.localToMap(x5(Math.PI / 2)), b7 = o8.localToMap(x5(0)), U6 = o8.localToMap(x5(-Math.PI / 2)), P8 = o8.localToMap(x5(Math.PI));
  return { geometry: R11, midpoints: null != j13 && null != b7 && null != U6 && null != P8 ? { top: d6(j13, h9), right: d6(b7, h9), bottom: d6(U6, h9), left: d6(P8, h9) } : null };
}

// node_modules/@arcgis/core/views/draw/support/helpMessageUtils.js
function e11(e13, i9, a12) {
  if (null == e13) return "noTool";
  switch (e13) {
    case "point":
      return n7();
    case "multipoint":
      return "multipoint";
    case "polyline":
      return r7(i9, a12);
    case "polygon":
      return t8(i9, a12);
    case "rectangle":
    case "circle":
      return l7(i9, a12);
    default:
      return;
  }
}
function n7(e13) {
  return "point";
}
function r7(e13, n8) {
  const r8 = null != e13 && "polyline" === e13.type && e13.paths.length ? e13.paths[0].length : 0;
  return "freehand" === n8 ? r8 < 2 ? "freehandStart" : "freehandEnd" : r8 < 2 ? "polylineZeroVertices" : "polylineOneVertex";
}
function t8(e13, n8) {
  const r8 = null != e13 && "polygon" === e13.type && e13.rings.length ? e13.rings[0].length : 0;
  if (r8 < 3) switch (n8) {
    case "freehand":
      return "freehandStart";
    case "hybrid":
      return "polygonZeroVerticesHybrid";
    default:
      return "polygonZeroVertices";
  }
  else if (r8 < 4) return "freehand" === n8 ? "freehandEnd" : "polygonOneVertex";
  return "polygonTwoVertices";
}
function l7(e13, n8) {
  if ((null != e13 && "polygon" === e13.type && e13.rings.length ? e13.rings[0].length : 0) < 3) switch (n8) {
    case "freehand":
      return "freehandStart";
    case "click":
      return "shapeStartClick";
    default:
      return "shapeStartHybrid";
  }
  switch (n8) {
    case "freehand":
      return "freehandEnd";
    case "click":
      return "shapeEndClick";
    default:
      return "shapeEndHybrid";
  }
}

// node_modules/@arcgis/core/views/draw/support/helpMessageUtils3d.js
function i4(o8, i9) {
  const l9 = o8?.geometry;
  if (!o8 || "mesh" !== l9?.type || !i9) return;
  const { renderCoordsHelper: p7, elevationProvider: u9 } = i9, { camera: h9 } = i9.state, { extent: d10 } = l9, { center: x5, spatialReference: g7 } = d10, v6 = Z(g7), j13 = V2(g7), z8 = Z(p7.spatialReference), y6 = d10.width * v6, C3 = d10.height * j13, R11 = (d10.zmax ?? 0) * j13, U6 = R11 - (d10.zmin ?? 0) * j13, b7 = Math.max(y6, C3, U6) / z8, { x: w8, y: P8 } = x5, S6 = x5.z ?? 0;
  o4(f6, w8, P8, S6), p7.toRenderCoords(f6, g7, f6);
  const T6 = b7 / h9.computeScreenPixelSizeAt(f6);
  if (T6 > h9.width * a11) return "meshTooClose";
  if (T6 < m4) return "meshTooFar";
  const k7 = a6(o8), { absoluteZ: A5 } = b2(w8, P8, R11, g7, i9, k7);
  return A5 < (u9.getElevation(w8, P8, S6, g7, "ground") ?? 0) * j13 + U6 * c10 ? "meshUnderground" : "mesh";
}
var m4 = 20;
var a11 = 1;
var c10 = 0.1;
var f6 = n();

// node_modules/@arcgis/core/views/interactive/sketch/constraintUtils.js
function Z2(e13, n8, t10, r8, o8, i9) {
  let l9 = "geodesic", u9 = N2(t10);
  const s3 = c7();
  return E2(e13, n8, r8, s3), s3[2] = 0, u9 && n3(s3, t10, s3, u9) || (l9 = "euclidean", u9 = t10), { mode: l9, view: n8, elevationInfo: r8, hasZ: o8, directionMode: i9, spatialReference: e13.spatialReference, measurementSR: u9, origin: s3 };
}
function b5(n8, t10, o8) {
  if (null == t10 || null == n8) return;
  const i9 = ae(o8.measurementSR);
  if (null == i9) return;
  const l9 = G(n8, o8);
  if (null == l9) return;
  const u9 = f4(t10, i9);
  return new yt(l9, u9);
}
function A2(e13, t10, r8, o8) {
  if (null == r8 || null == e13) return;
  const i9 = G(e13, o8);
  if (null == i9) return;
  const l9 = T(r8), u9 = 10, s3 = (e14) => {
    if (null == e14) return;
    const t11 = c7(), r9 = o5(e14, "degrees", "geographic");
    return M3(t11, i9, o8.measurementSR, u9, r9, o8.mode) ? new Et(i9, t11) : void 0;
  }, c14 = () => {
    if (null != t10 && null != e13) return T(R2(t10, e13));
  };
  switch (o8.directionMode) {
    case j8.Absolute:
      return s3(l9);
    case j8.Relative: {
      const e14 = c14();
      if (null == e14) return;
      return s3(e14 + l9);
    }
    case j8.RelativeBilateral: {
      const e14 = c14();
      if (null == e14) return;
      return ge([s3(e14 + l9), s3(e14 - l9)]);
    }
  }
}
function B(e13, n8) {
  const t10 = C(e13, n8);
  return null != t10 ? new qt(t10) : void 0;
}
function P5(e13, n8, t10) {
  const { context: r8, longitude: o8, latitude: i9, direction: l9, distance: u9, elevation: s3 } = t10;
  if (null != o8 || null != i9 || null != u9 || null != s3 || null != l9) {
    if (null != o8 || null != i9) {
      const e14 = T(o8), n9 = T(i9), t11 = C(s3, r8);
      return new Zt(e14, n9, t11);
    }
    return T3(e13, n8, t10);
  }
}
function T3(n8, t10, { context: r8, direction: o8, distance: i9, elevation: l9 }) {
  if (null == t10) return B(l9, r8);
  const { view: u9, elevationInfo: s3, measurementSR: a12 } = r8, f9 = E2(t10, u9, s3);
  if (!a12 || !n3(f9, t10.spatialReference, E5, a12)) return;
  const [m7, d10] = E5, p7 = null != i9 ? f4(i9, "meters") : void 0, g7 = T(o8), R11 = C(l9, r8), y6 = (e13) => {
    const n9 = new It([m7, d10], a12, p7, R11, e13);
    return null == p7 || null == e13 || null == R11 && r8.hasZ ? n9 : new gt(n9.closestTo(f9));
  };
  if (null == g7) return y6(void 0);
  const x5 = () => {
    if (null != n8 && null != t10) return T(R2(n8, t10));
  };
  switch (r8.directionMode) {
    case j8.Absolute:
      return y6(g7);
    case j8.Relative: {
      const e13 = x5();
      if (null == e13) return;
      return y6(e13 + g7);
    }
    case j8.RelativeBilateral: {
      const e13 = x5();
      if (null == e13) return;
      return ge([y6(e13 + g7), y6(e13 - g7)]);
    }
  }
}
function V4(e13) {
  return "geodesic" === e13.context.mode ? P5(null, null, e13) : q(e13);
}
function k6(e13, n8, t10) {
  const { context: r8, x: o8, y: i9, distance: l9, direction: u9, elevation: s3 } = t10;
  return "geodesic" === r8.mode ? P5(n8, e13, t10) : null != o8 || null != i9 ? q(t10) : z4([b5(e13, l9, r8), A2(e13, n8, u9, r8), B(s3, r8)]);
}
function q({ x: e13, y: n8, elevation: t10, context: r8 }) {
  J2.x = e13?.value ?? 0, J2.y = n8?.value ?? 0, J2.spatialReference = r8.spatialReference;
  const o8 = G(J2, r8, F3);
  return new Zt(null != e13 && null != o8 ? o8[0] : void 0, null != n8 && null != o8 ? o8[1] : void 0, C(t10, r8));
}
function z4(e13) {
  let n8;
  for (const t10 of e13) t10 && (n8 = n8?.intersect(t10) ?? t10);
  return n8;
}
function G(e13, n8, t10 = c7()) {
  const { view: r8, elevationInfo: o8, measurementSR: l9, origin: u9, mode: s3 } = n8;
  if (E2(e13, r8, o8, t10), n3(t10, e13.spatialReference, t10, l9)) return "geodesic" !== s3 && c4(t10, t10, u9), t10;
}
function W3(e13, n8, t10, r8) {
  const { view: o8, measurementSR: i9, spatialReference: s3, origin: a12, mode: f9 } = t10;
  if ("geodesic" === f9 ? s2(H2, e13) : u4(H2, e13, a12), n3(H2, i9, H2, s3)) return h4(H2, o8, n8, t10, r8);
}
function C(e13, n8) {
  return D2(e13, n8)?.value ?? void 0;
}
function D2(n8, { view: r8, origin: i9, elevationInfo: l9, hasZ: u9, measurementSR: s3 }) {
  if (null == n8 || !u9) return;
  const c14 = re(s3);
  if (null == c14) return;
  const [a12, f9] = i9, d10 = f4(n8, c14), p7 = "3d" === r8?.type ? E(r8, a12, f9, d10, s3, l9) : d10;
  return null != p7 ? a7(p7, c14) : void 0;
}
var E5 = c7();
var F3 = c7();
var H2 = c7();
var J2 = e5(0, 0, 0, f.WGS84);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawCircleTooltipInfo.js
var i5 = class extends r5 {
  constructor(o8) {
    super(o8), this.type = "draw-circle", this.radius = null, this.xSize = null, this.ySize = null, this.area = d4;
  }
  get allFields() {
    return [];
  }
};
r([m()], i5.prototype, "type", void 0), r([m()], i5.prototype, "radius", void 0), r([m()], i5.prototype, "xSize", void 0), r([m()], i5.prototype, "ySize", void 0), r([m()], i5.prototype, "area", void 0), r([m()], i5.prototype, "helpMessage", void 0), r([m()], i5.prototype, "allFields", null), i5 = r([a2("esri.views.interactive.tooltip.infos.DrawCircleTooltipInfo")], i5);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawMeshTooltipInfo.js
var p3 = class extends h5(r5) {
  constructor(o8) {
    super(o8), this.type = "draw-mesh", this.orientation = k4({ lockable: false }), this.scale = R4({ lockable: false });
  }
  get allFields() {
    return [this.longitude, this.latitude, this.x, this.y, this.elevation, this.orientation, this.scale];
  }
};
r([m()], p3.prototype, "helpMessage", void 0), r([m()], p3.prototype, "allFields", null), p3 = r([a2("esri.views.interactive.tooltip.infos.DrawMeshTooltipInfo")], p3);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawMultipointTooltipInfo.js
var i6 = class extends h5(r5) {
  constructor(o8) {
    super(o8), this.type = "draw-multipoint";
  }
  get allFields() {
    return [this.longitude, this.latitude, this.x, this.y, this.elevation];
  }
};
r([m()], i6.prototype, "helpMessage", void 0), r([m()], i6.prototype, "allFields", null), i6 = r([a2("esri.views.interactive.tooltip.infos.DrawMultipointTooltipInfo")], i6);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawPointTooltipInfo.js
var i7 = class extends h5(r5) {
  constructor(o8) {
    super(o8), this.type = "draw-point";
  }
  get allFields() {
    return [this.longitude, this.latitude, this.x, this.y, this.elevation];
  }
};
r([m()], i7.prototype, "helpMessage", void 0), r([m()], i7.prototype, "allFields", null), i7 = r([a2("esri.views.interactive.tooltip.infos.DrawPointTooltipInfo")], i7);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawPolygonTooltipInfo.js
var c11 = class extends h5(r5) {
  constructor(o8) {
    super(o8), this.type = "draw-polygon", this.direction = y3(), this.distance = F(), this.area = Q2(), this.xyMode = "direction-distance";
  }
  get allFields() {
    return [this.direction, this.distance, this.longitude, this.latitude, this.x, this.y, this.elevation, this.area];
  }
};
r([m()], c11.prototype, "xyMode", void 0), r([m()], c11.prototype, "helpMessage", void 0), r([m()], c11.prototype, "allFields", null), c11 = r([a2("esri.views.interactive.tooltip.infos.DrawPolygonTooltipInfo")], c11);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawPolylineTooltipInfo.js
var c12 = class extends h5(r5) {
  constructor(t10) {
    super(t10), this.type = "draw-polyline", this.direction = y3(), this.distance = F(), this.totalLength = w4(), this.xyMode = "direction-distance";
  }
  get allFields() {
    return [this.direction, this.distance, this.longitude, this.latitude, this.x, this.y, this.elevation, this.totalLength];
  }
};
r([m()], c12.prototype, "helpMessage", void 0), r([m()], c12.prototype, "xyMode", void 0), r([m()], c12.prototype, "allFields", null), c12 = r([a2("esri.views.interactive.tooltip.infos.DrawPolylineTooltipInfo")], c12);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawRectangleTooltipInfo.js
var p4 = class extends r5 {
  constructor(o8) {
    super(o8), this.type = "draw-rectangle", this.xSize = h3, this.ySize = h3, this.area = d4;
  }
  get allFields() {
    return [];
  }
};
r([m()], p4.prototype, "type", void 0), r([m()], p4.prototype, "xSize", void 0), r([m()], p4.prototype, "ySize", void 0), r([m()], p4.prototype, "area", void 0), r([m()], p4.prototype, "helpMessage", void 0), r([m()], p4.prototype, "allFields", null), p4 = r([a2("esri.views.interactive.tooltip.infos.DrawRectangleTooltipInfo")], p4);

// node_modules/@arcgis/core/views/draw/support/tooltipUtils.js
function D3(e13, t10) {
  return { point: new i7({ sketchOptions: t10, viewType: e13 }), multipoint: new i6({ sketchOptions: t10, viewType: e13 }), polyline: new c12({ sketchOptions: t10, viewType: e13 }), polygon: new c11({ sketchOptions: t10, viewType: e13 }), mesh: new p3({ sketchOptions: t10, viewType: e13 }), rectangle: new p4({ sketchOptions: t10 }), circle: new i5({ sketchOptions: t10 }) };
}
function T4(e13) {
  const { directionOptions: t10, geometryType: o8, sketchOptions: n8, tooltipInfos: i9 } = e13, r8 = (t11) => {
    const o9 = N4(e13).mode, n9 = i9[t11].elevation;
    "relative-to-ground" === o9 || "relative-to-scene" === o9 || "on-the-ground" === o9 ? n9.lock(W4(e13)) : n9.unlock();
  }, a12 = (e14) => {
    if (t10) {
      const o9 = i9[e14].direction;
      o9.committed = t10.angle, o9.unlockOnVertexPlacement = false, n8.values.directionMode = t10.mode;
    }
  };
  switch (o8) {
    case "polygon":
    case "polyline":
      r8(o8), a12(o8);
      break;
    case "point":
    case "mesh":
      r8(o8);
  }
}
function j11(e13, t10) {
  const { drawOperation: o8, view: n8 } = t10, i9 = b6(t10), r8 = N4(t10);
  if ("2d" === n8.type || !e13 || "absolute-height" !== r8.mode || 1 !== o8?.numCommittedVertices || !i9 || "draw-polyline" !== i9.type && "draw-polygon" !== i9.type || i9.elevation.locked) return;
  const [a12, c14, l9] = e13, s3 = K2(a12, c14, l9, r8, t10);
  null != s3 && i9.elevation.lock(s3);
}
function U3(e13) {
  b6(e13)?.allFields.forEach(((e14) => {
    e14.unlockOnVertexPlacement && e14.unlock();
  }));
}
function b6({ geometryType: e13, graphic: t10, tooltipInfos: o8 }) {
  return t10?.geometry?.type !== P6[e13] ? "circle" === e13 || "rectangle" === e13 ? o8[e13] : null : o8[e13];
}
var P6 = { point: "point", multipoint: "multipoint", mesh: "mesh", polyline: "polyline", polygon: "polygon", circle: "polygon", rectangle: "polygon", freehandPolygon: "polygon", freehandPolyline: "polyline" };
function I3(e13, t10) {
  switch (e13?.type) {
    case "draw-point":
      L5(e13, t10);
      break;
    case "draw-multipoint":
      V5(e13, t10);
      break;
    case "draw-polyline":
      z5(e13, t10);
      break;
    case "draw-polygon":
      A3(e13, t10);
      break;
    case "draw-rectangle":
      F4(e13, t10);
      break;
    case "draw-circle":
      H3(e13, t10);
      break;
    case "draw-mesh":
      G2(e13, t10);
  }
}
function L5(e13, t10) {
  const o8 = t10.graphic?.geometry;
  "point" === o8?.type && (S2(e13, o8, t10), e13.helpMessage = e11("point", o8, t10.drawOperation.drawingMode));
}
function V5(e13, t10) {
  const o8 = t10.graphic?.geometry;
  "multipoint" === o8?.type && (S2(e13, o8, t10), e13.helpMessage = e11("multipoint", o8, t10.drawOperation.drawingMode));
}
function G2(e13, t10) {
  const { graphic: o8, view: n8 } = t10, i9 = o8?.geometry;
  "3d" !== n8.type || i9 && "mesh" !== i9.type || (S2(e13, i9?.origin, t10), i9 && V3(e13, i9), e13.helpMessage = i4(o8, n8));
}
function S2(e13, t10, o8) {
  const { drawOperation: n8, view: i9, sketchOptions: r8 } = o8, { cursorVertex: a12 } = n8;
  e13.sketchOptions = r8, e13.viewType = i9.type;
  const c14 = "multipoint" === t10?.type ? t10.getPoint(t10.points.length - 1) : t10;
  if (e13.setLocationFromPoint(c14, Q3(o8)), R8(e13.elevation, o8), !a12) return void (n8.constraints = void 0);
  const l9 = a12;
  n8.constraints = { context: $(l9, o8), x: e13.x.committed, y: e13.y.committed, longitude: e13.longitude.committed, latitude: e13.latitude.committed, elevation: e13.elevation.committed, distance: null, direction: null };
}
function z5(e13, t10) {
  const { createOperationGeometry: n8, drawOperation: i9, automaticLengthMeasurementUtils: r8 } = t10, a12 = null != n8 ? n8.full : null;
  a12 && "polyline" !== a12.type || (Z3(e13, t10), e13.totalLength.actual = i9.lastVertex ? (a12 ? r8.autoLength2D(a12) : null) ?? h3 : null, e13.helpMessage = e11("polyline", a12, t10.drawOperation.drawingMode));
}
function A3(e13, o8) {
  const { createOperationGeometry: n8, drawOperation: i9 } = o8, r8 = null != n8 ? n8.full : null;
  r8 && "polygon" !== r8.type || (Z3(e13, o8), e13.area.actual = i9.lastVertex ? (r8 ? o8.automaticAreaMeasurementUtils.autoArea2D(r8) : null) ?? d4 : null, e13.helpMessage = e11("polygon", r8, o8.drawOperation.drawingMode));
}
var B2 = w(_);
function Z3(e13, t10) {
  const { drawOperation: n8, sketchOptions: r8, view: a12, automaticLengthMeasurementUtils: c14 } = t10, { cursorVertex: l9, lastVertex: s3, secondToLastVertex: p7 } = n8, u9 = r8.values.effectiveDirectionMode;
  e13.sketchOptions = r8, e13.viewType = a12.type;
  const m7 = s3 && l9 ? c14.autoDistanceBetweenPoints2D(B2(s3), B2(l9)) ?? h3 : null;
  if (e13.distance.actual = m7, e13.distance.readOnly = null == s3, e13.direction.actual = null, e13.direction.readOnly = true, s3 && l9 && ("absolute" === u9 || p7)) {
    const t11 = x2(p7, s3, l9, u9);
    e13.direction.actual = t11 ?? j6, e13.direction.readOnly = false;
  }
  e13.setLocationFromPoint(l9, Q3(t10)), R8(e13.elevation, t10);
  const d10 = C2(s3, t10);
  e13.xyMode = d10, e13.direction.visible = "direction-distance" === d10, e13.distance.visible = "direction-distance" === d10, e13.effectiveX.visible = "coordinates" === d10, e13.effectiveY.visible = "coordinates" === d10;
  const f9 = l9 ?? s3;
  n8.constraints = f9 ? { context: $(f9, t10), x: e13.x.committed, y: e13.y.committed, longitude: e13.longitude.committed, latitude: e13.latitude.committed, elevation: e13.elevation.committed, distance: e13.distance.committed, direction: e13.direction.committed } : void 0;
}
function C2(e13, { sketchOptions: t10 }) {
  const o8 = t10.tooltips.xyMode;
  return "auto" === o8 ? e13 ? "direction-distance" : "coordinates" : o8;
}
function F4(e13, t10) {
  e13.sketchOptions = t10.sketchOptions, e13.xSize = E6(t10), e13.ySize = X(t10), e13.area = q2(t10), e13.helpMessage = e11("rectangle", t10.graphic?.geometry, t10.drawOperation.drawingMode);
}
function H3(e13, t10) {
  const { forceUniformSize: o8, sketchOptions: n8 } = t10;
  e13.sketchOptions = n8, e13.radius = o8 ? Y(t10) : null, e13.xSize = o8 ? null : E6(t10), e13.ySize = o8 ? null : X(t10), e13.area = q2(t10), e13.helpMessage = e11("circle", t10.graphic?.geometry, t10.drawOperation.drawingMode);
}
function R8(e13, t10) {
  const { drawOperation: o8 } = t10, n8 = o8?.cursorVertex ?? o8?.lastVertex;
  e13.actual = R5(n8) ?? W4(t10), e13.visible = o8.hasZ, e13.readOnly = false, e13.showAsZ = true;
}
function q2(e13) {
  const o8 = e13.createOperationGeometry?.full;
  return "polygon" !== o8?.type ? d4 : e13.automaticAreaMeasurementUtils.autoArea2D(o8) ?? d4;
}
function E6({ createOperationGeometry: e13, automaticLengthMeasurementUtils: t10 }) {
  const n8 = e13?.rectangle?.midpoints;
  return (null != n8 ? t10.autoDistanceBetweenPoints2D(n8.left, n8.right) : null) ?? h3;
}
function X({ createOperationGeometry: e13, automaticLengthMeasurementUtils: t10 }) {
  const n8 = e13?.rectangle?.midpoints;
  return (null != n8 ? t10.autoDistanceBetweenPoints2D(n8.top, n8.bottom) : null) ?? h3;
}
function Y({ createOperationGeometry: e13, automaticLengthMeasurementUtils: t10 }) {
  return (null != e13?.circle?.center && null != e13.circle.edge ? t10.autoDistanceBetweenPoints2D(e13.circle.center, e13.circle.edge) : null) ?? h3;
}
function J3(t10) {
  const { geometryType: o8, tooltipInfos: n8 } = t10;
  switch (o8) {
    case "point":
    case "multipoint":
    case "mesh":
    case "polyline":
    case "polygon": {
      const i9 = n8[o8].elevation.committed;
      if (!i9) return;
      return f4(i9, "meters") / V2(Q3(t10));
    }
    default:
      return;
  }
}
function K2(e13, t10, o8, n8, i9) {
  const { view: r8, drawOperation: a12 } = i9;
  if ("3d" !== r8.type || !a12) return;
  o8 ??= 0;
  const c14 = Q3(i9), l9 = N4(i9), p7 = E(r8, e13, t10, o8, c14, l9, n8);
  return j9(p7, c14) ?? W4(i9);
}
function N4(e13) {
  return e13.drawOperation.elevationInfo ?? j5;
}
function Q3(e13) {
  return e13.drawOperation.coordinateHelper.spatialReference;
}
function W4(e13) {
  const t10 = V2(Q3(e13));
  return a7(e13.defaultZ * t10, "meters");
}
function $(e13, t10) {
  return Z2(e13, t10.view, Q3(t10), N4(t10), t10.drawOperation.coordinateHelper.hasZ(), t10.sketchOptions.values.effectiveDirectionMode);
}

// node_modules/@arcgis/core/views/draw/DrawGraphicTool.js
var E7 = class extends o2.EventedMixin(n4) {
  constructor(t10) {
    super(t10), this._graphic = null, this._coordinateFormatterLoadTask = null, this._createOperationGeometry = null, this.defaultZ = 0, this.directionOptions = null, this.elevationLockOnVertexAddDisabled = false, this.geometryType = null, this.hasZ = true, this.geometryToPlace = null, this.snappingManager = null, this.snapToScene = false, this.sketchOptions = new l5();
  }
  initialize() {
    const { view: t10 } = this;
    this.internalGraphicsLayer = new c6({ listMode: "hide", internal: true }), this.view.map.layers.add(this.internalGraphicsLayer);
    const e13 = this.drawOperation = this.makeDrawOperation();
    this.tooltipInfos = D3(t10.type, this.sketchOptions);
    const o8 = R3((() => ({ view: t10, options: this.sketchOptions.tooltips })));
    this.tooltip = o8, T4(this._tooltipsContext), this._coordinateFormatterLoadTask = d2((() => E3())), this.addHandles([e13.on("vertex-add", ((t11) => this.onVertexAdd(t11))), e13.on("vertex-remove", ((t11) => this.onVertexRemove(t11))), e13.on("vertex-update", ((t11) => this.onVertexUpdate(t11))), e13.on("cursor-update", ((t11) => this.onCursorUpdate(t11))), e13.on("cursor-remove", (() => this._updateGraphic())), e13.on("complete", ((t11) => this.onComplete(t11))), this._coordinateFormatterLoadTask, o8.on("paste", ((t11) => J(t11, this.activeTooltipInfo))), l2((() => this.cursor), ((t11) => {
      e13.cursor = t11;
    }), w2), i((() => {
      const { activeTooltipInfo: t11, sketchOptions: e14 } = this;
      I3(t11, this._tooltipsContext), o8.info = e14.tooltips.effectiveEnabled ? t11 : null;
    })), i((() => {
      e13.constraintZ = J3(this._tooltipsContext);
    }), U)]), this.finishToolCreation();
  }
  destroy() {
    this.drawOperation = u(this.drawOperation), this.tooltip = u(this.tooltip), this._destroyAllVisualizations(), this.view.map.remove(this.internalGraphicsLayer), this.internalGraphicsLayer = u(this.internalGraphicsLayer), this._set("view", null);
  }
  get _drawSpatialReference() {
    return this.drawOperation.coordinateHelper.spatialReference;
  }
  get _tooltipsContext() {
    const { defaultZ: t10, directionOptions: e13, drawOperation: o8, forceUniformSize: r8, geometryType: i9, graphic: s3, sketchOptions: n8, tooltipInfos: a12, view: l9, automaticAreaMeasurementUtils: p7, automaticLengthMeasurementUtils: c14 } = this;
    return { createOperationGeometry: this._createOperationGeometry, defaultZ: t10, directionOptions: e13, drawOperation: o8, forceUniformSize: r8, geometryType: i9, graphic: s3, sketchOptions: n8, tooltipInfos: a12, view: l9, automaticAreaMeasurementUtils: p7, automaticLengthMeasurementUtils: c14 };
  }
  get canRedo() {
    return this.drawOperation.canRedo;
  }
  get canUndo() {
    return this.drawOperation.canUndo;
  }
  set centered(t10) {
    this._set("centered", t10), this._updateGraphic();
  }
  get cursor() {
    return this._get("cursor");
  }
  set cursor(t10) {
    this._set("cursor", t10);
  }
  set enabled(t10) {
    this.drawOperation.interactive = t10, this._set("enabled", t10);
  }
  set forceUniformSize(t10) {
    this._set("forceUniformSize", t10), this._updateGraphic();
  }
  get graphic() {
    return this._graphic;
  }
  set graphicSymbol(t10) {
    this._set("graphicSymbol", t10), null != this._graphic && (this._graphic.symbol = t10);
  }
  set mode(t10) {
    const e13 = this.drawOperation;
    e13 && (e13.drawingMode = t10), this._set("mode", t10);
  }
  get updating() {
    return this.drawOperation?.updating ?? false;
  }
  get undoRedo() {
    const { view: { type: t10, map: e13 } } = this;
    return "2d" === t10 && e13 && "undoRedo" in e13 && e13.undoRedo instanceof u7 ? e13.undoRedo : null;
  }
  set undoRedo(t10) {
    this._override("undoRedo", t10);
  }
  completeCreateOperation() {
    this.drawOperation.complete();
  }
  onInputEvent(t10) {
    this.destroyed || H(t10, this.tooltip) || this.drawOperation.onInputEvent(t10);
  }
  redo() {
    this.drawOperation.redo();
  }
  reset() {
  }
  undo() {
    this.drawOperation.undo(), 0 === this.drawOperation.numCommittedVertices && T4(this._tooltipsContext);
  }
  _destroyAllVisualizations() {
    this.removeHandles(I4.outline), this.removeHandles(I4.regularVertices), this.removeHandles(I4.activeVertex), this.removeHandles(I4.activeEdge), this.removeHandles(M4);
  }
  _createOrUpdateGraphic(t10) {
    if (null != this._graphic) return this.updateGraphicGeometry(t10), this._graphic;
    const o8 = new d3({ ...this.graphicProperties, symbol: this.graphicSymbol });
    return this._graphic = o8, this.updateGraphicGeometry(t10), this.internalGraphicsLayer.add(o8), this.addHandles(this.initializeGraphic(o8)), this.notifyChange("graphic"), this.addHandles(e((() => {
      this.internalGraphicsLayer.remove(o8), this._graphic === o8 && (this._graphic = null);
    })), M4), o8;
  }
  updateGraphicGeometry(t10) {
    this._graphic.geometry = t10;
  }
  _getCreateOperationGeometry(t10 = { operationComplete: false }) {
    if (null == this.drawOperation) return;
    const { coordinateHelper: e13, view: o8, visualizationCursorVertex: r8, lastVertex: i9, committedVertices: s3, geometryIncludingUncommittedVertices: n8, numCommittedVertices: a12 } = this.drawOperation;
    if (!(a12 > 0 || null != r8)) return;
    const l9 = t10.operationComplete ? s3 : n8, p7 = l9.length, c14 = null != r8 ? e13.pointToArray(r8) : null, d10 = this._drawSpatialReference, h9 = "3d" === o8.type && "global" === o8.viewingMode, u9 = new l6();
    u9.committedVertices = s3, u9.cursorVertex = c14;
    const { geometryType: x5 } = this;
    switch (x5) {
      case "point":
      case "mesh":
        u9.full = e13.arrayToPoint(l9[0]);
        break;
      case "multipoint":
        u9.full = p7 > 0 ? R7(l9, d10) : null;
        break;
      case "polyline":
      case "polygon":
        p7 > 0 && (u9.full = "polygon" === x5 ? T2([l9], d10, h9, true) : j10([l9], d10, h9), u9.cursorEdge = null != c14 && i9 && !a5(r8, i9) ? j10([[c14, e13.pointToArray(i9)]], d10, h9) : null, u9.outline = p7 > 1 ? u9.full : null);
        break;
      case "circle":
      case "rectangle": {
        if (u9.committedVertices = u9.cursorVertex = null, !p7) break;
        const e14 = F2(o8, l9[0]), r9 = l9[0], i10 = e14.makeMapPoint(r9[0] + Z4 * o8.resolution, r9[1]);
        "circle" === x5 ? 1 === p7 && t10.operationComplete ? u9.circle = k5([r9, i10], e14, true) : 2 === p7 && (this.forceUniformSize ? u9.circle = k5(l9, e14, this.centered) : u9.rectangle = v2(l9, e14, this.centered)) : 1 === p7 && t10.operationComplete ? u9.rectangle = b4([r9, i10], e14, true) : 2 === p7 && (u9.rectangle = this.forceUniformSize ? b4(l9, e14, this.centered) : U2(l9, e14, this.centered)), u9.full = null != u9.circle ? u9.circle.geometry : u9.rectangle?.geometry, u9.outline = "polygon" === u9.full?.type ? u9.full : null;
        break;
      }
      default:
        return null;
    }
    return u9;
  }
  initializeGraphic(t10) {
    return e();
  }
  onComplete(t10) {
    if (!this.drawOperation) return;
    this._updateGraphic();
    let e13 = null;
    if (this.drawOperation.isCompleted) {
      const t11 = this._getCreateOperationGeometry({ operationComplete: true });
      null != t11 && (e13 = this._createOrUpdateGraphic(t11.full));
    }
    this._createOperationGeometry = null, this.emit("complete", { graphic: e13, ...t10 });
  }
  onCursorUpdate(t10) {
    this._updateGraphic(), this.emit("cursor-update", t10);
  }
  onDeactivate() {
    const { drawOperation: t10 } = this;
    t10 && (t10.isCompleted || t10.cancel());
  }
  onOutlineChanged(t10) {
    return e();
  }
  onCursorEdgeChanged(t10) {
    return e();
  }
  onVertexAdd(t10) {
    U3(this._tooltipsContext), this._updateGraphic(), this.elevationLockOnVertexAddDisabled || j11(t10.vertices.at(0)?.coordinates, this._tooltipsContext), this.emit("vertex-add", t10);
  }
  onVertexRemove(t10) {
    U3(this._tooltipsContext), this._updateGraphic(), this.emit("vertex-remove", t10);
  }
  onVertexUpdate(t10) {
    this._updateGraphic(), this.emit("vertex-update", t10);
  }
  _updateGraphic() {
    const t10 = this._getCreateOperationGeometry();
    this._createOperationGeometry = t10, null != t10 ? (null != t10.cursorEdge ? this.addHandles(this.onCursorEdgeChanged(t10.cursorEdge), I4.activeEdge) : this.removeHandles(I4.activeEdge), null != t10.outline ? this.addHandles(this.onOutlineChanged(t10.outline), I4.outline) : this.removeHandles(I4.outline), null != t10.committedVertices ? this.addHandles(this.onRegularVerticesChanged(t10.committedVertices), I4.regularVertices) : this.removeHandles(I4.regularVertices), null != t10.cursorVertex ? this.addHandles(this.onActiveVertexChanged(t10.cursorVertex), I4.activeVertex) : this.removeHandles(I4.activeVertex), null != t10.full ? this._createOrUpdateGraphic(t10.full) : this.removeHandles(M4)) : this._destroyAllVisualizations();
  }
  get activeTooltipInfo() {
    return this._coordinateFormatterLoadTask?.finished ? b6(this._tooltipsContext) : null;
  }
};
r([m()], E7.prototype, "_coordinateFormatterLoadTask", void 0), r([m()], E7.prototype, "_createOperationGeometry", void 0), r([m()], E7.prototype, "_tooltipsContext", null), r([m({ value: true })], E7.prototype, "centered", null), r([m()], E7.prototype, "cursor", null), r([m({ nonNullable: true })], E7.prototype, "defaultZ", void 0), r([m({ constructOnly: true })], E7.prototype, "directionOptions", void 0), r([m()], E7.prototype, "drawOperation", void 0), r([m()], E7.prototype, "elevationLockOnVertexAddDisabled", void 0), r([m({ value: true })], E7.prototype, "enabled", null), r([m({ value: true })], E7.prototype, "forceUniformSize", null), r([m({ constructOnly: true })], E7.prototype, "geometryType", void 0), r([m()], E7.prototype, "graphic", null), r([m({ constructOnly: true })], E7.prototype, "graphicProperties", void 0), r([m()], E7.prototype, "graphicSymbol", null), r([m({ constructOnly: true })], E7.prototype, "hasZ", void 0), r([m({ constructOnly: true })], E7.prototype, "geometryToPlace", void 0), r([m()], E7.prototype, "mode", null), r([m()], E7.prototype, "snappingManager", void 0), r([m()], E7.prototype, "snapToScene", void 0), r([m()], E7.prototype, "tooltip", void 0), r([m()], E7.prototype, "tooltipInfos", void 0), r([m({ constructOnly: true, type: l5 })], E7.prototype, "sketchOptions", void 0), r([m()], E7.prototype, "updating", null), r([m({ constructOnly: true, nonNullable: true })], E7.prototype, "view", void 0), r([m({ constructOnly: true })], E7.prototype, "automaticAreaMeasurementUtils", void 0), r([m({ constructOnly: true })], E7.prototype, "automaticLengthMeasurementUtils", void 0), r([m({ constructOnly: true })], E7.prototype, "undoRedo", null), r([m()], E7.prototype, "activeTooltipInfo", null), E7 = r([a2("esri.views.draw.DrawGraphicTool")], E7);
var M4 = Symbol("create-operation-graphic");
var I4 = { outline: Symbol("outline-visual"), regularVertices: Symbol("regular-vertices-visual"), activeVertex: Symbol("active-vertex-visual"), activeEdge: Symbol("active-edge-visual") };
function F5(t10) {
  switch (t10) {
    case "point":
    case "polyline":
    case "polygon":
    case "multipoint":
      return t10;
    case "circle":
    case "rectangle":
      return "segment";
    case "mesh":
      return "point";
  }
}
var Z4 = 48;

// node_modules/@arcgis/core/views/interactive/dragEventPipeline.js
function i8(t10, n8) {
  let e13 = null, r8 = null;
  return (a12) => {
    if ("cancel" === a12.action) return void (null != r8 && (r8.execute({ action: "cancel" }), e13 = null, r8 = null));
    const o8 = { action: a12.action, screenStart: a12.start, screenEnd: a12.screenPoint };
    "start" === a12.action && null == e13 && (e13 = new w7(), r8 = new w7(), n8(t10, e13, r8, a12.pointerType, o8)), null != e13 && e13.execute(o8), "end" === a12.action && null != e13 && (e13 = null, r8 = null);
  };
}
function p5(t10, n8) {
  return t10.events.on("drag", i8(t10, n8));
}
function m5(t10, n8) {
  const e13 = [t10.x, t10.y, t10.z ?? 0], r8 = n8, a12 = [Math.cos(r8), Math.sin(r8)], o8 = Math.sqrt(a12[0] * a12[0] + a12[1] * a12[1]);
  if (0 === o8) return null;
  a12[0] /= o8, a12[1] /= o8;
  const l9 = (t11) => {
    const n9 = (t11.x - e13[0]) * a12[0] + (t11.y - e13[1]) * a12[1];
    t11.x = e13[0] + n9 * a12[0], t11.y = e13[1] + n9 * a12[1];
  };
  return (t11) => (l9(t11.mapStart), l9(t11.mapEnd), { ...t11, axis: a12 });
}
function f7(t10) {
  let n8 = null;
  return (e13) => {
    if ("start" === e13.action && (n8 = y4(t10, e13.mapStart.spatialReference)), null == n8) return null;
    const r8 = e13.mapEnd.x - e13.mapStart.x, a12 = e13.mapEnd.y - e13.mapStart.y, o8 = (e13.mapEnd.z ?? 0) - (e13.mapStart.z ?? 0);
    return n8.move(r8, a12, o8, e13.action), { ...e13, translationX: r8, translationY: a12, translationZ: o8 };
  };
}
function d7(t10, n8) {
  return null == t10 ? null : t10.spatialReference.equals(n8) ? t10.clone() : O(t10, n8);
}
function y4(t10, n8) {
  const e13 = t10.operations;
  if (!e13) return null;
  const r8 = e13.data.geometry, l9 = k3(n8);
  if (r8.spatialReference.equals(l9)) return x3(t10, e13, (() => {
  }));
  if ("mesh" !== r8.type) {
    const n9 = d7(r8, l9);
    if (null == n9) return null;
    const o8 = r8.spatialReference;
    return x3(t10, E4.fromGeometry(n9, e13.viewingMode), (() => {
      const t11 = O(r8, o8);
      e13.trySetGeometry(t11);
    }));
  }
  if (c5(r8)) {
    const n9 = d7(r8.origin, l9);
    if (!n9) return null;
    const o8 = r8.spatialReference, c14 = E4.fromGeometry(n9, e13.viewingMode);
    return x3(t10, e13, (() => {
      const t11 = O(c14.data.geometry, o8), n10 = t11.x - r8.origin.x, l10 = t11.y - r8.origin.y, s3 = (t11.z ?? 0) - (r8.origin.z ?? 0);
      e13.move(n10, l10, s3);
    }));
  }
  return null;
}
function x3(t10, n8, e13) {
  let r8 = 0, a12 = 0, o8 = 0;
  return { move: (l9, c14, s3, u9) => {
    "start" === u9 && (r8 = 0, a12 = 0, o8 = 0);
    const i9 = l9 - r8, p7 = c14 - a12, m7 = s3 - o8;
    n8.move(i9, p7, m7), r8 += i9, a12 += p7, o8 += m7, e13(), "end" === u9 && t10.endInteraction?.();
  } };
}
function E8(t10, n8 = null, e13) {
  let r8 = null;
  const o8 = null == n8 || t10.spatialReference?.equals(n8) ? (t11) => t11 : (t11) => null != t11 ? O(t11, n8) : t11, l9 = { exclude: [], ...e13 };
  return (n9) => {
    if ("start" === n9.action && (r8 = o8(t10.toMap(n9.screenStart, l9))), null == r8) return null;
    const e14 = o8(t10.toMap(n9.screenEnd, l9));
    return null != e14 ? { ...n9, mapStart: r8, mapEnd: e14 } : null;
  };
}
function S3(n8) {
  const e13 = n8.map(((t10) => f7(t10))).filter(L);
  return (t10) => {
    const n9 = t10.mapEnd.x - t10.mapStart.x, r8 = t10.mapEnd.y - t10.mapStart.y, a12 = t10.mapEnd.z - t10.mapStart.z;
    return e13.forEach(((n10) => n10(t10))), { ...t10, translationX: n9, translationY: r8, translationZ: a12 };
  };
}
function g5(t10) {
  const n8 = t10.operations?.createResetState();
  return (t11) => (n8?.remove(), t11);
}
function z6(t10) {
  const n8 = t10.map(((t11) => g5(t11))).filter(((t11) => null != t11));
  return (t11) => (n8.forEach(((n9) => n9(t11))), t11);
}
function v3() {
  let t10 = 0, n8 = 0, e13 = 0;
  return (r8) => {
    "start" === r8.action && (t10 = r8.mapStart.x, n8 = r8.mapStart.y, e13 = r8.mapStart.z);
    const a12 = r8.mapEnd.x - t10, o8 = r8.mapEnd.y - n8, l9 = r8.mapEnd.z - e13;
    return t10 = r8.mapEnd.x, n8 = r8.mapEnd.y, e13 = r8.mapEnd.z, { ...r8, mapDeltaX: a12, mapDeltaY: o8, mapDeltaZ: l9, mapDeltaSpatialReference: r8.mapStart.spatialReference };
  };
}
function j12() {
  let t10 = 0, n8 = 0;
  return (e13) => {
    "start" === e13.action && (t10 = e13.screenStart.x, n8 = e13.screenStart.y);
    const r8 = e13.screenEnd.x - t10, a12 = e13.screenEnd.y - n8;
    return t10 = e13.screenEnd.x, n8 = e13.screenEnd.y, { ...e13, screenDeltaX: r8, screenDeltaY: a12 };
  };
}
function M5(t10, n8) {
  let a12 = null, o8 = 0, l9 = 0;
  return (c14) => {
    if ("start" === c14.action && (a12 = t10.toScreen?.(n8), null != a12 && (a12.x < 0 || a12.x > t10.width || a12.y < 0 || a12.y > t10.height ? a12 = null : (o8 = c14.screenStart.x - a12.x, l9 = c14.screenStart.y - a12.y))), null == a12) return null;
    const s3 = r3(c14.screenEnd.x - o8, 0, t10.width), u9 = r3(c14.screenEnd.y - l9, 0, t10.height), i9 = c(s3, u9);
    return c14.screenStart = a12, c14.screenEnd = i9, c14;
  };
}
var R9 = () => {
};
var w7 = class _w {
  constructor() {
    this.execute = R9;
  }
  next(t10, n8 = new _w()) {
    return null != t10 && (this.execute = (e13) => {
      const r8 = t10(e13);
      null != r8 && n8.execute(r8);
    }), n8;
  }
};
function D4(t10, n8, e13 = []) {
  if ("2d" === t10.type) return (t11) => t11;
  let r8 = null;
  return (a12) => {
    "start" === a12.action && (r8 = t10.toMap(a12.screenStart, { exclude: e13 }), null != r8 && (r8.z = p(r8, t10, n8)));
    const o8 = t10.toMap(a12.screenEnd, { exclude: e13 });
    null != o8 && (o8.z = p(o8, t10, n8));
    const l9 = null != r8 && null != o8 ? { sceneStart: r8, sceneEnd: o8 } : null;
    return { ...a12, scenePoints: l9 };
  };
}
function U4(t10, n8, e13) {
  const r8 = n8.elevationProvider.getElevation(t10.x, t10.y, t10.z ?? 0, t10.spatialReference, "scene") ?? 0, a12 = x(t10);
  return a12.z = r8, a12.hasZ = true, a12.z = p(a12, n8, e13), a12;
}
function G3(t10, n8) {
  if ("2d" === t10.type) return (t11) => t11;
  let e13 = null;
  return (r8) => {
    "start" === r8.action && (e13 = U4(r8.mapStart, t10, n8));
    const a12 = U4(r8.mapEnd, t10, n8), o8 = null != e13 && null != a12 ? { sceneStart: e13, sceneEnd: a12 } : null;
    return { ...r8, scenePoints: o8 };
  };
}

// node_modules/@arcgis/core/views/interactive/snapping/SnappingDragPipelineStep.js
function f8({ predicate: o8 = () => true, snappingManager: i9, snappingContext: l9, updatingHandles: u9, useZ: c14 = true }) {
  const p7 = new w7();
  if (null == i9) return { snappingStep: [y5, p7], cancelSnapping: y5 };
  let f9, Z5 = null, j13 = null, z8 = null;
  const T6 = () => {
    Z5 = e2(Z5), i9.doneSnapping(), j13?.frameTask.remove(), j13 = null, f9 = l(f9), z8 = null;
  }, k7 = d8(i9, c14, p7);
  let w8 = null, I5 = null, U6 = null;
  return { snappingStep: [(n8) => {
    if (!o8(n8)) return n8;
    const { action: e13 } = n8;
    if ("start" === e13) {
      const { info: e14 } = n8, t10 = m6(i9.view);
      if (j13 = g6(l9, n8, t10), j13.context.selfSnappingZ = null, !c14 && null != e14) {
        const n9 = S4(l9.coordinateHelper, e14.handle.component);
        null != n9 && (j13.context.selfSnappingZ = { value: n9, elevationInfo: l9.elevationInfo ?? j5 });
      }
    }
    if (null != j13) {
      const { context: o9, originalScenePos: l10, originalPos: a12 } = j13, { mapEnd: s3, mapStart: p8, scenePoints: d10 } = n8, m7 = x4(a12, v4(s3, p8)), g7 = v4(p8, a12), S6 = { ...n8, action: "update" }, y6 = j13.context, T7 = P7(l10, d10), C3 = i9.update({ point: m7, scenePoint: T7, context: o9 });
      if (U6 = C3, h6(s3, C3, g7, c14), w8 = m7, I5 = T7, "end" !== e13) {
        const { frameTask: n9 } = j13;
        null == Z5 && (Z5 = new AbortController()), z8 = (e14) => {
          u9.addPromise(d(k7({ frameTask: n9, event: S6, context: y6, point: m7, scenePoint: T7, delta: g7, getLastState: () => ({ point: w8, scenePoint: I5, updatePoint: e14.forceUpdate ? null : U6 }) }, Z5.signal)));
        }, z8({ forceUpdate: false }), null == f9 && (f9 = l2((() => i9.options.effectiveEnabled), (() => z8?.({ forceUpdate: true }))));
      }
    }
    return "end" === e13 && T6(), n8;
  }, p7], cancelSnapping: (n8) => (T6(), n8) };
}
function d8(n8, e13, t10) {
  return k((async ({ frameTask: o8, point: r8, scenePoint: l9, context: a12, event: s3, delta: u9, getLastState: c14 }, p7) => {
    const f9 = await o8.schedule((() => n8.snap({ point: r8, scenePoint: l9, context: a12, signal: p7 })), p7);
    if (f9.valid) {
      let l10 = await o8.schedule((() => f9.apply()), p7);
      const d10 = c14();
      null != d10.point && r8 !== d10.point && (l10 = n8.update({ point: d10.point, scenePoint: d10.scenePoint, context: a12 })), null != d10.updatePoint && a5(l10, d10.updatePoint) || (h6(s3.mapEnd, l10, u9, e13), t10.execute(s3));
    }
  }));
}
function m6(n8) {
  return "3d" === n8.type ? n8.resourceController.scheduler.registerTask(g.SNAPPING) : D;
}
function g6(n8, e13, t10) {
  return { context: new e8({ editGeometryOperations: n8.editGeometryOperations, elevationInfo: n8.elevationInfo, pointer: n8.pointer, vertexHandle: null != e13.info ? e13.info.handle : null, excludeFeature: n8.excludeFeature, feature: n8.feature, visualizer: n8.visualizer }), originalPos: null != e13.snapOrigin ? n8.coordinateHelper.vectorToDehydratedPoint(e13.snapOrigin) : e13.mapStart, originalScenePos: null != e13.scenePoints ? e13.scenePoints.sceneStart : null, frameTask: t10 };
}
function x4(n8, [e13, t10, o8]) {
  const r8 = x(n8);
  return r8.x += e13, r8.y += t10, r8.hasZ && (r8.z += o8), r8;
}
function P7(n8, e13) {
  return null == n8 || null == e13 ? null : x4(n8, v4(e13.sceneEnd, e13.sceneStart));
}
function v4(n8, e13) {
  const t10 = n8.hasZ && e13.hasZ ? n8.z - e13.z : 0;
  return [n8.x - e13.x, n8.y - e13.y, t10];
}
function h6(n8, e13, [t10, o8, r8], i9) {
  n8.x = e13.x + t10, n8.y = e13.y + o8, i9 && n8.hasZ && e13.hasZ && (n8.z = e13.z + r8);
}
function S4(n8, e13) {
  if (!n8.hasZ()) return null;
  const t10 = e13.vertices;
  let o8 = null;
  for (const r8 of t10) {
    const e14 = n8.getZ(r8.pos);
    if (null != o8 && null != e14 && Math.abs(e14 - o8) > 1e-6) return null;
    null == o8 && (o8 = e14);
  }
  return o8;
}
function y5(n8) {
  return n8;
}

// node_modules/@arcgis/core/views/draw/DrawingMode.js
var e12 = "click";

// node_modules/@arcgis/core/views/draw/DrawManipulator.js
var t9 = class {
  constructor({ consumesClicks: t10, grabbableForEvent: s3 }) {
    this.events = new o2(), this.interactive = true, this.selectable = false, this.cursor = null, this.grabbable = true, this.consumesClicks = t10, this.grabbableForEvent = s3;
  }
  destroy() {
  }
  intersectionDistance(e13, t10) {
    return 0;
  }
  attach() {
  }
  detach() {
  }
  onElevationChange() {
  }
  onViewChange() {
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/SnappingOperation.js
var p6 = class extends b {
  constructor(t10) {
    super(t10), this.constrainResult = (t11) => t11, this._snapPoints = null, this._frameTask = null, this._abortController = null, this._stagedPoint = null, this._snap = k((async (t11, s3, o8, n8) => {
      const i9 = this._frameTask;
      if (null == i9) return;
      const r8 = await i9.schedule((() => s3.snap({ ...t11, context: o8, signal: n8 })), n8);
      r8.valid && await i9.schedule((() => {
        this.stagedPoint = r8.apply(), t11 !== this._snapPoints && null != this._snapPoints && (this.stagedPoint = s3.update({ ...this._snapPoints, context: o8 }));
      }), n8);
    }));
  }
  get stagedPoint() {
    return this._stagedPoint;
  }
  set stagedPoint(t10) {
    this._stagedPoint = this.constrainResult(t10);
  }
  initialize() {
    const t10 = "3d" === this.view.type ? this.view?.resourceController?.scheduler : null;
    this._frameTask = null != t10 ? t10.registerTask(g.SNAPPING) : D;
  }
  destroy() {
    this._abortController = e2(this._abortController), this._frameTask = l(this._frameTask);
  }
  update(t10, s3, o8) {
    this._snapPoints = t10;
    const { point: n8, scenePoint: i9 } = t10, r8 = s3.update({ point: n8, scenePoint: i9, context: o8 });
    return this.stagedPoint = r8, r8;
  }
  async snap(t10, s3, o8) {
    const { point: n8, scenePoint: i9 } = t10;
    return this.stagedPoint = s3.update({ point: n8, scenePoint: i9, context: o8 }), this._snapPoints = t10, null == this._abortController && (this._abortController = new AbortController()), this._snap(t10, s3, o8, this._abortController.signal);
  }
  async snapAgainNearPreviousMapPoint(t10, s3) {
    null != this._snapPoints && await this.snap(this._snapPoints, t10, s3);
  }
  abort() {
    this._abortController = e2(this._abortController), this._snapPoints = null;
  }
};
r([m({ constructOnly: true })], p6.prototype, "view", void 0), r([m()], p6.prototype, "stagedPoint", null), r([m()], p6.prototype, "constrainResult", void 0), r([m()], p6.prototype, "_stagedPoint", void 0), p6 = r([a2("esri.views.interactive.snapping.SnappingOperation")], p6);

// node_modules/@arcgis/core/views/draw/DrawOperation.js
var L6 = "crosshair";
var U5 = "progress";
var A4 = Symbol();
var z7 = Symbol();
var F6 = class extends o2.EventedMixin(b) {
  constructor(t10) {
    super(t10), this._createOperationCompleted = false, this._hideDefaultCursor = false, this._pointerDownStates = new t3(), this._stagedScreenPoint = null, this._stagedPointerType = null, this._updatingHandles = new h2(), this._stagedPointerId = null, this.constraintsEnabled = false, this.constraints = void 0, this._getPointConstraint = t4(V4), this._getPolylineOrPolygonConstraint = t4(k6), this.constraintZ = null, this.defaultZ = null, this.isDraped = true, this.labelOptions = new c8(), this.cursor = null, this.loading = false, this.snapToSceneEnabled = null, this.firstVertex = null, this.lastVertex = null, this.secondToLastVertex = null, null == t10.elevationInfo && (this.elevationInfo = u6(!!t10.hasZ));
  }
  initialize() {
    const { geometryType: t10, view: e13 } = this, i9 = e13.spatialReference, n8 = "viewingMode" in e13.state ? e13.state.viewingMode : l4.Local, r8 = "segment" === t10 || "multipoint" === t10 ? "polyline" : t10;
    this.coordinateHelper = P3(this.hasZ, this.hasM, i9), this._editGeometryOperations = new E4(new p2(r8, this.coordinateHelper), n8), this._snappingOperation = new p6({ view: e13 }), this.addHandles([l2((() => ({ stagedPoint: this._snappingOperation.stagedPoint, constraint: this._constraint })), (({ stagedPoint: t11, constraint: e14 }, i10) => {
      const { snappingOptions: n9 } = this;
      n9 && (n9.forceDisabled = null != e14 && Le(e14));
      if (null != i10 && t11 === i10.stagedPoint && e14 !== i10.constraint) return this._onKeyboardBasedChange();
      this._processCursor(t11 ?? this._screenToMap(this._stagedScreenPoint));
    }), { equals: (t11, e14) => t11.stagedPoint === e14.stagedPoint && o(t11.constraint, e14.constraint) }), l2((() => this.view.viewpoint), ((t11, e14) => {
      t11 && e14 && y2(t11, e14) && this._onKeyboardBasedChange();
    }))]), this._activeComponent = new a8(i9, n8), this._editGeometryOperations.data.components.push(this._activeComponent);
    const s3 = this.segmentLabels;
    null != s3 && (s3.context = { view: e13, editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, labelOptions: this.labelOptions, automaticLengthMeasurementUtils: this.automaticLengthMeasurementUtils }, this.addHandles(l2((() => this.labelOptions.enabled), ((t11) => {
      s3.visible = t11;
    }), w2))), this.addHandles(this._editGeometryOperations.on(["vertex-add", "vertex-update", "vertex-remove"], ((t11) => {
      const e14 = t11.vertices.map(((t12) => ({ componentIndex: 0, vertexIndex: t12.index, coordinates: this.coordinateHelper.vectorToArray(t12.pos) }))), i10 = e14.map(((t12) => t12.coordinates)), n9 = this.coordinateHelper.vectorToDehydratedPoint(this._activeComponent.getFirstVertex()?.pos) ?? null;
      a5(n9, this.firstVertex) || (this.firstVertex = n9);
      const o8 = this.coordinateHelper.vectorToDehydratedPoint(this._activeComponent.getLastVertex()?.pos) ?? null;
      a5(o8, this.lastVertex) || (this.lastVertex = o8);
      const r9 = this.coordinateHelper.vectorToDehydratedPoint(this._activeComponent.edges.at(-1)?.leftVertex?.pos) ?? null;
      switch (a5(r9, this.secondToLastVertex) || (this.secondToLastVertex = r9), this._processCursor(this.cursorVertex), t11.type) {
        case "vertex-add":
          this.emit(t11.type, { ...t11, added: i10, vertices: e14 });
          break;
        case "vertex-update":
          this.emit(t11.type, { ...t11, updated: i10, vertices: e14 });
          break;
        case "vertex-remove":
          this.emit(t11.type, { ...t11, removed: i10, vertices: e14 });
      }
    })));
    const p7 = this._manipulator = new t9({ consumesClicks: false, grabbableForEvent: (t11) => "click" !== this.drawingMode || "touch" === t11.pointerType && this._snappingEnabled && 1 === this._pointerDownStates.size });
    this.manipulators.add(p7), p7.grabbable = "point" !== t10 && "multipoint" !== t10, this.addHandles([p7.events.on("immediate-click", ((t11) => this._onImmediateClick(t11))), p7.events.on("immediate-double-click", ((t11) => this._onImmediateDoubleClick(t11))), l2((() => this.drawingMode), (() => {
      this.removeHandles(A4), this.addHandles(this._createManipulatorDragPipeline(p7), A4);
    }), w2), l2((() => ({ effectiveCursor: this.effectiveCursor })), (({ effectiveCursor: t11 }) => {
      p7.cursor = t11;
    }), w2)]), N3(this, (() => {
      const t11 = this.view.inputManager.latestPointerType ?? "mouse", e14 = this._getSnappingContext(t11);
      if (null != this.snappingManager) {
        const t12 = this._snappingOperation.snapAgainNearPreviousMapPoint(this.snappingManager, e14);
        this._updatingHandles.addPromise(d(t12));
      }
    }));
  }
  destroy() {
    u(this.segmentLabels), u(this._snappingOperation), this._editGeometryOperations = u(this._editGeometryOperations), this._updatingHandles.destroy();
  }
  get _isDragging() {
    const { _stagedPointerId: t10, _manipulator: e13 } = this;
    return null != t10 && this._pointerDownStates.has(t10) || e13.grabbing || !e13.interactive;
  }
  get _snappingEnabled() {
    return null != this.snappingManager && this.snappingManager.options.effectiveEnabled;
  }
  get _requiresScenePoint() {
    const t10 = this._updateAndGetEffectiveDrawSurface();
    return "3d" === this.view.type && this.drawSurface !== t10;
  }
  get canRedo() {
    return this._editGeometryOperations.canRedo;
  }
  get canUndo() {
    return this._editGeometryOperations.canUndo;
  }
  get committedVertices() {
    return this._activeComponent.vertices.map(((t10) => this.coordinateHelper.vectorToArray(t10.pos)));
  }
  get _constraint() {
    const { constraints: t10, constraintsEnabled: e13 } = this;
    if (t10 && e13) switch (this.geometryType) {
      case "point":
      case "multipoint":
        return this._getPointConstraint(t10);
      case "polygon":
      case "polyline":
        return this._getPolylineOrPolygonConstraint(this.lastVertex, this.secondToLastVertex, t10);
    }
  }
  set drawingMode(t10) {
    this._set("drawingMode", t10 ?? e12);
  }
  get effectiveCursor() {
    return this.loading ? U5 : this._hideDefaultCursor ? null : this.cursor || L6;
  }
  get interactive() {
    return this._manipulator.interactive;
  }
  set interactive(t10) {
    this._manipulator.interactive = t10;
  }
  get isCompleted() {
    return this._createOperationCompleted;
  }
  get numCommittedVertices() {
    return this._activeComponent.vertices.length;
  }
  get snappingOptions() {
    return null != this.snappingManager ? this.snappingManager.options : null;
  }
  get cursorVertex() {
    return this._get("cursorVertex");
  }
  get visualizationCursorVertex() {
    return "mouse" === this._stagedPointerType ? this.cursorVertex : null;
  }
  get committableVertex() {
    const { cursorVertex: t10, lastVertex: e13, firstVertex: i9, geometryType: n8 } = this;
    return "polygon" === n8 && i2(t10, i9) || i2(t10, e13) ? null : t10;
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get geometryIncludingUncommittedVertices() {
    const { committedVertices: t10, committableVertex: e13, coordinateHelper: i9 } = this, n8 = t10.slice();
    return null != e13 && n8.push(i9.pointToArray(e13)), n8;
  }
  cancel() {
    this.complete({ aborted: true });
  }
  commitStagedVertex() {
    this._snappingOperation.abort();
    const { committableVertex: t10 } = this;
    null != t10 && this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(t10));
  }
  complete(t10) {
    const e13 = t10?.aborted || false;
    this._snappingOperation.abort(), this.snappingManager?.doneSnapping();
    const { geometryType: i9, numCommittedVertices: n8 } = this, o8 = "multipoint" === i9 && 0 === n8 || "polyline" === i9 && n8 < 2 || "polygon" === i9 && n8 < 3;
    "segment" !== i9 && "point" !== i9 || this.commitStagedVertex(), this._createOperationCompleted = !o8, (this.isCompleted || e13) && (this._stagedScreenPoint = null, this._stagedPointerId = null, this._stagedPointerType = null, this._processCursor(null), this.emit("complete", { vertices: this.committedVertices.map(((t11, e14) => ({ componentIndex: 0, vertexIndex: e14, coordinates: t11 }))), aborted: e13, type: "complete" }));
  }
  onInputEvent(t10) {
    switch (t10.type) {
      case "pointer-down":
        this._pointerDownStates.add(t10.pointerId);
        break;
      case "pointer-up":
        this._pointerDownStates.delete(t10.pointerId);
    }
    switch (t10.type) {
      case "pointer-move":
        return this._onPointerMove(t10);
      case "hold":
        return this._onHold(t10);
    }
  }
  redo() {
    this._editGeometryOperations.redo();
  }
  undo() {
    null != this.snappingManager && this.snappingManager.doneSnapping(), this._editGeometryOperations.undo();
  }
  _processCursor(t10) {
    const e13 = a(this.cursorVertex), i9 = a(t10), o8 = i9 && (this._updateAndGetEffectiveDrawSurface()?.constrainZ(i9) ?? i9), r8 = this._snapToClosingVertex(o8), s3 = this._applyConstraints(r8);
    i2(e13, s3) || (this._set("cursorVertex", s3), this.segmentLabels?.set("stagedVertex", null != s3 ? this.coordinateHelper.pointToVector(s3) : null), null == s3 || "mouse" !== this._stagedPointerType ? this.emit("cursor-remove") : this.emit("cursor-update", { updated: null, vertices: [{ componentIndex: 0, vertexIndex: this._activeComponent.vertices.length, coordinates: this.coordinateHelper.pointToArray(s3) }], operation: "apply", type: "vertex-update" }));
  }
  _snapToClosingVertex(t10) {
    if (null == t10 || this._isDragging || "polygon" !== this.geometryType || this.numCommittedVertices <= 2) return t10;
    const e13 = this._mapToScreen(t10);
    if (!e13) return t10;
    const i9 = this._activeComponent;
    return this._vertexWithinPointerDistance(i9.vertices[0].pos, e13) ? this.firstVertex : this._vertexWithinPointerDistance(i9.vertices.at(-1).pos, e13) ? this.lastVertex : t10;
  }
  _createManipulatorDragPipeline(t10) {
    switch (this.drawingMode) {
      case "click":
        return this._createManipulatorDragPipelineClick(t10);
      case "freehand":
        return this._createManipulatorDragPipelineFreehand(t10);
      case "hybrid":
        return this._createManipulatorDragPipelineHybrid(t10);
    }
  }
  _createManipulatorDragPipelineClick(t10) {
    return p5(t10, ((t11, e13, i9, n8) => {
      const o8 = "touch" === n8 && this._snappingEnabled;
      if (this.isCompleted || !o8) return;
      const { snappingStep: r8, cancelSnapping: s3 } = f8({ predicate: () => o8, snappingManager: this.snappingManager, snappingContext: new e8({ editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, feature: this.graphic, pointer: n8, visualizer: this.snappingVisualizer, drawConstraints: this.constraints }), updatingHandles: this._updatingHandles, useZ: !this._requiresScenePoint });
      i9 = i9.next(((t12) => (o8 && null != this.snappingManager && this.snappingManager.doneSnapping(), t12))).next(s3), e13.next(this._screenToMapDragEventStep()).next(((t12) => ("start" === t12.action && (this._processCursor(t12.mapStart), ("segment" === this.geometryType || o8 && !this.numCommittedVertices) && this.commitStagedVertex()), t12))).next(D4(this.view, this.elevationInfo)).next(...r8).next(((t12) => (o8 && (this._processCursor(t12.mapEnd), "end" === t12.action && this.commitStagedVertex()), t12))).next(((t12) => ("end" === t12.action && ("mouse" !== this._stagedPointerType && this._snappingOperation.abort(), "segment" !== this.geometryType && "point" !== this.geometryType || this.complete()), t12)));
    }));
  }
  _createManipulatorDragPipelineFreehand(t10) {
    return p5(t10, ((t11, e13) => {
      this.isCompleted || e13.next(this._screenToMapDragEventStep()).next(((t12) => ("start" === t12.action && (this._snappingOperation.abort(), null == this.committableVertex && this._processCursor(t12.mapStart), "segment" === this.geometryType && this.commitStagedVertex()), t12))).next(((t12) => {
        switch (t12.action) {
          case "start":
          case "update":
            this._processCursor(t12.mapEnd), "polygon" !== this.geometryType && "polyline" !== this.geometryType || this.commitStagedVertex();
            break;
          case "end":
            this.complete();
        }
        return t12;
      }));
    }));
  }
  _createManipulatorDragPipelineHybrid(t10) {
    return p5(t10, ((t11, e13) => {
      this.isCompleted || e13.next(this._screenToMapDragEventStep()).next(((t12) => ("start" === t12.action && (this._snappingOperation.abort(), this.addHandles(this._editGeometryOperations.createUndoGroup(), z7), this._processCursor(t12.mapStart), this.commitStagedVertex()), t12))).next(((t12) => {
        switch (t12.action) {
          case "start":
          case "update":
            this._processCursor(t12.mapEnd), "polygon" !== this.geometryType && "polyline" !== this.geometryType || this.commitStagedVertex();
            break;
          case "end":
            "mouse" !== this._stagedPointerType && this._snappingOperation.abort(), this.removeHandles(z7), "segment" !== this.geometryType && "point" !== this.geometryType || this.complete();
        }
        return t12;
      }));
    }));
  }
  get _drawAtFixedElevation() {
    const { constraintsEnabled: t10, constraintZ: e13, geometryType: i9, numCommittedVertices: n8 } = this;
    return t10 ? null != e13 || "segment" === i9 && n8 > 0 : ("segment" === i9 || "polygon" === i9) && n8 > 0;
  }
  _updateAndGetEffectiveDrawSurface() {
    const { constraintsEnabled: t10, coordinateHelper: e13, drawSurface: i9, elevationDrawSurface: n8, snapToSceneEnabled: o8 } = this;
    if (null == n8) return i9;
    if (!this.hasZ) return n8.defaultZ = null, n8;
    const r8 = this.elevationInfo?.mode;
    let s3 = this.defaultZ, a12 = t10 || "absolute-height" === r8;
    if (null != o8 && (a12 = o8), "on-the-ground" === r8 && (a12 = false), this._drawAtFixedElevation) {
      s3 = (t10 ? this.constraintZ : null) ?? e13.getZ(this._activeComponent.vertices[0].pos), a12 = false;
    }
    return a12 ? i9 : (n8.defaultZ = s3, n8);
  }
  _mapToScreen(t10) {
    return this._updateAndGetEffectiveDrawSurface()?.mapToScreen(t10);
  }
  _onHold(t10) {
    this._snappingOperation.abort(), "click" === this.drawingMode && "touch" === t10.pointerType && this._snappingEnabled && this._processCursor(t10.mapPoint), t10.stopPropagation();
  }
  _onImmediateClick(t10) {
    if (!("mouse" === t10.pointerType && 2 === t10.button || this._manipulator.dragging)) try {
      const { drawingMode: e13, geometryType: i9 } = this;
      this._stagedPointerType = t10.pointerType, this._stagedScreenPoint = t10.screenPoint;
      const n8 = this._screenToMap(t10.screenPoint);
      if (null == n8) return;
      if (null == n8 || "freehand" === e13 && "point" !== i9 && "multipoint" !== i9) return;
      if (this._snappingEnabled && null != this.cursorVertex || this._processCursor(n8), null == this.committableVertex) return void this.complete();
      this.commitStagedVertex(), "mouse" !== t10.pointerType && this._processCursor(null), ("freehand" === e13 && "multipoint" !== this.geometryType || "point" === i9 || "segment" === i9 && 2 === this.numCommittedVertices || "segment" === i9 && "hybrid" === e13 && 1 === this.numCommittedVertices) && this.complete();
    } finally {
      t10.stopPropagation();
    }
  }
  _onImmediateDoubleClick(t10) {
    this._manipulator.dragging || "point" === this.geometryType || (this.complete(), t10.stopPropagation());
  }
  _onPointerMove(t10) {
    const e13 = c(t10.x, t10.y);
    this._stagedScreenPoint = e13, this._stagedPointerType = t10.pointerType, this._stagedPointerId = t10.pointerId, this._isDragging ? this._snappingOperation.abort() : (t10.stopPropagation(), this._processCursorMovementRelativeToSurface(e13, t10.pointerType));
  }
  _onKeyboardBasedChange() {
    "mouse" === this._stagedPointerType && this._stagedScreenPoint && null != this._stagedPointerId && !this._isDragging ? this._processCursorMovementRelativeToSurface(this._stagedScreenPoint, this._stagedPointerType) : this._snappingOperation.abort();
  }
  _processCursorMovementRelativeToSurface(t10, e13) {
    const i9 = this._snappingOperation, n8 = this._screenToMap(t10), o8 = this._requiresScenePoint ? this.drawSurface?.screenToMap(t10) : null;
    if (null == n8) return this._hideDefaultCursor = true, this._processCursor(null), void i9.abort();
    this._hideDefaultCursor = false;
    const r8 = this.snappingManager;
    if (null == r8) return this._processCursor(n8), void i9.abort();
    const s3 = this._getSnappingContext(e13);
    this._updatingHandles.addPromise(d(i9.snap({ point: n8, scenePoint: o8 }, r8, s3)));
  }
  _applyConstraints(t10) {
    const { _constraint: e13, constraints: i9 } = this;
    if (!t10 || !i9 || !e13) return t10;
    const { context: n8 } = i9, o8 = G(t10, n8), r8 = o8 ? e13.closestTo(o8) : void 0;
    if (!r8) return t10;
    const s3 = W3(r8, t10, n8), a12 = "2d" === this.view.type || "absolute-height" !== n8.elevationInfo.mode;
    return null != s3 && a12 && null != this.constraintZ && this.hasZ && (s3.z = this.constraintZ), s3;
  }
  _screenToMap(t10) {
    return t10 ? this._updateAndGetEffectiveDrawSurface()?.screenToMap(t10) : null;
  }
  _screenToMapDragEventStep() {
    let t10 = null;
    return (e13) => {
      if ("start" === e13.action && (t10 = this._screenToMap(e13.screenStart)), null == t10) return null;
      const i9 = this._screenToMap(e13.screenEnd);
      return null != i9 ? { ...e13, mapStart: t10, mapEnd: i9 } : null;
    };
  }
  _vertexWithinPointerDistance(t10, e13) {
    const i9 = 25, n8 = this._mapToScreen(this.coordinateHelper.vectorToDehydratedPoint(t10));
    return null != n8 && R10(n8, e13, i9);
  }
  _getSnappingContext(t10) {
    const e13 = this._drawAtFixedElevation ? this.elevationDrawSurface?.defaultZ : null;
    return new e8({ editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, pointer: t10, feature: this.graphic, visualizer: this.snappingVisualizer, selfSnappingZ: null != e13 ? { value: e13, elevationInfo: this.elevationInfo } : null, drawConstraints: this.constraints });
  }
};
function R10(t10, e13, i9) {
  const n8 = t10.x - e13.x, o8 = t10.y - e13.y;
  return n8 * n8 + o8 * o8 <= i9;
}
r([m()], F6.prototype, "_hideDefaultCursor", void 0), r([m()], F6.prototype, "_stagedPointerId", void 0), r([m()], F6.prototype, "_isDragging", null), r([m()], F6.prototype, "_snappingOperation", void 0), r([m()], F6.prototype, "_snappingEnabled", null), r([m({ constructOnly: true })], F6.prototype, "graphic", void 0), r([m()], F6.prototype, "constraintsEnabled", void 0), r([m()], F6.prototype, "constraints", void 0), r([m()], F6.prototype, "_constraint", null), r([m()], F6.prototype, "constraintZ", void 0), r([m()], F6.prototype, "defaultZ", void 0), r([m()], F6.prototype, "isDraped", void 0), r([m({ constructOnly: true })], F6.prototype, "automaticLengthMeasurementUtils", void 0), r([m({ value: e12 })], F6.prototype, "drawingMode", null), r([m({ constructOnly: true })], F6.prototype, "elevationDrawSurface", void 0), r([m({ constructOnly: true })], F6.prototype, "elevationInfo", void 0), r([m({ constructOnly: true, type: c8 })], F6.prototype, "labelOptions", void 0), r([m({ constructOnly: true })], F6.prototype, "geometryType", void 0), r([m({ constructOnly: true })], F6.prototype, "hasM", void 0), r([m({ constructOnly: true })], F6.prototype, "hasZ", void 0), r([m()], F6.prototype, "cursor", void 0), r([m()], F6.prototype, "effectiveCursor", null), r([m()], F6.prototype, "loading", void 0), r([m({ constructOnly: true })], F6.prototype, "manipulators", void 0), r([m({ constructOnly: true })], F6.prototype, "drawSurface", void 0), r([m({ constructOnly: true })], F6.prototype, "segmentLabels", void 0), r([m({ constructOnly: true })], F6.prototype, "snappingManager", void 0), r([m({ constructOnly: true })], F6.prototype, "snappingVisualizer", void 0), r([m()], F6.prototype, "snapToSceneEnabled", void 0), r([m({ readOnly: true })], F6.prototype, "cursorVertex", null), r([m({ readOnly: true })], F6.prototype, "visualizationCursorVertex", null), r([m()], F6.prototype, "committableVertex", null), r([m()], F6.prototype, "firstVertex", void 0), r([m()], F6.prototype, "lastVertex", void 0), r([m()], F6.prototype, "secondToLastVertex", void 0), r([m()], F6.prototype, "updating", null), r([m({ constructOnly: true })], F6.prototype, "view", void 0), F6 = r([a2("esri.views.draw.DrawOperation")], F6);

// node_modules/@arcgis/core/views/draw/drawSurfaces.js
var c13 = class {
  constructor(e13, t10, s3, r8 = null) {
    this._elevationInfo = e13, this.defaultZ = t10, this._view = s3, this._excludeGraphics = r8;
  }
  screenToMap(t10) {
    const { defaultZ: s3, _view: r8 } = this, n8 = r8.sceneIntersectionHelper.intersectElevationFromScreen(f2(t10.x, t10.y), this._elevationInfo, s3 ?? 0, this._excludeGraphics);
    return null == s3 && null != n8 && (n8.z = void 0), n8;
  }
  mapToScreen(e13) {
    const t10 = e5(e13.x, e13.y, m3(this._view, e13, this._elevationInfo), e13.spatialReference);
    return this._view.toScreen(t10);
  }
  constrainZ(e13) {
    const { defaultZ: t10 } = this;
    return null != t10 && e13.z !== t10 && ((e13 = x(e13)).z = t10), e13;
  }
};
var l8 = class {
  constructor(e13, t10, s3 = []) {
    this.view = e13, this.elevationInfo = t10, this.exclude = s3;
  }
  screenToMap(e13) {
    const t10 = this.view.toMap(e13, { exclude: this.exclude, excludeLabels: true });
    return null != t10 && (t10.z = p(t10, this.view, this.elevationInfo)), t10;
  }
  mapToScreen(e13) {
    let t10 = e13;
    return null != this.elevationInfo && (t10 = e5(e13.x, e13.y, m3(this.view, e13, this.elevationInfo), e13.spatialReference)), this.view.toScreen(t10);
  }
  constrainZ(e13) {
    return e13;
  }
};
var h7 = class {
  constructor(e13, t10 = false, s3 = 0) {
    this.view = e13, this.hasZ = t10, this.defaultZ = s3, this.mapToScreen = (t11) => e13.toScreen(t11), this.screenToMap = t10 ? (t11) => {
      const r8 = e13.toMap(t11);
      return r8.z = s3, r8;
    } : (t11) => e13.toMap(t11);
  }
  constrainZ(e13) {
    const { defaultZ: t10 } = this;
    return this.hasZ && e13.z !== t10 && ((e13 = x(e13)).z = t10), e13;
  }
};
var _u = class _u {
  screenToMap(e13) {
    const { x: t10, y: r8 } = e13;
    return new _({ x: t10, y: r8, spatialReference: _u.spatialReference });
  }
  mapToScreen(e13) {
    return c(e13.x, e13.y);
  }
  constrainZ(e13) {
    return e13;
  }
};
_u.spatialReference = new f();
var u8 = _u;

// node_modules/@arcgis/core/views/interactive/editGeometry/support/editPlaneUtils.js
function d9(o8, i9) {
  return E9(o8, i9, false);
}
function T5(o8, i9) {
  return E9(o8, i9, true);
}
function E9(o8, i9, r8) {
  if (o8 instanceof t5) {
    if (o8.operation instanceof t6) return h8(o8.operation, i9, r8), true;
    if (o8.operation instanceof e7) return v5(o8.operation, i9, r8), true;
    if (o8.operation instanceof c9) return F7(o8.operation, i9, r8), true;
  }
  return false;
}
function h8(o8, i9, r8 = false) {
  const t10 = r8 ? -1 : 1, s3 = r4(t10 * o8.dx, t10 * o8.dy, t10 * o8.dz);
  u4(i9.origin, i9.origin, s3), K(i9);
}
function v5(o8, i9, r8 = false) {
  const t10 = r8 ? -o8.angle : o8.angle;
  w3(i9.basis1, i9.basis1, a3, t10), w3(i9.basis2, i9.basis2, a3, t10), K(i9);
}
function F7(o8, i9, r8 = false) {
  const t10 = r8 ? 1 / o8.factor1 : o8.factor1, s3 = r8 ? 1 / o8.factor2 : o8.factor2;
  g2(i9.basis1, i9.basis1, t10), g2(i9.basis2, i9.basis2, s3), k2(i9.origin, i9.origin, o8.origin, o8.axis1, t10), k2(i9.origin, i9.origin, o8.origin, o8.axis2, s3), K(i9);
}
function S5(a12, m7, g7, p7, u9 = false) {
  p7 || (p7 = W());
  const l9 = o3(t.get(), a12[1], -a12[0]), j13 = o3(t.get(), Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), x5 = o3(t.get(), Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY), V6 = t.get(), d10 = m7.allVertices;
  d10.forEach((({ pos: s3 }) => {
    o3(V6, j4(a12, s3), j4(l9, s3)), f3(j13, j13, V6), M2(x5, x5, V6);
  }));
  const T6 = 1e-6, E10 = o3(t.get(), x5[0] - j13[0] < T6 ? g7 / 2 : 0, x5[1] - j13[1] < T6 ? g7 / 2 : 0);
  e3(j13, j13, E10), u3(x5, x5, E10);
  const h9 = u9 ? d10.reduce(((o8, i9) => o8 + (i9.pos[2] ?? 0)), 0) / d10.length : 0;
  return l3(p7.basis1, a12, (x5[0] - j13[0]) / 2), l3(p7.basis2, l9, (x5[1] - j13[1]) / 2), o4(p7.origin, j13[0] * a12[0] + j13[1] * l9[0], j13[0] * a12[1] + j13[1] * l9[1], h9), u4(p7.origin, p7.origin, p7.basis1), u4(p7.origin, p7.origin, p7.basis2), K(p7), p7;
}

export {
  n4 as n,
  E7 as E,
  F5 as F,
  p5 as p,
  m5 as m,
  f7 as f,
  E8 as E2,
  S3 as S,
  g5 as g,
  z6 as z,
  v3 as v,
  j12 as j,
  M5 as M,
  w7 as w,
  D4 as D,
  G3 as G,
  f8 as f2,
  F6 as F2,
  c13 as c,
  l8 as l,
  h7 as h,
  d9 as d,
  T5 as T,
  S5 as S2
};
//# sourceMappingURL=chunk-QKYGBHDG.js.map
