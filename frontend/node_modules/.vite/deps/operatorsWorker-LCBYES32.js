import {
  f
} from "./chunk-SCMB64VM.js";
import "./chunk-RMRI4NYS.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-BLBN3L5Q.js";
import "./chunk-CBXZL53X.js";
import "./chunk-SMO33YG7.js";
import "./chunk-LCBAL6ER.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import "./chunk-67AKDROO.js";
import "./chunk-CM3TIXEV.js";
import "./chunk-2AYGXVZI.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-ZJQPHR3K.js";
import "./chunk-NJZD7WM5.js";
import "./chunk-CL7VLXUR.js";
import "./chunk-FCX4ZA3Z.js";
import "./chunk-2ZPU5IZX.js";
import "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import "./chunk-JNYZ3I5R.js";
import "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import "./chunk-N626Y23H.js";
import "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/arcade/geometry/operatorsWorker.js
function t(e, t2) {
  let r2;
  return { loaded: false, load: () => r2 ??= t2().then(((t3) => {
    o[e] = { loaded: true, execute: t3 };
  })) };
}
function r(e) {
  return null == e ? null : e.toJSON();
}
var o = { disjoint: t("disjoint", (() => import("./disjointOperator-COWIHGWY.js").then(((e) => e.execute)))), intersects: t("intersects", (() => import("./intersectsOperator-2J2EGSQI.js").then(((e) => e.execute)))), touches: t("touches", (() => import("./touchesOperator-HRO273QX.js").then(((e) => e.execute)))), crosses: t("crosses", (() => import("./crossesOperator-B5RJS6MC.js").then(((e) => e.execute)))), within: t("within", (() => import("./withinOperator-DUAT4FNO.js").then(((e) => e.execute)))), contains: t("contains", (() => import("./containsOperator-SHPJ6ACP.js").then(((e) => e.execute)))), overlaps: t("overlaps", (() => import("./overlapsOperator-DLCIN7SC.js").then(((e) => e.execute)))), equals: t("equals", (async () => {
  const t2 = await import("./equalsOperator-IPYDDJDH.js");
  return (r2, o2) => t2.execute(f(r2), f(o2));
})), relate: t("relate", (async () => {
  const t2 = await import("./relateOperator-D733F6UM.js");
  return (r2, o2, n2) => t2.execute(f(r2), f(o2), n2);
})), intersection: t("intersection", (() => import("./intersectionOperator-E43BSVR5.js").then(((e) => e.execute)))), union: t("union", (() => import("./unionOperator-2LX2WNQD.js").then(((e) => e.executeMany)))), difference: t("difference", (async () => {
  const t2 = await import("./differenceOperator-2K6M2I26.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
})), symmetricDifference: t("symmetricDifference", (async () => {
  const t2 = await import("./symmetricDifferenceOperator-JNIGUD5U.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
})), clip: t("clip", (async () => {
  const t2 = await import("./clipOperator-RWRZABP6.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
})), cut: t("cut", (async () => {
  const t2 = await import("./cutOperator-FE2VMG3E.js");
  return (o2, n2) => t2.execute(f(o2), f(n2)).map(((e) => r(e)));
})), area: t("area", (async () => {
  const t2 = await import("./areaOperator-DADZJHVY.js"), { convertFromSpatialReferenceUnit: r2, toAreaUnit: o2 } = await import("./unitConversion-VU74IJUN.js");
  return (n2, a) => {
    const s = t2.execute(f(n2));
    return r2(n2.spatialReference, o2(a), s);
  };
})), geodeticArea: t("geodeticArea", (async () => {
  const t2 = await import("./geodeticAreaOperator-NECCJRAF.js"), { convert: r2, squareMeters: o2, toAreaUnit: n2 } = await import("./unitConversion-VU74IJUN.js");
  return await t2.load(), (a, s, i) => {
    const c = t2.execute(f(a), { curveType: i });
    return r2(o2, n2(s), c);
  };
})), length: t("length", (async () => {
  const e = await import("./lengthOperator-OIAQ3VTH.js"), { convertFromSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-VU74IJUN.js");
  return (o2, n2) => {
    const a = e.execute(o2);
    return t2(o2.spatialReference, r2(n2), a);
  };
})), geodeticLength: t("geodeticLength", (async () => {
  const t2 = await import("./geodeticLengthOperator-7GQB7VON.js"), { convert: r2, meters: o2, toLengthUnit: n2 } = await import("./unitConversion-VU74IJUN.js");
  return await t2.load(), (a, s, i) => {
    const c = t2.execute(f(a), { curveType: i });
    return r2(o2, n2(s), c);
  };
})), distance: t("distance", (async () => {
  const t2 = await import("./distanceOperator-5TIFHGJV.js"), { convertFromSpatialReferenceUnit: r2, toLengthUnit: o2 } = await import("./unitConversion-VU74IJUN.js");
  return (n2, a, s) => {
    const i = t2.execute(f(n2), f(a));
    return r2(n2.spatialReference, o2(s), i);
  };
})), densify: t("densify", (async () => {
  const t2 = await import("./densifyOperator-ABEDVICC.js"), { convertToSpatialReferenceUnit: o2, toLengthUnit: n2 } = await import("./unitConversion-VU74IJUN.js");
  return (a, s, i) => (s = o2(n2(i), a.spatialReference, s), r(t2.execute(f(a), s)));
})), geodeticDensify: t("geodeticDensify", (async () => {
  const t2 = await import("./geodeticDensifyOperator-IDSHZVS7.js"), { convert: o2, meters: n2, toLengthUnit: a } = await import("./unitConversion-VU74IJUN.js");
  return await t2.load(), (s, i, c, p) => (i = o2(a(c), n2, i), r(t2.execute(f(s), i, { curveType: p })));
})), generalize: t("generalize", (async () => {
  const t2 = await import("./generalizeOperator-ZAHSD6JA.js"), { convertToSpatialReferenceUnit: o2, toLengthUnit: n2 } = await import("./unitConversion-VU74IJUN.js");
  return (a, s, i, c) => (s = o2(n2(i), a.spatialReference, s), r(t2.execute(f(a), s, c)));
})), buffer: t("buffer", (async () => {
  const e = await import("./bufferOperator-7WL2LFFF.js"), { convertToSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-VU74IJUN.js");
  return (o2, n2, a) => (n2 = t2(r2(a), o2.spatialReference, n2), e.execute(o2, n2));
})), geodesicBuffer: t("geodesicBuffer", (async () => {
  const e = await import("./geodesicBufferOperator-XG34DUIK.js"), { convert: t2, meters: r2, toLengthUnit: o2 } = await import("./unitConversion-VU74IJUN.js");
  return await e.load(), (n2, a, s, i) => (a = t2(o2(s), r2, a), e.execute(n2, a, { curveType: i }));
})), offset: t("offset", (async () => {
  const e = await import("./offsetOperator-E3I6RFG7.js"), { convertToSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-VU74IJUN.js");
  return (o2, n2, a, s) => (n2 = t2(r2(a), o2.spatialReference, n2), e.execute(o2, n2, s));
})), rotate: t("rotate", (async () => {
  const t2 = await import("./affineTransformOperator-UZ4CYYWN.js"), { default: o2 } = await import("./Transformation-QWH5PL52.js");
  return (n2, a, s, i) => {
    const c = new o2().rotate(a, s, i);
    return r(t2.execute(f(n2), c));
  };
})), centroid: t("centroid", (async () => {
  const t2 = await import("./centroidOperator-WD6ILNLM.js");
  return (o2) => r(t2.execute(f(o2)));
})), labelPoint: t("labelPoint", (async () => {
  const t2 = await import("./labelPointOperator-L3NZ3MDN.js");
  return (o2) => r(t2.execute(f(o2)));
})), simplify: t("simplify", (() => import("./simplifyOperator-XVXDYLTM.js").then(((e) => e.execute)))), isSelfIntersecting: t("isSelfIntersecting", (async () => {
  const { NonSimpleResult: t2 } = await import("./OperatorDefinitions-Y7VM2FIO.js"), r2 = await import("./simplifyOGCOperator-HNVTDIVP.js"), o2 = /* @__PURE__ */ new Set([5, 6, 7, 10, 11, 12]);
  return (n2) => {
    const a = new t2();
    return !r2.isSimple(f(n2), a) && o2.has(a.m_reason);
  };
})), isSimple: t("isSimple", (() => import("./simplifyOperator-XVXDYLTM.js").then(((e) => e.isSimple)))), convexHull: t("convexHull", (() => import("./convexHullOperator-EMCG2AWQ.js").then(((e) => e.execute)))), getNearestCoordinate: t("getNearestCoordinate", (async () => {
  const t2 = await import("./proximityOperator-SDQA5IDF.js");
  return (o2, n2, a) => {
    const s = t2.getNearestCoordinate(f(o2), f(n2), a);
    return { ...s, coordinate: r(s.coordinate) };
  };
})), getNearestVertex: t("getNearestVertex", (async () => {
  const t2 = await import("./proximityOperator-SDQA5IDF.js");
  return (o2, n2) => {
    const a = t2.getNearestVertex(f(o2), f(n2));
    return { ...a, coordinate: r(a.coordinate) };
  };
})) };
function n(e, t2) {
  const r2 = o[e];
  return r2.loaded ? r2.execute.apply(void 0, t2) : r2.load().then((() => n(e, t2)));
}
export {
  n as invokeGeometryOp
};
//# sourceMappingURL=operatorsWorker-LCBYES32.js.map
