import {
  c,
  i
} from "./chunk-LHRFXQHT.js";
import {
  G,
  _,
  r
} from "./chunk-ZB6KRLRI.js";
import "./chunk-CM3TIXEV.js";
import "./chunk-POWGZO3T.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-2ZPU5IZX.js";
import "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import "./chunk-JNYZ3I5R.js";
import "./chunk-N626Y23H.js";
import "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/geometry/operators/support/geographicTransformationUtils.js
var s;
var i2;
var a;
var c2;
function p() {
  return !!s && r();
}
async function m() {
  if (!p()) {
    const [t, e, r2, p2] = await Promise.all([import("./Envelope2D-SZNQNMVA.js"), import("./ProjectionTransformation-RMC77OPG.js").then(((n) => n.aK)).then((({ queryTransformationList: n }) => n)), import("./ProjectionTransformation-RMC77OPG.js").then(((n) => n.aG)).then((({ injectPe: n }) => n)), import("./apiConverter-BITBHAJU.js"), _()]);
    c2 = t.Envelope2D.constructEmpty(), s = e, r2(G), i2 = p2.fromExtent, a = p2.fromSpatialReference;
  }
}
function u(n, t, o = null) {
  const e = o ? i2(o).asEnvelope2D() : c2, r2 = s(0, a(n), a(t), e, 1, true);
  return r2.length > 0 ? l(r2[0]) : null;
}
function f(n, t, o = null) {
  const e = o ? i2(o).asEnvelope2D() : c2;
  return s(0, a(n), a(t), e, 0, true).map(((n2) => l(n2)));
}
function l(n) {
  const t = new c();
  for (let o = 0; o < n.count(); o++) {
    const e = n.getStep(o);
    t.steps.push(new i({ wkid: e.getID(), isInverse: e.isInverted() }));
  }
  return t;
}
export {
  u as getTransformation,
  f as getTransformations,
  p as isLoaded,
  m as load
};
//# sourceMappingURL=geographicTransformationUtils-T6RC2PJL.js.map
