import {
  s as s3
} from "./chunk-6MIR5DFD.js";
import {
  l as l3
} from "./chunk-RGZR25IP.js";
import {
  t as t2
} from "./chunk-LFDAB5ON.js";
import {
  B,
  E,
  F,
  L as L2,
  N,
  R as R2,
  R2 as R3,
  a as a3,
  a2 as a4,
  b,
  c as c2,
  e as e3,
  j as j2,
  k,
  p,
  q as q2
} from "./chunk-O6WTPME7.js";
import "./chunk-ZR62VL5J.js";
import {
  O,
  u as u2
} from "./chunk-EEMZXBIQ.js";
import {
  D
} from "./chunk-W7MPPZTB.js";
import "./chunk-26HWVNMY.js";
import {
  j
} from "./chunk-X6MR5RJV.js";
import {
  l as l2
} from "./chunk-4AWS66T2.js";
import {
  $,
  G,
  K,
  Ke,
  L,
  Ne,
  Se,
  Te,
  X,
  _e,
  ae,
  ie,
  ne,
  pe,
  q,
  re,
  te
} from "./chunk-ONCJ5DYL.js";
import {
  s,
  x
} from "./chunk-4I7FX2CT.js";
import {
  t
} from "./chunk-MX6BY66A.js";
import {
  Xe
} from "./chunk-57NU6P6U.js";
import "./chunk-DPZUWQQD.js";
import "./chunk-VJFNPV3I.js";
import "./chunk-PUDEDAPY.js";
import "./chunk-JXBJIDCW.js";
import "./chunk-BZSAIP56.js";
import "./chunk-RWIBDRMM.js";
import "./chunk-AXEQLPYK.js";
import "./chunk-MWIJEAM3.js";
import "./chunk-BGSPX4Z3.js";
import "./chunk-WBA6DQSU.js";
import "./chunk-BB6EK2RQ.js";
import "./chunk-R3HU2OBM.js";
import "./chunk-5ZJG2W6X.js";
import "./chunk-7JSCPQTK.js";
import "./chunk-EYECC3PG.js";
import "./chunk-LUPQ25XG.js";
import "./chunk-3GQTEESV.js";
import "./chunk-UBVWE2LK.js";
import "./chunk-32DGBWKL.js";
import "./chunk-DJRZXLB2.js";
import "./chunk-3ESJRJZD.js";
import "./chunk-L6GG77AZ.js";
import "./chunk-XOKYRVJ5.js";
import "./chunk-D2DRG2DH.js";
import "./chunk-HOVLU5XA.js";
import "./chunk-2DCDAX3U.js";
import "./chunk-EZ5REY53.js";
import "./chunk-3HYSKSYM.js";
import "./chunk-EWP4DLQF.js";
import "./chunk-CHGKJUJ3.js";
import "./chunk-3YBQQHIP.js";
import "./chunk-OJQCHQYS.js";
import "./chunk-N3W3EVP3.js";
import "./chunk-ZJXLBTN2.js";
import "./chunk-SIRTOV2N.js";
import "./chunk-V7CFMRVF.js";
import "./chunk-LINWZZJL.js";
import "./chunk-YKZMZKSQ.js";
import "./chunk-QZISYUPA.js";
import "./chunk-HQRWZZNA.js";
import "./chunk-CKFS2QIU.js";
import "./chunk-PI2R2EZ2.js";
import "./chunk-JLGVQWP5.js";
import "./chunk-LCT65JMM.js";
import "./chunk-IR6JOM7Y.js";
import "./chunk-MK7DDFJN.js";
import "./chunk-H2PFGMJP.js";
import "./chunk-OFINLTIW.js";
import "./chunk-TIU3P5HE.js";
import "./chunk-EU5HNJUP.js";
import "./chunk-CJSURDZH.js";
import "./chunk-FFY3IMAS.js";
import "./chunk-YT2ORY5Z.js";
import "./chunk-2UINVE7X.js";
import "./chunk-CLMM4HHK.js";
import "./chunk-PTLGJ4Y6.js";
import "./chunk-KXZAYF3U.js";
import "./chunk-PHSQVJNW.js";
import "./chunk-KFNWBWN4.js";
import "./chunk-K55CXVYD.js";
import "./chunk-XOTDRYLO.js";
import "./chunk-G2F62CY5.js";
import "./chunk-Q37ABIVM.js";
import "./chunk-VFMQPCCZ.js";
import "./chunk-63ZT5BWV.js";
import "./chunk-OPQ3FCJ4.js";
import "./chunk-SMDDQAST.js";
import "./chunk-W3BJJE6D.js";
import "./chunk-UZ3YWBWC.js";
import "./chunk-K5CV62SX.js";
import "./chunk-2EOHKZLO.js";
import "./chunk-S7GLMIAQ.js";
import "./chunk-YIVJSMJO.js";
import "./chunk-QMUTCCDX.js";
import "./chunk-24S6C5S6.js";
import "./chunk-7Y4U2JD3.js";
import "./chunk-GCTSCKPO.js";
import "./chunk-6U4EGJOK.js";
import "./chunk-W7U4L72B.js";
import "./chunk-UICDKBDP.js";
import "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-LQQCPLIT.js";
import "./chunk-4O46EK5T.js";
import {
  R
} from "./chunk-4R7TSTKL.js";
import {
  h
} from "./chunk-UO2UKPG5.js";
import "./chunk-EMULKSUV.js";
import {
  a as a2,
  e,
  o as o3,
  r as r3
} from "./chunk-AY3JR4QM.js";
import "./chunk-DKFJHHQ4.js";
import "./chunk-UXVQ5YGS.js";
import "./chunk-Z34SUCTX.js";
import "./chunk-A2AZM62Y.js";
import "./chunk-LQYJLB4P.js";
import "./chunk-D6GGPM6D.js";
import "./chunk-FQY65CBA.js";
import {
  m as m3
} from "./chunk-HH4Q2NN5.js";
import "./chunk-3CFYBBSV.js";
import {
  f,
  s as s2,
  u
} from "./chunk-ZVNJ2S2Z.js";
import "./chunk-AACFCXAP.js";
import "./chunk-ZT7UIVVR.js";
import "./chunk-R25QZWQ7.js";
import "./chunk-BELQIHLO.js";
import "./chunk-BPI4BR4E.js";
import "./chunk-YVMULGDJ.js";
import "./chunk-CJDZN5K5.js";
import "./chunk-N77BULFI.js";
import "./chunk-6TZIEYTZ.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-A6R2FXH6.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-QLKHFYAN.js";
import "./chunk-3TSZDV6B.js";
import "./chunk-P4O4YCLI.js";
import "./chunk-FV6ZNHFI.js";
import "./chunk-MSSQA3XK.js";
import {
  d
} from "./chunk-PBKE5BCM.js";
import "./chunk-FOALQHMM.js";
import "./chunk-7HS3ESHX.js";
import "./chunk-2CS746FZ.js";
import "./chunk-NEI5HAVK.js";
import "./chunk-RCOFAQFP.js";
import "./chunk-CO2J5JPW.js";
import "./chunk-CHAHOTAY.js";
import "./chunk-RZGBA4KS.js";
import "./chunk-FSYN2HHU.js";
import "./chunk-7I4TWCTW.js";
import "./chunk-W5UOLFE2.js";
import "./chunk-AZ2S2PYZ.js";
import "./chunk-SCMB64VM.js";
import {
  e as e2,
  o as o4,
  r as r4
} from "./chunk-FOPBVVXE.js";
import "./chunk-INI6MHIQ.js";
import "./chunk-R7YP6EQJ.js";
import "./chunk-QUZZIDFR.js";
import "./chunk-CBCDVQSA.js";
import "./chunk-74GULGYB.js";
import "./chunk-RKF6WUZT.js";
import {
  y
} from "./chunk-RMRI4NYS.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-BLBN3L5Q.js";
import {
  C
} from "./chunk-5EWIWLNU.js";
import "./chunk-TOCH3L2K.js";
import "./chunk-CBXZL53X.js";
import "./chunk-HYAO4PVV.js";
import "./chunk-SRNKPAJX.js";
import "./chunk-MOMLPET6.js";
import "./chunk-VNQUG2TO.js";
import "./chunk-EULNFFHG.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-LPCUYJ2B.js";
import "./chunk-3QHX4R4B.js";
import "./chunk-SMO33YG7.js";
import "./chunk-LCBAL6ER.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import "./chunk-67AKDROO.js";
import "./chunk-CM3TIXEV.js";
import {
  H
} from "./chunk-2AYGXVZI.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-WO5FLTVY.js";
import "./chunk-MGA7XBRB.js";
import "./chunk-XNUSHDFN.js";
import "./chunk-4AKMPOG7.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-APMQAZ5Z.js";
import "./chunk-ZJQPHR3K.js";
import {
  o as o2
} from "./chunk-NJZD7WM5.js";
import {
  r as r2
} from "./chunk-CL7VLXUR.js";
import {
  l
} from "./chunk-FCX4ZA3Z.js";
import {
  c,
  m2
} from "./chunk-2ZPU5IZX.js";
import {
  a2 as a
} from "./chunk-S62CSPIH.js";
import {
  m
} from "./chunk-X26VPODZ.js";
import {
  o
} from "./chunk-XNYPRDKK.js";
import "./chunk-JNYZ3I5R.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import {
  S
} from "./chunk-N626Y23H.js";
import {
  i3 as i
} from "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/networks/support/typeUtils.js
var t3;
!(function(n2) {
  n2[n2.RTJunctionJunctionConnectivity = 1] = "RTJunctionJunctionConnectivity", n2[n2.RTContainment = 2] = "RTContainment", n2[n2.RTAttachment = 3] = "RTAttachment", n2[n2.RTJunctionEdgeConnectivity = 4] = "RTJunctionEdgeConnectivity", n2[n2.RTEdgeJunctionEdgeConnectivity = 5] = "RTEdgeJunctionEdgeConnectivity";
})(t3 || (t3 = {}));
var o5 = new o({ connected: "connected", upstream: "upstream", downstream: "downstream", shortestPath: "shortest-path", subnetwork: "subnetwork", subnetworkController: "subnetwork-controller", loops: "loops", isolation: "isolation", path: "path", circuit: "circuit" });
var i2 = new o({ junctionJunctionConnectivity: "junction-junction-connectivity", connectivity: "connectivity", attachment: "attachment", containment: "containment", junctionEdgeFromConnectivity: "junction-edge-from-connectivity", junctionEdgeMidspanConnectivity: "junction-edge-midspan-connectivity", junctionEdgeToConnectivity: "junction-edge-to-connectivity" });
var c3 = new o({ normal: "normal", rebuild: "rebuild", forceRebuild: "force-rebuild" });

// node_modules/@arcgis/core/rest/networks/support/TelecomNetworkElement.js
var s4 = class extends s3 {
  constructor(o6) {
    super(o6), this.type = "telecomNetworkElement", this.firstUnit = null, this.numUnits = null;
  }
};
r([m2({ json: { write: false } })], s4.prototype, "type", void 0), r([m2({ json: { write: true } })], s4.prototype, "firstUnit", void 0), r([m2({ json: { write: true } })], s4.prototype, "numUnits", void 0), s4 = r([a("esri.rest.networks.support.TelecomNetworkElement")], s4);

// node_modules/@arcgis/core/rest/networks/support/Association.js
var d2 = class extends l {
  constructor(t4) {
    super(t4), this.globalId = null, this.associationType = null, this.fromNetworkElement = null, this.toNetworkElement = null, this.geometry = null, this.errorMessage = null, this.percentAlong = null, this.errorCode = null, this.isContentVisible = null, this.status = null;
  }
  readFromNetworkElement(t4, o6) {
    return o6.fromFirstUnit || o6.fromNumUnits ? new s4({ globalId: o6.fromGlobalId, networkSourceId: o6.fromNetworkSourceId, terminalId: o6.fromTerminalId, firstUnit: o6.fromFirstUnit, numUnits: o6.fromNumUnits }) : new s3({ globalId: o6.fromGlobalId, networkSourceId: o6.fromNetworkSourceId, terminalId: o6.fromTerminalId });
  }
  writeFromNetworkElement(t4, o6) {
    if (t4 && (o6.fromGlobalId = t4.globalId, o6.fromNetworkSourceId = t4.networkSourceId, o6.fromTerminalId = t4.terminalId, "telecomNetworkElement" === t4.type)) {
      const e4 = t4;
      o6.fromFirstUnit = e4.firstUnit, o6.fromNumUnits = e4.numUnits;
    }
  }
  readToNetworkElement(t4, o6) {
    return o6.toFirstUnit || o6.toNumUnits ? new s4({ globalId: o6.toGlobalId, networkSourceId: o6.toNetworkSourceId, terminalId: o6.toTerminalId, firstUnit: o6.toFirstUnit, numUnits: o6.toNumUnits }) : new s3({ globalId: o6.toGlobalId, networkSourceId: o6.toNetworkSourceId, terminalId: o6.toTerminalId });
  }
  writeToNetworkElement(t4, o6) {
    if (t4 && (o6.toGlobalId = t4.globalId, o6.toNetworkSourceId = t4.networkSourceId, o6.toTerminalId = t4.terminalId, "telecomNetworkElement" === t4.type)) {
      const e4 = t4;
      o6.toFirstUnit = e4.firstUnit, o6.toNumUnits = e4.numUnits;
    }
  }
};
r([m2({ type: String, json: { write: true } })], d2.prototype, "globalId", void 0), r([m2({ type: i2.apiValues, json: { type: i2.jsonValues, read: i2.read, write: i2.write } })], d2.prototype, "associationType", void 0), r([m2({ type: s3, json: { write: { target: { fromGlobalId: { type: String }, fromNetworkSourceId: { type: Number }, fromTerminalId: { type: Number }, fromFirstUnit: { type: Number }, fromNumUnits: { type: Number } } }, read: { source: ["fromGlobalId", "fromNetworkSourceId", "fromTerminalId", "fromFirstUnit", "fromNumUnits"] } } })], d2.prototype, "fromNetworkElement", void 0), r([o2("fromNetworkElement")], d2.prototype, "readFromNetworkElement", null), r([r2("fromNetworkElement")], d2.prototype, "writeFromNetworkElement", null), r([m2({ type: s3, json: { write: { target: { toGlobalId: { type: String }, toNetworkSourceId: { type: Number }, toTerminalId: { type: Number }, toFirstUnit: { type: Number }, toNumUnits: { type: Number } } }, read: { source: ["toGlobalId", "toNetworkSourceId", "toTerminalId", "toFirstUnit", "toNumUnits"] } } })], d2.prototype, "toNetworkElement", void 0), r([o2("toNetworkElement")], d2.prototype, "readToNetworkElement", null), r([r2("toNetworkElement")], d2.prototype, "writeToNetworkElement", null), r([m2({ type: y, json: { write: true } })], d2.prototype, "geometry", void 0), r([m2({ type: String, json: { write: true } })], d2.prototype, "errorMessage", void 0), r([m2({ type: Number, json: { write: true } })], d2.prototype, "percentAlong", void 0), r([m2({ type: Number, json: { write: true } })], d2.prototype, "errorCode", void 0), r([m2({ type: Boolean, json: { write: true } })], d2.prototype, "isContentVisible", void 0), r([m2({ type: Number, json: { write: true } })], d2.prototype, "status", void 0), d2 = r([a("esri.rest.networks.support.Association")], d2);

// node_modules/@arcgis/core/rest/networks/support/QueryAssociationsResult.js
var p2 = class extends l {
  constructor(o6) {
    super(o6), this.associations = [];
  }
};
r([m2({ type: [d2], json: { write: true } })], p2.prototype, "associations", void 0), p2 = r([a("esri.rest.networks.support.QueryAssociationsResult")], p2);

// node_modules/@arcgis/core/rest/networks/queryAssociations.js
function a5(e4) {
  const { returnDeletes: t4, elements: o6, gdbVersion: n2, moment: s5 } = e4.toJSON();
  return { returnDeletes: t4, elements: JSON.stringify(o6.map(((e5) => ({ globalId: e5.globalId, networkSourceId: e5.networkSourceId, terminalId: e5.terminalId })))), types: JSON.stringify(e4.types.map(((e5) => i2.toJSON(e5)))).replaceAll('"connectivity"', '"junctionJunctionConnectivity"'), gdbVersion: n2, moment: s5 ?? Date.now() };
}
async function p3(r5, p4, m5) {
  const u3 = f(r5), l4 = { ...a5(p4), f: "json" }, y2 = u({ ...u3.query, ...l4 }), d3 = s2(y2, { ...m5, method: "post" }), f2 = `${u3.path}/associations/query`, { data: g } = await H(f2, d3), j3 = p2.fromJSON(g);
  return p4.types.includes("connectivity") && c(i.getLogger("esri/rest/networks/support/QueryAssociationsParameters"), "types", { replacement: "Please use 'junction-junction-connectivity' instead of 'connectivity'.", see: "https://arcg.is/11Tr8a#types", version: "4.29", warnOnce: true }), j3;
}

// node_modules/@arcgis/core/rest/networks/support/QueryAssociationsParameters.js
var m4;
var n = m4 = class extends l {
  static from(e4) {
    return m(m4, e4);
  }
  constructor(e4) {
    super(e4), this.returnDeletes = false, this.elements = [], this.types = [], this.gdbVersion = null, this.moment = null;
  }
};
r([m2({ type: Boolean, json: { write: true } })], n.prototype, "returnDeletes", void 0), r([m2({ type: [s3], json: { write: true } })], n.prototype, "elements", void 0), r([m2({ type: [i2.apiValues], json: { type: i2.jsonValues, read: i2.read, write: i2.write } })], n.prototype, "types", void 0), r([m2({ type: String, json: { write: true } })], n.prototype, "gdbVersion", void 0), r([m2({ type: Date, json: { type: Number, write: { writer: (e4, t4) => {
  t4.moment = e4?.getTime();
} } } })], n.prototype, "moment", void 0), n = m4 = r([a("esri.rest.networks.support.QueryAssociationsParameters")], n);

// node_modules/@arcgis/core/arcade/functions/featuresetbase.js
function oe(e4) {
  if (1 === e4.length) {
    if (o4(e4[0])) return l2("distinct", e4[0], -1);
    if (te(e4[0])) return l2("distinct", e4[0].toArray(), -1);
  }
  return l2("distinct", e4, -1);
}
function se(e4, t4, n2) {
  const i3 = e4.getVariables();
  if (i3.length > 0) {
    const a6 = {};
    for (const e5 of i3) a6[e5] = t4.evaluateIdentifier(n2, { name: e5 });
    e4.parameters = a6;
  }
  return e4;
}
function le(e4, t4, n2 = null) {
  for (const i3 in e4) if (i3.toLowerCase() === t4.toLowerCase()) return e4[i3];
  return n2;
}
function fe(e4) {
  if (null === e4) return null;
  const t4 = { type: le(e4, "type", ""), name: le(e4, "name", "") };
  if ("range" === t4.type) t4.range = le(e4, "range", []);
  else {
    t4.codedValues = [];
    for (const n2 of le(e4, "codedValues", [])) t4.codedValues.push({ name: le(n2, "name", ""), code: le(n2, "code", null) });
  }
  return t4;
}
function de(e4) {
  if (null === e4) return null;
  const t4 = {}, n2 = le(e4, "wkt");
  null !== n2 && (t4.wkt = n2);
  const i3 = le(e4, "wkid");
  return null !== i3 && (t4.wkid = i3), t4;
}
function ue(e4) {
  if (null === e4) return null;
  const t4 = { hasZ: le(e4, "hasz", false), hasM: le(e4, "hasm", false) }, n2 = le(e4, "spatialreference");
  null != n2 && (t4.spatialReference = de(n2));
  const i3 = le(e4, "x", null);
  if (null !== i3) return t4.x = i3, t4.y = le(e4, "y", null), t4.hasZ && (t4.z = le(e4, "z", null)), t4.hasM && (t4.m = le(e4, "m", null)), t4;
  const a6 = le(e4, "rings", null);
  if (null !== a6) return t4.rings = a6, t4;
  const r5 = le(e4, "paths", null);
  if (null !== r5) return t4.paths = r5, t4;
  const o6 = le(e4, "points", null);
  if (null !== o6) return t4.points = o6, t4;
  for (const s5 of ["xmin", "xmax", "ymin", "ymax", "zmin", "zmax", "mmin", "mmax"]) {
    const n3 = le(e4, s5, null);
    null !== n3 && (t4[s5] = n3);
  }
  return t4;
}
function ce(e4, t4) {
  for (const n2 of t4) if (n2 === e4) return true;
  return false;
}
function me(e4) {
  return !!e4.layerDefinition && (!!e4.featureSet && (false !== ce(e4.layerDefinition.geometryType, ["", null, "esriGeometryNull", "esriGeometryPoint", "esriGeometryPolyline", "esriGeometryPolygon", "esriGeometryMultipoint", "esriGeometryEnvelope"]) && (false !== o4(e4.layerDefinition.fields) && false !== o4(e4.featureSet.features))));
}
function pe2(e4) {
  return "utc" === e4?.toLowerCase() ? "UTC" : "unknown" === e4?.toLowerCase() ? "Unknown" : e4;
}
async function ye(t4, n2, i3, a6, r5, l4, f2) {
  const d3 = await t4.getFeatureSetInfo();
  if (null === (d3?.layerId ?? null)) return null;
  if (!r5.layerIdLookup.get(d3.layerId)) return null;
  const c4 = t4.serviceUrl().replace(/\/FeatureServer/i, "/UtilityNetworkServer"), m5 = [];
  switch (i3) {
    case "connected":
      m5.push("connectivity"), m5.push("junction-edge-from-connectivity"), m5.push("junction-edge-to-connectivity"), m5.push("junction-edge-midspan-connectivity"), m5.push("junction-junction-connectivity");
      break;
    case "container":
    case "content":
      m5.push("containment");
      break;
    case "structure":
    case "attached":
      m5.push("attachment");
      break;
    case "junctionedge":
      m5.push("junction-edge-from-connectivity"), m5.push("junction-edge-to-connectivity");
      break;
    case "midspan":
      m5.push("junction-edge-midspan-connectivity");
      break;
    default:
      throw new a2(l4, r3.InvalidParameter, f2);
  }
  let p4 = null, y2 = false;
  if (null !== a6 && "" !== a6 && void 0 !== a6) {
    for (const e4 of r5.terminals) e4.terminalName === a6 && (p4 = e4.terminalId);
    null === p4 && (y2 = true);
  }
  const w = [];
  if (!y2) {
    const a7 = new s3({ globalId: n2.field(t4.globalIdField), networkSourceId: r5.layerIdLookup.get(d3.layerId).sourceId, ...p4 ? { terminalId: p4 } : "" }), o6 = await p3(c4, new n({ types: m5, elements: [a7] }));
    let s5 = 0;
    for (const t5 of o6.associations) {
      let n3 = null, o7 = "", l5 = "";
      if (t5.fromNetworkElement?.globalId === a7.globalId ? (n3 = t5.toNetworkElement, l5 = "to") : t5.toNetworkElement?.globalId === a7.globalId && (n3 = t5.fromNetworkElement, l5 = "from"), !n3) continue;
      switch (i3) {
        case "attached":
          if ("attachment" !== t5.associationType) continue;
          if ("to" !== l5) continue;
          break;
        case "structure":
          if ("attachment" !== t5.associationType) continue;
          if ("from" !== l5) continue;
          break;
        case "container":
          if ("containment" !== t5.associationType) continue;
          if ("from" !== l5) continue;
          break;
        case "content":
          if ("containment" !== t5.associationType) continue;
          if ("to" !== l5) continue;
          break;
        case "connected":
          break;
        case "junctionedge":
          "junction-edge-to-connectivity" === t5.associationType ? o7 = "to" : "junction-edge-from-connectivity" === t5.associationType && (o7 = "from");
          break;
        case "midspan":
          if ("junction-edge-midspan-connectivity" !== t5.associationType) continue;
      }
      const f3 = r5.sourceIdLookup.get(n3.networkSourceId)?.className ?? "";
      w.push(new d({ geometry: null, attributes: { objectId: s5++, globalId: n3.globalId, percentAlong: t5.percentAlong ?? 0, isContentVisible: t5.isContentVisible ? 0 : 1, className: f3, side: o7 } }));
    }
  }
  const I = new Xe({ source: w, geometryType: null, objectIdField: "objectId", globalIdField: "globalId", fields: [new m3({ name: "objectId", alias: "objectId", type: "oid" }), new m3({ name: "globalId", alias: "globalId", type: "global-id" }), new m3({ name: "percentAlong", alias: "percentAlong", type: "double" }), new m3({ name: "side", alias: "side", type: "string" }), new m3({ name: "isContentVisible", alias: "isContentVisible", type: "integer" }), new m3({ name: "className", alias: "className", type: "string" })] });
  return N(I);
}
function we(e4) {
  if ("async" === e4.mode) {
    e4.functions.timezone = function(n2, a6) {
      return e4.standardFunctionAsync(n2, a6, (async (e5, r5, l4) => {
        if (ae(l4, 1, 2, n2, a6), ie(l4[0])) return "Unknown";
        if (re(l4[0])) return "Unknown";
        if (K(l4[0])) {
          if (await l4[0].load(), 1 === l4.length || null === l4[1]) return l4[0].datesInUnknownTimezone ? pe2("unknown") : pe2(l4[0].dateFieldsTimeZone);
          if (!(l4[1] instanceof j) || false === l4[1].hasField("type")) throw new a2(n2, r3.InvalidParameter, a6);
          const e6 = l4[1].field("type");
          if (false === e2(e6)) throw new a2(n2, r3.InvalidParameter, a6);
          switch (pe(e6).toLowerCase()) {
            case "preferredtimezone":
              return pe2(l4[0].preferredTimeZone);
            case "editfieldsinfo":
              return pe2(l4[0].editFieldsInfo?.timeZone ?? null);
            case "timeinfo":
              return pe2(l4[0].timeInfo?.timeZone ?? null);
            case "field":
              if (l4[1].hasField("fieldname") && e2(l4[1].field("fieldname"))) return pe2(l4[0].fieldTimeZone(pe(l4[1].field("fieldname"))));
          }
          throw new a2(n2, r3.InvalidParameter, a6);
        }
        const f2 = Se(l4[0], Ke(n2));
        if (null === f2) return null;
        const d3 = f2.timeZone;
        return "system" === d3 ? h.systemTimeZoneCanonicalName : "utc" === d3.toLowerCase() ? "UTC" : "unknown" === d3.toLowerCase() ? "Unknown" : d3;
      }));
    }, e4.functions.sqltimestamp = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (e5, i3, a6) => {
        ae(a6, 1, 3, t4, n2);
        const r5 = a6[0];
        if (ne(r5)) {
          if (1 === a6.length) return r5.toSQLWithKeyword();
          if (2 === a6.length) return r5.changeTimeZone(pe(a6[1])).toSQLWithKeyword();
          throw new a2(t4, r3.InvalidParameter, n2);
        }
        if (re(r5)) return r5.toSQLWithKeyword();
        if (K(r5)) {
          if (3 !== a6.length) throw new a2(t4, r3.InvalidParameter, n2);
          await r5.load();
          const e6 = pe(a6[1]);
          if (re(a6[2])) return a6[2].toSQLWithKeyword();
          if (false === ne(a6[2])) throw new a2(t4, r3.InvalidParameter, n2);
          const i4 = r5.fieldTimeZone(e6);
          return null == i4 ? a6[2].toSQLWithKeyword() : a6[2].changeTimeZone(i4).toSQLWithKeyword();
        }
        throw new a2(t4, r3.InvalidParameter, n2);
      }));
    }, e4.signatures.push({ name: "sqltimestamp", min: 2, max: 4 }), e4.functions.featuresetbyid = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, ((e5, i3, a6) => {
        if (ae(a6, 2, 4, t4, n2), X(a6[0])) {
          const e6 = pe(a6[1]);
          let i4 = q(a6[2], null);
          const r5 = Te(q(a6[3], true));
          if (null === i4 && (i4 = ["*"]), false === o4(i4)) throw new a2(t4, r3.InvalidParameter, n2);
          return a6[0].featureSetById(e6, r5, i4);
        }
        throw new a2(t4, r3.InvalidParameter, n2);
      }));
    }, e4.signatures.push({ name: "featuresetbyid", min: 2, max: 4 });
    const K2 = new e(["datasource", "parent", "root"]);
    e4.functions.getfeatureset = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (e5, i3, a6) => {
        if (ae(a6, 1, 2, t4, n2), $(a6[0])) {
          const e6 = null == a6[1] ? "datasource" : K2.lookup(pe(a6[1]));
          return R3(a6[0].fullSchema(), e6, t4.lrucache, t4.interceptor, t4.spatialReference);
        }
        throw new a2(t4, r3.InvalidParameter, n2);
      }));
    }, e4.signatures.push({ name: "getfeatureset", min: 1, max: 2 }), e4.functions.featuresetbyportalitem = function(t4, i3) {
      return e4.standardFunctionAsync(t4, i3, ((e5, a6, r5) => {
        if (ae(r5, 2, 5, t4, i3), null === r5[0]) throw new a2(t4, r3.PortalRequired, i3);
        if (r5[0] instanceof t2) {
          const e6 = pe(r5[1]), n2 = pe(r5[2]);
          let a7 = q(r5[3], null);
          const l5 = Te(q(r5[4], true));
          if (null === a7 && (a7 = ["*"]), false === o4(a7)) throw new a2(t4, r3.InvalidParameter, i3);
          let f3;
          return f3 = t4.services?.portal ? t4.services.portal : C.getDefault(), f3 = l3(r5[0], f3), q2(e6, n2, t4.spatialReference, a7, l5, f3, t4.lrucache, t4.interceptor);
        }
        if (false === e2(r5[0])) throw new a2(t4, r3.PortalRequired, i3);
        const l4 = pe(r5[0]), f2 = pe(r5[1]);
        let u3 = q(r5[2], null);
        const c4 = Te(q(r5[3], true));
        if (null === u3 && (u3 = ["*"]), false === o4(u3)) throw new a2(t4, r3.InvalidParameter, i3);
        return q2(l4, f2, t4.spatialReference, u3, c4, t4.services?.portal ?? C.getDefault(), t4.lrucache, t4.interceptor);
      }));
    }, e4.signatures.push({ name: "featuresetbyportalitem", min: 2, max: 5 }), e4.functions.featuresetbyname = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, ((e5, i3, a6) => {
        if (ae(a6, 2, 4, t4, n2), X(a6[0])) {
          const e6 = pe(a6[1]);
          let i4 = q(a6[2], null);
          const r5 = Te(q(a6[3], true));
          if (null === i4 && (i4 = ["*"]), false === o4(i4)) throw new a2(t4, r3.InvalidParameter, n2);
          return a6[0].featureSetByName(e6, r5, i4);
        }
        throw new a2(t4, r3.InvalidParameter, n2);
      }));
    }, e4.signatures.push({ name: "featuresetbyname", min: 2, max: 4 }), e4.functions.featureset = function(t4, n2) {
      return e4.standardFunction(t4, n2, ((e5, a6, r5) => {
        ae(r5, 1, 1, t4, n2);
        const l4 = { layerDefinition: { geometryType: "", objectIdField: "", globalIdField: "", typeIdField: "", hasM: false, hasZ: false, fields: [] }, featureSet: { geometryType: "", features: [] } };
        if (e2(r5[0])) {
          const e6 = JSON.parse(r5[0]);
          void 0 !== e6.layerDefinition ? (l4.layerDefinition = e6.layerDefinition, l4.featureSet = e6.featureSet, e6.layerDefinition.spatialReference && (l4.layerDefinition.spatialReference = e6.layerDefinition.spatialReference)) : (l4.featureSet.features = e6.features, l4.featureSet.geometryType = e6.geometryType, l4.layerDefinition.geometryType = l4.featureSet.geometryType, l4.layerDefinition.objectIdField = e6.objectIdFieldName ?? "", l4.layerDefinition.typeIdField = e6.typeIdFieldName, l4.layerDefinition.globalIdField = e6.globalIdFieldName, l4.layerDefinition.fields = e6.fields, e6.spatialReference && (l4.layerDefinition.spatialReference = e6.spatialReference));
        } else {
          if (!(r5[0] instanceof j)) throw new a2(t4, r3.InvalidParameter, n2);
          {
            const e6 = JSON.parse(r5[0].castToText(true)), i3 = le(e6, "layerdefinition");
            if (null !== i3) {
              l4.layerDefinition.geometryType = le(i3, "geometrytype", ""), l4.featureSet.geometryType = l4.layerDefinition.geometryType, l4.layerDefinition.globalIdField = le(i3, "globalidfield", ""), l4.layerDefinition.objectIdField = le(i3, "objectidfield", ""), l4.layerDefinition.typeIdField = le(i3, "typeidfield", ""), l4.layerDefinition.hasZ = true === le(i3, "hasz", false), l4.layerDefinition.hasM = true === le(i3, "hasm", false);
              const t5 = le(i3, "spatialreference");
              t5 && (l4.layerDefinition.spatialReference = de(t5));
              const n3 = [];
              for (const e7 of le(i3, "fields", [])) {
                const t6 = { name: le(e7, "name", ""), alias: le(e7, "alias", ""), type: le(e7, "type", ""), nullable: le(e7, "nullable", true), editable: le(e7, "editable", true), length: le(e7, "length", null), domain: fe(le(e7, "domain")) };
                n3.push(t6);
              }
              l4.layerDefinition.fields = n3;
              const a7 = le(e6, "featureset");
              if (a7) {
                const e7 = {};
                for (const t6 of n3) e7[t6.name.toLowerCase()] = t6.name;
                for (const t6 of le(a7, "features", [])) {
                  const n4 = {}, i4 = le(t6, "attributes", {});
                  for (const t7 in i4) n4[e7[t7.toLowerCase()]] = i4[t7];
                  l4.featureSet.features.push({ attributes: n4, geometry: ue(le(t6, "geometry")) });
                }
              }
            } else {
              l4.layerDefinition.hasZ = true === le(e6, "hasz", false), l4.layerDefinition.hasM = true === le(e6, "hasm", false), l4.layerDefinition.geometryType = le(e6, "geometrytype", ""), l4.featureSet.geometryType = l4.layerDefinition.geometryType, l4.layerDefinition.objectIdField = le(e6, "objectidfieldname", ""), l4.layerDefinition.typeIdField = le(e6, "typeidfieldname", "");
              const i4 = le(e6, "spatialreference");
              i4 && (l4.layerDefinition.spatialReference = de(i4));
              const a7 = [], r6 = le(e6, "fields", null);
              if (!o4(r6)) throw new a2(t4, r3.InvalidParameter, n2);
              for (const e7 of r6) {
                const t5 = { name: le(e7, "name", ""), alias: le(e7, "alias", ""), type: le(e7, "type", ""), nullable: le(e7, "nullable", true), editable: le(e7, "editable", true), length: le(e7, "length", null), domain: fe(le(e7, "domain")) };
                a7.push(t5);
              }
              l4.layerDefinition.fields = a7;
              const f2 = {};
              for (const e7 of a7) f2[e7.name.toLowerCase()] = e7.name;
              let d3 = le(e6, "features", null);
              if (o4(d3)) for (const e7 of d3) {
                const t5 = {}, n3 = le(e7, "attributes", {});
                for (const e8 in n3) t5[f2[e8.toLowerCase()]] = n3[e8];
                l4.featureSet.features.push({ attributes: t5, geometry: ue(le(e7, "geometry", null)) });
              }
              else d3 = null, l4.featureSet.features = d3;
            }
          }
        }
        if (false === me(l4)) throw new a2(t4, r3.InvalidParameter, n2);
        return l4.layerDefinition.geometryType || (l4.layerDefinition.geometryType = "esriGeometryNull"), p.create(l4, t4.spatialReference);
      }));
    }, e4.signatures.push({ name: "featureset", min: 1, max: 1 }), e4.functions.filter = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (i3, a6, r5) => {
        if (ae(r5, 2, 2, t4, n2), o4(r5[0]) || te(r5[0])) {
          const e5 = [];
          let i4, a7 = r5[0];
          if (a7 instanceof t && (a7 = a7.toArray()), !G(r5[1])) throw new a2(t4, r3.InvalidParameter, n2);
          i4 = r5[1].createFunction(t4);
          for (const t5 of a7) {
            const n3 = i4(t5);
            S(n3) ? true === await n3 && e5.push(t5) : true === n3 && e5.push(t5);
          }
          return e5;
        }
        if (K(r5[0])) {
          const n3 = await r5[0].load(), i4 = R.create(r5[1], { fieldsIndex: n3.getFieldsIndex(), timeZone: n3.dateFieldsTimeZoneDefaultUTC }), a7 = i4.getVariables();
          if (a7.length > 0) {
            const n4 = {};
            for (const i5 of a7) n4[i5] = e4.evaluateIdentifier(t4, { name: i5 });
            i4.parameters = n4;
          }
          return new c2({ parentfeatureset: r5[0], whereclause: i4 });
        }
        throw new a2(t4, r3.InvalidParameter, n2);
      }));
    }, e4.signatures.push({ name: "filter", min: 2, max: 2 }), e4.functions.orderby = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (e5, i3, a6) => {
        if (ae(a6, 2, 2, t4, n2), K(a6[0])) {
          const e6 = new e3(a6[1]);
          return new a3({ parentfeatureset: a6[0], orderbyclause: e6 });
        }
        throw new a2(t4, r3.InvalidParameter, n2);
      }));
    }, e4.signatures.push({ name: "orderby", min: 2, max: 2 }), e4.functions.top = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (e5, i3, a6) => {
        if (ae(a6, 2, 2, t4, n2), K(a6[0])) return new a4({ parentfeatureset: a6[0], topnum: a6[1] });
        if (o4(a6[0])) return Ne(a6[1]) >= a6[0].length ? a6[0].slice() : a6[0].slice(0, Ne(a6[1]));
        if (te(a6[0])) return Ne(a6[1]) >= a6[0].length() ? a6[0].slice() : a6[0].slice(0, Ne(a6[1]));
        throw new a2(t4, r3.InvalidParameter, n2);
      }));
    }, e4.signatures.push({ name: "top", min: 2, max: 2 }), e4.functions.first = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (e5, i3, a6) => {
        if (ae(a6, 1, 1, t4, n2), K(a6[0])) {
          const n3 = await a6[0].first(e5.abortSignal);
          if (null !== n3) {
            const e6 = D.createFromGraphicLikeObject(n3.geometry, n3.attributes, a6[0], t4.timeZone);
            return e6._underlyingGraphic = n3, e6;
          }
          return n3;
        }
        return o4(a6[0]) ? 0 === a6[0].length ? null : a6[0][0] : te(a6[0]) ? 0 === a6[0].length() ? null : a6[0].get(0) : null;
      }));
    }, e4.signatures.push({ name: "first", min: 1, max: 1 }), e4.functions.attachments = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (e5, a6, r5) => {
        ae(r5, 1, 2, t4, n2);
        const l4 = { minsize: -1, maxsize: -1, types: null, returnMetadata: false };
        if (r5.length > 1) {
          if (r5[1] instanceof j) {
            if (r5[1].hasField("minsize") && (l4.minsize = Ne(r5[1].field("minsize"))), r5[1].hasField("metadata") && (l4.returnMetadata = Te(r5[1].field("metadata"))), r5[1].hasField("maxsize") && (l4.maxsize = Ne(r5[1].field("maxsize"))), r5[1].hasField("types")) {
              const e6 = _e(r5[1].field("types"), false);
              e6.length > 0 && (l4.types = e6);
            }
          } else if (null !== r5[1]) throw new a2(t4, r3.InvalidParameter, n2);
        }
        if ($(r5[0])) {
          const e6 = r5[0]._layer;
          let n3;
          if (K(e6)) n3 = e6;
          else {
            if (null == e6 || !x(e6)) return [];
            n3 = N(e6, t4.spatialReference, ["*"], true, t4.lrucache, t4.interceptor);
          }
          return await n3.load(), n3.queryAttachments(r5[0].field(n3.objectIdField), l4.minsize, l4.maxsize, l4.types, l4.returnMetadata);
        }
        if (null === r5[0]) return [];
        throw new a2(t4, r3.InvalidParameter, n2);
      }));
    }, e4.signatures.push({ name: "attachments", min: 1, max: 2 }), e4.functions.featuresetbyrelationshipname = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (e5, i3, a6) => {
        ae(a6, 2, 4, t4, n2);
        const r5 = a6[0], l4 = pe(a6[1]);
        let f2 = q(a6[2], null);
        const d3 = Te(q(a6[3], true));
        if (null === f2 && (f2 = ["*"]), false === o4(f2)) throw new a2(t4, r3.InvalidParameter, n2);
        if (null === a6[0]) return null;
        if (!$(a6[0])) throw new a2(t4, r3.InvalidParameter, n2);
        const p4 = r5._layer;
        let y2;
        if (K(p4)) y2 = p4;
        else {
          if (null == p4 || !x(p4)) return null;
          y2 = N(p4, t4.spatialReference, ["*"], true, t4.lrucache, t4.interceptor);
        }
        y2 = await y2.load();
        const I = y2.relationshipMetaData().filter(((e6) => e6.name === l4));
        if (0 === I.length) return null;
        if (void 0 !== I[0].relationshipTableId && null !== I[0].relationshipTableId && I[0].relationshipTableId > -1) return j2(y2, I[0], r5.field(y2.objectIdField), y2.spatialReference, f2, d3, t4.lrucache, t4.interceptor);
        let h2 = y2.serviceUrl();
        if (!h2) return null;
        h2 = "/" === h2.charAt(h2.length - 1) ? h2 + I[0].relatedTableId.toString() : h2 + "/" + I[0].relatedTableId.toString();
        const b2 = await F(h2, y2.spatialReference, f2, d3, t4.lrucache, t4.interceptor);
        await b2.load();
        let T = b2.relationshipMetaData();
        if (T = T.filter(((e6) => e6.id === I[0].id)), false === r5.hasField(I[0].keyField) || null === r5.field(I[0].keyField)) {
          const e6 = await y2.getFeatureByObjectId(r5.field(y2.objectIdField), [I[0].keyField]);
          if (e6) {
            const t5 = R.create(T[0].keyField + "= @id", { fieldsIndex: b2.getFieldsIndex(), timeZone: b2.dateFieldsTimeZoneDefaultUTC });
            return t5.parameters = { id: e6.attributes[I[0].keyField] }, b2.filter(t5);
          }
          return new u2({ parentfeatureset: b2 });
        }
        const D2 = R.create(T[0].keyField + "= @id", { fieldsIndex: b2.getFieldsIndex(), timeZone: b2.dateFieldsTimeZoneDefaultUTC });
        return D2.parameters = { id: r5.field(I[0].keyField) }, b2.filter(D2);
      }));
    }, e4.signatures.push({ name: "featuresetbyrelationshipname", min: 2, max: 4 }), e4.functions.featuresetbyassociation = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (e5, i3, a6) => {
        ae(a6, 2, 3, t4, n2);
        const l4 = a6[0], f2 = o3(pe(q(a6[1], ""))), d3 = e2(a6[2]) ? pe(a6[2]) : null;
        if (null === a6[0]) return null;
        if (!$(a6[0])) throw new a2(t4, r3.InvalidParameter, n2);
        let c4 = l4._layer;
        if (c4 instanceof Xe && (c4 = N(c4, t4.spatialReference, ["*"], true, t4.lrucache, t4.interceptor)), null === c4) return null;
        if (false === K(c4)) return null;
        await c4.load();
        const m5 = c4.serviceUrl(), y2 = await E(m5, t4.spatialReference, true);
        if (y2.unVersion >= 8) return await ye(c4, l4, f2, d3, y2, t4, n2);
        const I = y2.associations;
        let h2 = null, b2 = null, T = false;
        if (null !== d3 && "" !== d3 && void 0 !== d3) {
          for (const e6 of y2.terminals) e6.terminalName === d3 && (b2 = e6.terminalId);
          null === b2 && (T = true);
        }
        const D2 = I.getFieldsIndex(), x2 = D2.get("TOGLOBALID").name, N2 = D2.get("FROMGLOBALID").name, v = D2.get("TOTERMINALID").name, S2 = D2.get("FROMTERMINALID").name, L3 = D2.get("FROMNETWORKSOURCEID").name, j3 = D2.get("TONETWORKSOURCEID").name, k2 = D2.get("ASSOCIATIONTYPE").name, R4 = D2.get("ISCONTENTVISIBLE").name, O2 = D2.get("OBJECTID").name;
        for (const t5 of c4.fields) if ("global-id" === t5.type) {
          h2 = l4.field(t5.name);
          break;
        }
        let z = null, H2 = new L2(new m3({ name: "percentalong", alias: "percentalong", type: "double" }), R.create("0", { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC })), W = new L2(new m3({ name: "side", alias: "side", type: "string" }), R.create("''", { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC }));
        const G2 = "globalid", V = "globalId", B2 = {};
        for (const t5 in y2.lkp) B2[t5] = y2.lkp[t5].sourceId;
        const K3 = new B(new m3({ name: "classname", alias: "classname", type: "string" }), null, B2);
        let q3 = "";
        switch (f2) {
          case "midspan": {
            q3 = `((${x2}='${h2}') OR ( ${N2}='${h2}')) AND (${k2} IN (5))`, K3.codefield = R.create(`CASE WHEN (${x2}='${h2}') THEN ${L3} ELSE ${j3} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC });
            const e6 = s(R2.findField(I.fields, N2));
            e6.name = G2, e6.alias = G2, z = new L2(e6, R.create(`CASE WHEN (${N2}='${h2}') THEN ${x2} ELSE ${N2} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC })), H2 = y2.unVersion >= 4 ? new k(R2.findField(I.fields, D2.get("PERCENTALONG").name)) : new L2(new m3({ name: "percentalong", alias: "percentalong", type: "double" }), R.create("0", { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC }));
            break;
          }
          case "junctionedge": {
            q3 = `((${x2}='${h2}') OR ( ${N2}='${h2}')) AND (${k2} IN (4,6))`, K3.codefield = R.create(`CASE WHEN (${x2}='${h2}') THEN ${L3} ELSE ${j3} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC });
            const e6 = s(R2.findField(I.fields, N2));
            e6.name = G2, e6.alias = G2, z = new L2(e6, R.create(`CASE WHEN (${N2}='${h2}') THEN ${x2} ELSE ${N2} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC })), W = new L2(new m3({ name: "side", alias: "side", type: "string" }), R.create(`CASE WHEN (${k2}=4) THEN 'from' ELSE 'to' END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC }));
            break;
          }
          case "connected": {
            let e6 = `${x2}='@T'`, t5 = `${N2}='@T'`;
            null !== b2 && (e6 += ` AND ${v}=@A`, t5 += ` AND ${S2}=@A`), q3 = "((" + e6 + ") OR (" + t5 + "))", q3 = L(q3, "@T", h2 ?? ""), e6 = L(e6, "@T", h2 ?? ""), null !== b2 && (e6 = L(e6, "@A", b2.toString()), q3 = L(q3, "@A", b2.toString())), K3.codefield = R.create("CASE WHEN " + e6 + ` THEN ${L3} ELSE ${j3} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC });
            const n3 = s(R2.findField(I.fields, N2));
            n3.name = G2, n3.alias = G2, z = new L2(n3, R.create("CASE WHEN " + e6 + ` THEN ${N2} ELSE ${x2} END`, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC }));
            break;
          }
          case "container":
            q3 = `${x2}='${h2}' AND ${k2} = 2`, null !== b2 && (q3 += ` AND ${v} = ` + b2.toString()), K3.codefield = L3, q3 = "( " + q3 + " )", z = new b(R2.findField(I.fields, N2), G2, G2);
            break;
          case "content":
            q3 = `(${N2}='${h2}' AND ${k2} = 2)`, null !== b2 && (q3 += ` AND ${S2} = ` + b2.toString()), K3.codefield = j3, q3 = "( " + q3 + " )", z = new b(R2.findField(I.fields, x2), G2, G2);
            break;
          case "structure":
            q3 = `(${x2}='${h2}' AND ${k2} = 3)`, null !== b2 && (q3 += ` AND ${v} = ` + b2.toString()), K3.codefield = L3, q3 = "( " + q3 + " )", z = new b(R2.findField(I.fields, N2), G2, V);
            break;
          case "attached":
            q3 = `(${N2}='${h2}' AND ${k2} = 3)`, null !== b2 && (q3 += ` AND ${S2} = ` + b2.toString()), K3.codefield = j3, q3 = "( " + q3 + " )", z = new b(R2.findField(I.fields, x2), G2, V);
            break;
          default:
            throw new a2(t4, r3.InvalidParameter, n2);
        }
        T && (q3 = "1 <> 1");
        return new R2({ parentfeatureset: I, adaptedFields: [new k(R2.findField(I.fields, O2)), new k(R2.findField(I.fields, R4)), z, W, K3, H2], extraFilter: q3 ? R.create(q3, { fieldsIndex: I.getFieldsIndex(), timeZone: I.dateFieldsTimeZoneDefaultUTC }) : null });
      }));
    }, e4.signatures.push({ name: "featuresetbyassociation", min: 2, max: 6 }), e4.functions.groupby = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (a6, r5, l4) => {
        if (ae(l4, 3, 3, t4, n2), !K(l4[0])) throw new a2(t4, r3.InvalidParameter, n2);
        const f2 = await l4[0].load(), d3 = [], u3 = [];
        let c4 = false, m5 = [];
        if (e2(l4[1])) m5.push(l4[1]);
        else if (l4[1] instanceof j) m5.push(l4[1]);
        else if (o4(l4[1])) m5 = l4[1];
        else {
          if (!te(l4[1])) throw new a2(t4, r3.InvalidParameter, n2);
          m5 = l4[1].toArray();
        }
        for (const e5 of m5) if (e2(e5)) {
          const t5 = R.create(pe(e5), { fieldsIndex: f2.getFieldsIndex(), timeZone: f2.dateFieldsTimeZoneDefaultUTC }), n3 = true === O(t5) ? pe(e5) : "%%%%FIELDNAME";
          d3.push({ name: n3, expression: t5 }), "%%%%FIELDNAME" === n3 && (c4 = true);
        } else {
          if (!(e5 instanceof j)) throw new a2(t4, r3.InvalidParameter, n2);
          {
            const i3 = e5.hasField("name") ? e5.field("name") : "%%%%FIELDNAME", a7 = e5.hasField("expression") ? e5.field("expression") : "";
            if ("%%%%FIELDNAME" === i3 && (c4 = true), !i3) throw new a2(t4, r3.InvalidParameter, n2);
            d3.push({ name: i3, expression: R.create(a7 || i3, { fieldsIndex: f2.getFieldsIndex(), timeZone: f2.dateFieldsTimeZoneDefaultUTC }) });
          }
        }
        if (m5 = [], e2(l4[2])) m5.push(l4[2]);
        else if (o4(l4[2])) m5 = l4[2];
        else if (te(l4[2])) m5 = l4[2].toArray();
        else {
          if (!(l4[2] instanceof j)) throw new a2(t4, r3.InvalidParameter, n2);
          m5.push(l4[2]);
        }
        for (const e5 of m5) {
          if (!(e5 instanceof j)) throw new a2(t4, r3.InvalidParameter, n2);
          {
            const i3 = e5.hasField("name") ? e5.field("name") : "", a7 = e5.hasField("statistic") ? e5.field("statistic") : "", r6 = e5.hasField("expression") ? e5.field("expression") : "";
            if (!(i3 && a7 && e2(a7) && r6)) throw new a2(t4, r3.InvalidParameter, n2);
            u3.push({ name: i3, statistic: a7, expression: R.create(r6, { fieldsIndex: f2.getFieldsIndex(), timeZone: f2.dateFieldsTimeZoneDefaultUTC }) });
          }
        }
        if (c4) {
          const e5 = {};
          for (const n3 of f2.fields) e5[n3.name.toLowerCase()] = 1;
          for (const n3 of d3) "%%%%FIELDNAME" !== n3.name && (e5[n3.name.toLowerCase()] = 1);
          for (const n3 of u3) "%%%%FIELDNAME" !== n3.name && (e5[n3.name.toLowerCase()] = 1);
          let t5 = 0;
          for (const n3 of d3) if ("%%%%FIELDNAME" === n3.name) {
            for (; 1 === e5["field_" + t5.toString()]; ) t5++;
            e5["field_" + t5.toString()] = 1, n3.name = "FIELD_" + t5.toString();
          }
        }
        for (const n3 of d3) se(n3.expression, e4, t4);
        for (const n3 of u3) se(n3.expression, e4, t4);
        return l4[0].groupby(d3, u3);
      }));
    }, e4.signatures.push({ name: "groupby", min: 3, max: 3 }), e4.functions.distinct = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (a6, r5, l4) => {
        if (K(l4[0])) {
          ae(l4, 2, 2, t4, n2);
          const a7 = await l4[0].load(), r6 = [];
          let f2 = [];
          if (e2(l4[1])) f2.push(l4[1]);
          else if (l4[1] instanceof j) f2.push(l4[1]);
          else if (o4(l4[1])) f2 = l4[1];
          else {
            if (!te(l4[1])) throw new a2(t4, r3.InvalidParameter, n2);
            f2 = l4[1].toArray();
          }
          let d3 = false;
          for (const e5 of f2) if (e2(e5)) {
            const t5 = R.create(pe(e5), { fieldsIndex: a7.getFieldsIndex(), timeZone: a7.dateFieldsTimeZoneDefaultUTC }), n3 = true === O(t5) ? pe(e5) : "%%%%FIELDNAME";
            r6.push({ name: n3, expression: t5 }), "%%%%FIELDNAME" === n3 && (d3 = true);
          } else {
            if (!(e5 instanceof j)) throw new a2(t4, r3.InvalidParameter, n2);
            {
              const i3 = e5.hasField("name") ? e5.field("name") : "%%%%FIELDNAME", l5 = e5.hasField("expression") ? e5.field("expression") : "";
              if ("%%%%FIELDNAME" === i3 && (d3 = true), !i3) throw new a2(t4, r3.InvalidParameter, n2);
              r6.push({ name: i3, expression: R.create(l5 || i3, { fieldsIndex: a7.getFieldsIndex(), timeZone: a7.dateFieldsTimeZoneDefaultUTC }) });
            }
          }
          if (d3) {
            const e5 = {};
            for (const n3 of a7.fields) e5[n3.name.toLowerCase()] = 1;
            for (const n3 of r6) "%%%%FIELDNAME" !== n3.name && (e5[n3.name.toLowerCase()] = 1);
            let t5 = 0;
            for (const n3 of r6) if ("%%%%FIELDNAME" === n3.name) {
              for (; 1 === e5["field_" + t5.toString()]; ) t5++;
              e5["field_" + t5.toString()] = 1, n3.name = "FIELD_" + t5.toString();
            }
          }
          for (const n3 of r6) se(n3.expression, e4, t4);
          return l4[0].groupby(r6, []);
        }
        return oe(l4);
      }));
    }, e4.functions.getfeaturesetinfo = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (e5, a6, r5) => {
        if (ae(r5, 1, 1, t4, n2), !K(r5[0])) return null;
        const o6 = await r5[0].getFeatureSetInfo();
        return o6 ? j.convertObjectToArcadeDictionary({ layerId: o6.layerId, layerName: o6.layerName, itemId: o6.itemId, serviceLayerUrl: o6.serviceLayerUrl, webMapLayerId: o6.webMapLayerId ?? null, webMapLayerTitle: o6.webMapLayerTitle ?? null, className: null, objectClassId: null }, Ke(t4), false, false) : null;
      }));
    }, e4.signatures.push({ name: "getfeaturesetinfo", min: 1, max: 1 }), e4.functions.filterbysubtypecode = function(t4, n2) {
      return e4.standardFunctionAsync(t4, n2, (async (e5, i3, a6) => {
        if (ae(a6, 2, 2, t4, n2), K(a6[0])) {
          const e6 = await a6[0].load(), i4 = a6[1];
          if (!r4(i4)) throw new a2(t4, r3.InvalidParameter, n2);
          if (e6.subtypeField) {
            const t5 = R.create(`${e6.subtypeField}= ${a6[1]}`, { fieldsIndex: e6.getFieldsIndex(), timeZone: e6.dateFieldsTimeZoneDefaultUTC });
            return new c2({ parentfeatureset: a6[0], whereclause: t5 });
          }
          if (null === e6.typeIdField || "" === e6.typeIdField) throw new a2(t4, r3.FeatureSetDoesNotHaveSubtypes, n2);
          const r5 = R.create(`${e6.typeIdField}= ${a6[1]}`, { fieldsIndex: e6.getFieldsIndex(), timeZone: e6.dateFieldsTimeZoneDefaultUTC });
          return new c2({ parentfeatureset: a6[0], whereclause: r5 });
        }
        throw new a2(t4, r3.InvalidParameter, n2);
      }));
    }, e4.signatures.push({ name: "filterbysubtypecode", min: 2, max: 2 });
  }
}
export {
  we as registerFunctions
};
//# sourceMappingURL=featuresetbase-YQTNR6XX.js.map
