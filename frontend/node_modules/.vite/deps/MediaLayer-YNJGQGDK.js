import {
  c as c3,
  e as e3,
  i as i2,
  j as j2,
  n as n7,
  p as p6
} from "./chunk-B3GRIPCF.js";
import {
  r as r5
} from "./chunk-KJ4LM5AS.js";
import {
  A
} from "./chunk-BZSAIP56.js";
import {
  p as p3
} from "./chunk-CHGKJUJ3.js";
import "./chunk-3YBQQHIP.js";
import "./chunk-OJQCHQYS.js";
import {
  t as t2
} from "./chunk-N3W3EVP3.js";
import {
  b2 as b
} from "./chunk-ZJXLBTN2.js";
import "./chunk-SIRTOV2N.js";
import {
  j
} from "./chunk-H2PFGMJP.js";
import {
  S
} from "./chunk-OFINLTIW.js";
import "./chunk-OUBBZ23V.js";
import "./chunk-G2F62CY5.js";
import {
  e as e2,
  n as n6
} from "./chunk-LOLNWH3R.js";
import "./chunk-W3BJJE6D.js";
import "./chunk-UZ3YWBWC.js";
import "./chunk-2EOHKZLO.js";
import {
  o as o4
} from "./chunk-5J3DOLRD.js";
import "./chunk-OXO3GGCE.js";
import {
  p as p4
} from "./chunk-IUEKX5MN.js";
import {
  s as s5
} from "./chunk-2RL34CVC.js";
import {
  I,
  _ as _3,
  o as o5
} from "./chunk-BNQMKYX6.js";
import {
  n as n5,
  r as r4
} from "./chunk-B6C2GOG6.js";
import "./chunk-K3VYMAVM.js";
import "./chunk-OT2P27SF.js";
import "./chunk-KPGNM4LZ.js";
import {
  t
} from "./chunk-FNXTTV6Z.js";
import {
  p as p5
} from "./chunk-MBPP56MY.js";
import {
  h
} from "./chunk-R25QZWQ7.js";
import "./chunk-BELQIHLO.js";
import "./chunk-BPI4BR4E.js";
import "./chunk-YVMULGDJ.js";
import {
  O,
  Q,
  X
} from "./chunk-CJDZN5K5.js";
import "./chunk-N77BULFI.js";
import "./chunk-6TZIEYTZ.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-A6R2FXH6.js";
import "./chunk-H6ZVHKNF.js";
import {
  u
} from "./chunk-YAXW2DL6.js";
import "./chunk-QLKHFYAN.js";
import {
  n as n2
} from "./chunk-FV6ZNHFI.js";
import "./chunk-W5UOLFE2.js";
import "./chunk-AZ2S2PYZ.js";
import "./chunk-SCMB64VM.js";
import "./chunk-FOPBVVXE.js";
import {
  n as n4
} from "./chunk-INI6MHIQ.js";
import {
  n as n3
} from "./chunk-R7YP6EQJ.js";
import "./chunk-QUZZIDFR.js";
import {
  a as a2
} from "./chunk-CBCDVQSA.js";
import {
  V as V2
} from "./chunk-74GULGYB.js";
import "./chunk-RKF6WUZT.js";
import {
  P
} from "./chunk-RMRI4NYS.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import {
  o as o3
} from "./chunk-BLBN3L5Q.js";
import "./chunk-5EWIWLNU.js";
import {
  p as p2
} from "./chunk-TOCH3L2K.js";
import {
  x2 as x,
  z
} from "./chunk-CBXZL53X.js";
import {
  l
} from "./chunk-HYAO4PVV.js";
import "./chunk-SRNKPAJX.js";
import "./chunk-MOMLPET6.js";
import {
  o
} from "./chunk-VNQUG2TO.js";
import {
  m as m3
} from "./chunk-EULNFFHG.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-LPCUYJ2B.js";
import "./chunk-3QHX4R4B.js";
import {
  _ as _2
} from "./chunk-SMO33YG7.js";
import {
  f
} from "./chunk-LCBAL6ER.js";
import {
  s as s4
} from "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import {
  s as s3
} from "./chunk-67AKDROO.js";
import "./chunk-CM3TIXEV.js";
import {
  H,
  U,
  m,
  p,
  y
} from "./chunk-2AYGXVZI.js";
import {
  T,
  V,
  Y,
  Z,
  _,
  k,
  tt,
  ut
} from "./chunk-OUZJZB6I.js";
import {
  c as c2
} from "./chunk-4AKMPOG7.js";
import "./chunk-2CJBZZN7.js";
import {
  M,
  c,
  r as r3
} from "./chunk-ZJQPHR3K.js";
import {
  o as o2
} from "./chunk-NJZD7WM5.js";
import {
  r as r2
} from "./chunk-CL7VLXUR.js";
import {
  l as l2
} from "./chunk-FCX4ZA3Z.js";
import {
  e,
  m2,
  n2 as n
} from "./chunk-2ZPU5IZX.js";
import {
  a2 as a
} from "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import "./chunk-JNYZ3I5R.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import {
  k as k2,
  s as s2
} from "./chunk-N626Y23H.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/GeoreferenceBase.js
var c4 = class extends a2 {
  projectOrWarn(e4, r6) {
    if (null == e4) return e4;
    const { geometry: t3, pending: c5 } = X(e4, r6);
    return c5 ? null : c5 || t3 ? t3 : (i.getLogger(this).warn("geometry could not be projected to the spatial reference", { georeference: this, geometry: e4, sourceSpatialReference: e4.spatialReference, targetSpatialReference: r6 }), null);
  }
};
c4 = r([a("esri.layers.support.GeoreferenceBase")], c4);

// node_modules/@arcgis/core/layers/support/ControlPointsGeoreference.js
var S2 = e2();
var C = n5();
var N = class extends l2 {
};
r([m2({ type: Number, json: { write: { isRequired: true } } })], N.prototype, "x", void 0), r([m2({ type: Number, json: { write: { isRequired: true } } })], N.prototype, "y", void 0), N = r([a("esri.layers.support.ControlPointsGeoreference.ControlPointJSONType")], N);
var q = class extends a2 {
  constructor() {
    super(...arguments), this.sourcePoint = null, this.mapPoint = null;
  }
};
r([m2()], q.prototype, "sourcePoint", void 0), r([m2({ type: _2 })], q.prototype, "mapPoint", void 0), q = r([a("esri.layers.support.ControlPointsGeoreference.ControlPoint")], q);
var O2 = class extends l2.JSONSupportMixin(c4) {
  constructor(t3) {
    super(t3), this.controlPoints = null, this.height = 0, this.type = "control-points", this.width = 0;
  }
  readControlPoints(t3, o6) {
    const e4 = f.fromJSON(o6.spatialReference), r6 = n6(...o6.coefficients, 1);
    return t3.map(((t4) => (o5(C, t4.x, t4.y), p6(C, C, r6), { sourcePoint: t4, mapPoint: new _2({ x: C[0], y: C[1], spatialReference: e4 }) })));
  }
  writeControlPoints(t3, o6, r6, i3) {
    if (null != this.transform) null != t3 && T2(t3[0]) && (o6.controlPoints = t3.map(((t4) => {
      const o7 = t4.sourcePoint;
      return { x: o7.x, y: o7.y };
    })), o6.spatialReference = t3[0].mapPoint.spatialReference.toJSON(), o6.coefficients = this.transform.slice(0, 8));
    else {
      const t4 = new s("web-document-write:invalid-georeference", "Invalid 'controlPoints', 'width', 'height' configuration. Make sure the parent media element is loaded i.e. the ImageElement or VideoElement set as 'MediaLayer.source'.", { layer: i3?.layer, georeference: this });
      i3?.messages ? i3.messages.push(t4) : i.getLogger(this).error(t4.name, t4.message);
    }
  }
  get coords() {
    if (null == this.controlPoints) return null;
    const t3 = this._updateTransform(S2);
    if (null == t3 || !T2(this.controlPoints[0])) return null;
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    return K(t3, this.width, this.height, o6);
  }
  set coords(t3) {
    if (null == this.controlPoints || !T2(this.controlPoints[0])) return;
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    if (null == (t3 = this.projectOrWarn(t3, o6))) return;
    const { width: e4, height: r6 } = this, { rings: [[n8, s6, c5, a3]] } = t3, p8 = { sourcePoint: c2(0, r6), mapPoint: new _2({ x: n8[0], y: n8[1], spatialReference: o6 }) }, u6 = { sourcePoint: c2(0, 0), mapPoint: new _2({ x: s6[0], y: s6[1], spatialReference: o6 }) }, m4 = { sourcePoint: c2(e4, 0), mapPoint: new _2({ x: c5[0], y: c5[1], spatialReference: o6 }) }, f2 = { sourcePoint: c2(e4, r6), mapPoint: new _2({ x: a3[0], y: a3[1], spatialReference: o6 }) };
    T2(p8) && T2(u6) && T2(m4) && T2(f2) && (B(S2, p8, u6, m4, f2), this.controlPoints = this.controlPoints.map((({ sourcePoint: t4 }) => (o5(C, t4.x, t4.y), p6(C, C, S2), { sourcePoint: t4, mapPoint: new _2({ x: C[0], y: C[1], spatialReference: o6 }) }))));
  }
  get inverseTransform() {
    return null == this.transform ? null : s5(e2(), this.transform);
  }
  get transform() {
    return this._updateTransform();
  }
  toMap(t3) {
    if (null == t3 || null == this.transform || null == this.controlPoints || !T2(this.controlPoints[0])) return null;
    o5(C, t3.x, t3.y);
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    return p6(C, C, this.transform), new _2({ x: C[0], y: C[1], spatialReference: o6 });
  }
  toSource(t3) {
    if (null == t3 || null == this.inverseTransform || null == this.controlPoints || !T2(this.controlPoints[0])) return null;
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    return t3 = t3.normalize(), null == (t3 = X(t3, o6).geometry) ? null : (o5(C, t3.x, t3.y), p6(C, C, this.inverseTransform), c2(C[0], C[1]));
  }
  toSourceNormalized(t3) {
    const o6 = this.toSource(t3);
    return null != o6 && (o6.x /= this.width, o6.y /= this.height), o6;
  }
  _updateTransform(t3) {
    const { controlPoints: o6, width: e4, height: r6 } = this;
    if (!(null != o6 && e4 > 0 && r6 > 0)) return null;
    const [n8, i3, s6, l3] = o6;
    if (!T2(n8)) return null;
    const c5 = n8.mapPoint.spatialReference, a3 = this._projectControlPoint(i3, c5), p8 = this._projectControlPoint(s6, c5), u6 = this._projectControlPoint(l3, c5);
    if (!a3.valid || !p8.valid || !u6.valid) return null;
    if (!T2(a3.controlPoint)) return null;
    null == t3 && (t3 = e2());
    let m4 = null;
    return m4 = T2(p8.controlPoint) && T2(u6.controlPoint) ? B(t3, n8, a3.controlPoint, p8.controlPoint, u6.controlPoint) : T2(p8.controlPoint) ? V3(t3, n8, a3.controlPoint, p8.controlPoint) : A2(t3, n8, a3.controlPoint), m4.every(((t4) => 0 === t4)) ? null : m4;
  }
  _projectControlPoint(t3, o6) {
    if (!T2(t3)) return { valid: true, controlPoint: t3 };
    const { sourcePoint: e4, mapPoint: r6 } = t3, { geometry: i3, pending: s6 } = X(r6, o6);
    return s6 ? { valid: false, controlPoint: null } : s6 || i3 ? { valid: true, controlPoint: { sourcePoint: e4, mapPoint: i3 } } : (i.getLogger(this).warn("map point could not be projected to the spatial reference", { georeference: this, controlPoint: t3, sourceSpatialReference: r6.spatialReference, targetSpatialReference: o6 }), { valid: false, controlPoint: null });
  }
};
function T2(t3) {
  return null != t3?.sourcePoint && null != t3.mapPoint;
}
r([m2({ type: [q], json: { write: { allowNull: false, isRequired: true, target: { controlPoints: { type: [N], isRequired: true }, coefficients: { type: [Number], isRequired: true }, spatialReference: { type: f, isRequired: true } } } } })], O2.prototype, "controlPoints", void 0), r([o2("controlPoints")], O2.prototype, "readControlPoints", null), r([r2("controlPoints")], O2.prototype, "writeControlPoints", null), r([m2({ clonable: false })], O2.prototype, "coords", null), r([m2({ type: Number, nonNullable: true, json: { write: { isRequired: true } } })], O2.prototype, "height", void 0), r([m2({ readOnly: true })], O2.prototype, "inverseTransform", null), r([m2({ readOnly: true })], O2.prototype, "transform", null), r([m2({ type: Number, nonNullable: true, json: { write: { isRequired: true } } })], O2.prototype, "width", void 0), O2 = r([a("esri.layers.support.ControlPointsGeoreference")], O2);
var _4 = n5();
var M2 = n5();
var G = n5();
var I2 = n5();
var J = n5();
var L = n5();
var E = n5();
var U2 = n5();
var k3 = Math.PI / 2;
function z2(t3, o6, e4) {
  o5(t3, e4.sourcePoint.x, e4.sourcePoint.y), o5(o6, e4.mapPoint.x, e4.mapPoint.y);
}
function A2(t3, o6, e4) {
  return z2(_4, J, o6), z2(M2, L, e4), I(G, M2, _4, k3), I(I2, _4, M2, k3), I(E, L, J, -k3), I(U2, J, L, -k3), H2(t3, _4, M2, G, I2, J, L, E, U2);
}
function V3(t3, o6, e4, r6) {
  return z2(_4, J, o6), z2(M2, L, e4), z2(G, E, r6), _3(I2, _4, M2, 0.5), I(I2, G, I2, Math.PI), _3(U2, J, L, 0.5), I(U2, E, U2, Math.PI), H2(t3, _4, M2, G, I2, J, L, E, U2);
}
function B(t3, o6, e4, r6, n8) {
  return z2(_4, J, o6), z2(M2, L, e4), z2(G, E, r6), z2(I2, U2, n8), H2(t3, _4, M2, G, I2, J, L, E, U2);
}
var W = new Array(8).fill(0);
var D = new Array(8).fill(0);
function F(t3, o6, e4, r6, n8) {
  return t3[0] = o6[0], t3[1] = o6[1], t3[2] = e4[0], t3[3] = e4[1], t3[4] = r6[0], t3[5] = r6[1], t3[6] = n8[0], t3[7] = n8[1], t3;
}
function H2(t3, o6, e4, r6, n8, i3, l3, c5, a3) {
  return j2(t3, F(W, o6, e4, r6, n8), F(D, i3, l3, c5, a3));
}
function K(t3, o6, e4, r6) {
  const n8 = r4(0, e4), s6 = r4(0, 0), l3 = r4(o6, 0), c5 = r4(o6, e4);
  return p6(n8, n8, t3), p6(s6, s6, t3), p6(l3, l3, t3), p6(c5, c5, t3), new P({ rings: [[n8, s6, l3, c5, n8]], spatialReference: r6 });
}

// node_modules/@arcgis/core/layers/support/CornersGeoreference.js
var u2 = n5();
var y2 = class extends c4 {
  constructor(t3) {
    super(t3), this.bottomLeft = null, this.bottomRight = null, this.topLeft = null, this.topRight = null, this.type = "corners";
  }
  get coords() {
    let { topLeft: t3, topRight: o6, bottomLeft: e4, bottomRight: r6 } = this;
    if (null == t3 || null == o6 || null == e4 || null == r6) return null;
    const s6 = t3.spatialReference;
    return o6 = this.projectOrWarn(o6, s6), e4 = this.projectOrWarn(e4, s6), r6 = this.projectOrWarn(r6, s6), null == o6 || null == e4 || null == r6 ? null : new P({ rings: [[[e4.x, e4.y], [t3.x, t3.y], [o6.x, o6.y], [r6.x, r6.y], [e4.x, e4.y]]], spatialReference: s6 });
  }
  set coords(t3) {
    const { topLeft: o6 } = this;
    if (null == o6) return;
    const e4 = o6.spatialReference;
    if (null == (t3 = this.projectOrWarn(t3, e4))) return;
    const { rings: [[r6, s6, i3, l3]] } = t3;
    this.bottomLeft = new _2({ x: r6[0], y: r6[1], spatialReference: e4 }), this.topLeft = new _2({ x: s6[0], y: s6[1], spatialReference: e4 }), this.topRight = new _2({ x: i3[0], y: i3[1], spatialReference: e4 }), this.bottomRight = new _2({ x: l3[0], y: l3[1], spatialReference: e4 });
  }
  toSourceNormalized(t3) {
    const { topLeft: s6, topRight: i3, bottomRight: p8, bottomLeft: c5 } = this;
    if (null == t3 || null == s6 || null == i3 || null == p8 || null == c5) return null;
    const m4 = s6.spatialReference;
    t3 = t3.normalize();
    const f2 = X(t3, m4).geometry;
    if (null == f2) return null;
    o5(u2, f2.x, f2.y);
    const y3 = j2(e2(), [s6.x, s6.y, c5.x, c5.y, i3.x, i3.y, p8.x, p8.y], [0, 0, 0, 1, 1, 0, 1, 1]);
    return p6(u2, u2, y3), c2(u2[0], u2[1]);
  }
};
r([m2({ clonable: false })], y2.prototype, "coords", null), r([m2({ type: _2 })], y2.prototype, "bottomLeft", void 0), r([m2({ type: _2 })], y2.prototype, "bottomRight", void 0), r([m2({ type: _2 })], y2.prototype, "topLeft", void 0), r([m2({ type: _2 })], y2.prototype, "topRight", void 0), y2 = r([a("esri.layers.support.CornersGeoreference")], y2);
var h2 = y2;

// node_modules/@arcgis/core/layers/support/ExtentAndRotationGeoreference.js
var p7 = class extends c4 {
  constructor(t3) {
    super(t3), this.extent = null, this.rotation = 0, this.type = "extent-and-rotation";
  }
  get coords() {
    if (null == this.extent) return null;
    const { xmin: t3, ymin: e4, xmax: r6, ymax: o6, spatialReference: n8 } = this.extent;
    let s6;
    if (this.rotation) {
      const { x: n9, y: i3 } = this.extent.center, a3 = x2(n9, i3, this.rotation);
      s6 = [a3(t3, e4), a3(t3, o6), a3(r6, o6), a3(r6, e4)], s6.push(s6[0]);
    } else s6 = [[t3, e4], [t3, o6], [r6, o6], [r6, e4], [t3, e4]];
    return new P({ rings: [s6], spatialReference: n8 });
  }
  set coords(t3) {
    if (null == t3 || null == this.extent) return;
    const r6 = this.extent.spatialReference;
    if (t3 = this.projectOrWarn(t3, r6), null == t3?.extent) return;
    const { rings: [[o6, n8, s6]], extent: { center: { x: i3, y: c5 } } } = t3, l3 = M(Math.PI / 2 - Math.atan2(n8[1] - o6[1], n8[0] - o6[0])), m4 = x2(i3, c5, -l3), [p8, u6] = m4(o6[0], o6[1]), [f2, h4] = m4(s6[0], s6[1]);
    this.extent = new z({ xmin: p8, ymin: u6, xmax: f2, ymax: h4, spatialReference: r6 }), this.rotation = l3;
  }
  toSourceNormalized(t3) {
    const { extent: e4, rotation: n8 } = this;
    if (null == t3 || null == e4) return null;
    const { xmin: s6, ymin: i3, xmax: a3, ymax: c5, center: m4, spatialReference: p8 } = e4;
    t3 = t3.normalize();
    const u6 = X(t3, p8).geometry;
    if (null == u6) return null;
    let f2 = u6.x, h4 = u6.y;
    return n8 && ([f2, h4] = x2(m4.x, m4.y, -n8)(f2, h4)), c2(c(f2, s6, a3, 0, 1), c(h4, c5, i3, 0, 1));
  }
};
function x2(t3, e4, r6) {
  const o6 = u(r6), n8 = Math.cos(o6), s6 = Math.sin(o6);
  return (r7, o7) => [n8 * (r7 - t3) + s6 * (o7 - e4) + t3, n8 * (o7 - e4) - s6 * (r7 - t3) + e4];
}
r([m2({ clonable: false })], p7.prototype, "coords", null), r([m2({ type: z })], p7.prototype, "extent", void 0), r([m2({ type: Number })], p7.prototype, "rotation", void 0), p7 = r([a("esri.layers.support.ExtentAndRotationGeoreference")], p7);
var u3 = p7;

// node_modules/@arcgis/core/layers/support/mediaUtils.js
function u4(e4) {
  return "media" === e4?.type;
}
function P2(e4, o6) {
  const r6 = n(o6);
  return u4(e4) && !!e4.portalItem && null != r6 && r6 > e.PORTAL_ITEM;
}
function d2(t3, n8, o6) {
  if (!t3 || "control-points" === t3.type) return t3;
  const { coords: i3 } = t3;
  if (5 !== i3?.rings[0]?.length) return null;
  const [a3, c5, p8, l3] = i3.rings[0], { spatialReference: y3 } = i3;
  return new O2({ controlPoints: [{ mapPoint: new _2({ x: a3[0], y: a3[1], spatialReference: y3 }), sourcePoint: c2(0, o6) }, { mapPoint: new _2({ x: c5[0], y: c5[1], spatialReference: y3 }), sourcePoint: c2(0, 0) }, { mapPoint: new _2({ x: p8[0], y: p8[1], spatialReference: y3 }), sourcePoint: c2(n8, 0) }, { mapPoint: new _2({ x: l3[0], y: l3[1], spatialReference: y3 }), sourcePoint: c2(n8, o6) }], width: n8, height: o6 });
}
function x3(e4, t3, n8) {
  return { enabled: !P2(n8?.layer, n8?.origin), ignoreOrigin: true };
}
var w = { json: { name: "url", type: String, write: { overridePolicy: x3 } } };
var g = { readOnly: true, json: { read: false, write: { target: "mediaType", overridePolicy: x3 } } };
var h3 = { types: { key: "type", base: c4, typeMap: { "control-points": O2, corners: h2, "extent-and-rotation": u3 } }, json: { types: { key: "type", base: c4, typeMap: { "control-points": O2 } }, write: { overridePolicy: () => ({ enabled: true, ignoreOrigin: true }) } } };

// node_modules/@arcgis/core/layers/support/MediaElementBase.js
var u5 = class extends n4.NumericIdentifiableMixin(S(p2)) {
  constructor(e4) {
    super(e4), this.georeference = null, this.opacity = 1;
  }
  readGeoreference(e4) {
    return O2.fromJSON(e4);
  }
  writeGeoreference(e4, o6, t3, n8) {
    const i3 = n8?.resources?.pendingOperations, c5 = () => {
      const i4 = d2(this.georeference, this.contentWidth, this.contentHeight);
      if (i4) {
        if ("control-points" !== e4.type && i.getLogger(this).warn(`only georeference of type 'control-points' may be persisted. The georeference of type '${e4.type}' has been automatically converted.`), 4 !== i4.controlPoints?.length && n8?.messages) return void n8.messages.push(new s("property:unsupported", "only 'control-points' georeference with 4 control points may be persisted."));
        o6[t3] = i4.write({}, n8);
      }
    };
    if ("control-points" !== e4.type && !this.loaded && i3) return o6[t3] = {}, void i3.push(this.load().then(c5));
    c5();
  }
  get contentWidth() {
    return 0;
  }
  get contentHeight() {
    return 0;
  }
  toSource(e4) {
    const { georeference: r6, contentWidth: o6, contentHeight: t3 } = this;
    if (null == e4 || null == r6 || 0 === o6 || 0 === t3) return null;
    const s6 = r6.toSourceNormalized(e4);
    return null == s6 ? null : (s6.x *= o6, s6.y *= t3, s6);
  }
};
r([m2(h3)], u5.prototype, "georeference", void 0), r([o2("georeference")], u5.prototype, "readGeoreference", null), r([r2("georeference")], u5.prototype, "writeGeoreference", null), r([m2({ json: { read: false, write: false } })], u5.prototype, "opacity", void 0), u5 = r([a("esri.layers.support.MediaElementBase")], u5);

// node_modules/@arcgis/core/layers/support/ImageElement.js
var E2;
var _a;
var U3 = (_a = class extends u5 {
  constructor(t3) {
    super(t3), this.animationOptions = null, this.content = null, this.image = null, this.type = "image", this[E2] = true, this.image = null;
  }
  load() {
    const t3 = this.image;
    if ("string" == typeof t3) {
      const e4 = p4(t3).then(((t4) => {
        this._set("content", t4);
      }));
      this.addResolvingPromise(e4);
    } else if (t3 instanceof HTMLImageElement) {
      const e4 = t3.decode().then((() => {
        this._set("content", t3);
      }));
      this.addResolvingPromise(e4);
    } else t3 ? this._set("content", t3) : this.addResolvingPromise(Promise.reject(new s("image-element:invalid-image-type", "Invalid image type", { image: t3 })));
    return Promise.resolve(this);
  }
  get contentWidth() {
    return null == this.content ? 0 : this.content instanceof HTMLImageElement ? this.content.naturalWidth : this.content.width;
  }
  get contentHeight() {
    return null == this.content ? 0 : this.content instanceof HTMLImageElement ? this.content.naturalHeight : this.content.height;
  }
  readImage(t3, e4, r6) {
    return p(e4.url, r6);
  }
  writeImage(t3, e4, r6, o6) {
    if (null == t3) return;
    const n8 = o6?.portalItem, s6 = o6?.resources;
    if (!n8 || !s6) return void ("string" == typeof t3 && (e4[r6] = m(t3, o6)));
    const a3 = H3(t3) ? t3 : null;
    if (a3) {
      if (null == U(a3)) return void (e4[r6] = a3);
      const t4 = m(a3, { ...o6, verifyItemRelativeUrls: o6?.verifyItemRelativeUrls ? { writtenUrls: o6.verifyItemRelativeUrls.writtenUrls, rootPath: void 0 } : void 0 }, y.NO);
      if (n8 && t4 && !Y(t4)) return s6.toKeep.push({ resource: n8.resourceFromPath(t4), compress: false }), void (e4[r6] = t4);
    }
    e4[r6] = "<pending>", s6.pendingOperations.push(L2(t3).then(((t4) => {
      const o7 = P3(t4, n8);
      e4[r6] = o7.itemRelativeUrl, s6.toAdd.push({ resource: o7, content: { type: "blob", blob: t4 }, compress: false, finish: (t5) => {
        this.image = t5.url;
      } });
    })));
  }
}, E2 = n7, _a);
function H3(t3) {
  return "string" == typeof t3 && !tt(t3) && !Z(t3);
}
async function L2(t3) {
  if ("string" == typeof t3) {
    if (tt(t3)) return ut(t3);
    return (await H(t3, { responseType: "blob" })).data;
  }
  return new Promise(((e4) => M3(t3).toBlob(e4)));
}
function M3(t3) {
  if (t3 instanceof HTMLCanvasElement) return t3;
  const e4 = t3 instanceof HTMLImageElement ? t3.naturalWidth : t3.width, r6 = t3 instanceof HTMLImageElement ? t3.naturalHeight : t3.height, o6 = document.createElement("canvas"), i3 = o6.getContext("2d");
  return o6.width = e4, o6.height = r6, t3 instanceof HTMLImageElement ? i3.drawImage(t3, 0, 0, t3.width, t3.height) : t3 instanceof ImageData && i3.putImageData(t3, 0, 0), o6;
}
function P3(t3, e4) {
  const r6 = n2(), o6 = `${V("media", r6)}.${p5({ type: "blob", blob: t3 })}`;
  return e4.resourceFromPath(o6);
}
r([m2()], U3.prototype, "animationOptions", void 0), r([m2({ readOnly: true })], U3.prototype, "content", void 0), r([m2({ readOnly: true })], U3.prototype, "contentWidth", null), r([m2({ readOnly: true })], U3.prototype, "contentHeight", null), r([m2(w)], U3.prototype, "image", void 0), r([o2("image", ["url"])], U3.prototype, "readImage", null), r([r2("image")], U3.prototype, "writeImage", null), r([m2(g)], U3.prototype, "type", void 0), U3 = r([a("esri.layers.support.ImageElement")], U3);

// node_modules/@arcgis/core/layers/support/VideoElement.js
var b2;
var w2 = Symbol("canplay");
var _a2;
var V4 = (_a2 = class extends u5 {
  constructor(e4) {
    super(e4), this.autoplay = true, this.content = null, this.type = "video", this[b2] = true;
  }
  load() {
    const e4 = this.video;
    return "string" == typeof e4 ? this.addResolvingPromise(this._preProcessVideoUrl(e4).then((async (e5) => {
      const t3 = document.createElement("video");
      return t3.src = t.sanitizeUrl(_(e5)), t3.crossOrigin = "anonymous", t3.autoplay = this.autoplay, t3.muted = true, t3.loop = true, t3.playsInline = true, this._loadVideo(t3).then((() => {
        this._set("content", t3);
      }));
    }))) : e4 instanceof HTMLVideoElement ? this.addResolvingPromise(this._loadVideo(e4).then((() => {
      this._set("content", e4);
    }))) : this.addResolvingPromise(Promise.reject(new s("video-element:invalid-video-type", "Invalid video type", { video: e4 }))), Promise.resolve(this);
  }
  get contentWidth() {
    return this.content?.videoWidth ?? 0;
  }
  get contentHeight() {
    return this.content?.videoHeight ?? 0;
  }
  get currentTime() {
    return this.content?.currentTime;
  }
  set currentTime(e4) {
    if (!this.content) return;
    const t3 = r3(e4, 0, this.content.duration);
    "fastSeek" in this.content ? this.content.fastSeek(t3) : this.content.currentTime = t3, this.content.play().then((() => {
      this.content?.pause();
    })).catch((() => {
    }));
  }
  get duration() {
    return this.content?.duration;
  }
  set video(e4) {
    "not-loaded" === this.loadStatus ? this._set("video", e4) : i.getLogger(this).error("#video", "video cannot be changed after the element is loaded.");
  }
  writeVideo(e4, t3, r6, s6) {
    if (!e4) return void (s6?.messages && s6.messages.push(new s("video-element:unsupported-video", "video source is missing")));
    const i3 = _5(e4) ? e4 : null;
    if (!i3) return void (s6?.messages && s6.messages.push(new s("video-element:unsupported-video", "video source must be an absolute url")));
    !Y(i3) && s6?.blockedRelativeUrls && s6.blockedRelativeUrls.push(i3);
    const c5 = _(i3);
    !U(c5) ? t3[r6] = c5 : s6?.messages && s6.messages.push(new s("video-element:unsupported-video", "video source cannot be an item resource"));
  }
  async _preProcessVideoUrl(e4) {
    if (T(e4)) return k(e4);
    try {
      return await H(e4, { method: "head" }), e4;
    } catch {
      try {
        return k(e4, true);
      } catch {
        return e4;
      }
    }
  }
  async _loadVideo(e4) {
    "anonymous" !== e4.crossOrigin && (e4.crossOrigin = "anonymous", Z(e4.src) || (e4.src = e4.src));
    try {
      await r5(e4, ((e5) => this.addHandles(e5, w2))), this.autoplay && await e4.play().catch(((e5) => {
        throw console.error(e5), e5;
      }));
    } finally {
      this.removeHandles(w2);
    }
  }
}, b2 = e3, _a2);
function _5(e4) {
  return "string" == typeof e4 && !tt(e4) && !Z(e4);
}
r([m2()], V4.prototype, "autoplay", void 0), r([m2({ readOnly: true })], V4.prototype, "content", void 0), r([m2({ readOnly: true })], V4.prototype, "contentWidth", null), r([m2({ readOnly: true })], V4.prototype, "contentHeight", null), r([m2({ type: Number })], V4.prototype, "currentTime", null), r([m2({ type: Number })], V4.prototype, "duration", null), r([m2(w)], V4.prototype, "video", null), r([r2("video")], V4.prototype, "writeVideo", null), r([m2(g)], V4.prototype, "type", void 0), V4 = r([a("esri.layers.support.VideoElement")], V4);

// node_modules/@arcgis/core/layers/support/LocalMediaElementSource.js
var w3 = { key: "type", defaultKeyValue: "image", base: u5, typeMap: { image: U3, video: V4 } };
var M4 = V2.ofType(w3);
var I3 = class extends p2.LoadableMixin(m3.EsriPromiseMixin(o.EventedAccessor)) {
  constructor(e4) {
    super(e4), this._index = new o4(), this._elementViewsMap = /* @__PURE__ */ new Map(), this._elementsIndexes = /* @__PURE__ */ new Map(), this._elementsChangedHandler = (e5) => {
      for (const s6 of e5.removed) {
        const e6 = this._elementViewsMap.get(s6);
        this._elementViewsMap.delete(s6), this._index.delete(e6), this.removeHandles(e6), e6.destroy(), this.notifyChange("fullExtent");
      }
      const { spatialReference: t3 } = this;
      for (const s6 of e5.added) {
        if (this._elementViewsMap.get(s6)) continue;
        const e6 = new i2({ spatialReference: t3, element: s6 });
        this._elementViewsMap.set(s6, e6);
        const r6 = l((() => e6.coords), (() => this._updateIndexForElement(e6, false)));
        this._updateIndexForElement(e6, true), this.addHandles(r6, e6);
      }
      this._elementsIndexes.clear(), this.elements.forEach(((e6, t4) => this._elementsIndexes.set(e6, t4))), this.emit("refresh");
    }, this.elements = new M4();
  }
  async load(e4) {
    if (s2(e4), !this.spatialReference) {
      const e5 = this.elements.find(((e6) => null != e6.georeference?.coords));
      this._set("spatialReference", e5 ? e5.georeference.coords.spatialReference : f.WGS84);
    }
    return this._elementsChangedHandler({ added: this.elements.items, removed: [] }), this.addHandles(this.elements.on("change", this._elementsChangedHandler)), this;
  }
  destroy() {
    this._index.clear(), this._elementViewsMap.clear(), this._elementsIndexes.clear();
  }
  set elements(e4) {
    this._set("elements", n3(e4, this._get("elements"), M4));
  }
  get fullExtent() {
    if ("not-loaded" === this.loadStatus) return null;
    const e4 = this._index.fullBounds;
    return null == e4 ? null : new z({ xmin: e4[0], ymin: e4[1], xmax: e4[2], ymax: e4[3], spatialReference: this.spatialReference });
  }
  set spatialReference(e4) {
    "not-loaded" === this.loadStatus ? this._set("spatialReference", e4) : i.getLogger(this).error("#spatialReference", "spatialReference cannot be changed after the source is loaded.");
  }
  async queryElements(e4, t3) {
    await this.load(), await Q(e4.spatialReference, this.spatialReference, null, t3);
    const s6 = s4(e4.spatialReference, this.spatialReference) ? e4 : O(e4, this.spatialReference);
    if (!s6) return [];
    const r6 = s6.normalize(), o6 = [];
    for (const n8 of r6) this._index.forEachInBounds(o3(n8), (({ normalizedCoords: e5, element: t4 }) => {
      null != e5 && x(n8, e5) && o6.push(t4);
    }));
    return o6.sort(((e5, t4) => this._elementsIndexes.get(e5) - this._elementsIndexes.get(t4))), o6;
  }
  hasElement(e4) {
    return this.elements.includes(e4);
  }
  _updateIndexForElement(e4, t3) {
    const s6 = e4.normalizedBounds, r6 = this._index.has(e4), o6 = null != s6;
    this._index.delete(e4), o6 && this._index.set(e4, s6), this.notifyChange("fullExtent"), t3 || (r6 !== o6 ? this.emit("refresh") : this.emit("change", { element: e4.element }));
  }
};
r([m2()], I3.prototype, "elements", null), r([m2({ readOnly: true })], I3.prototype, "fullExtent", null), r([m2()], I3.prototype, "spatialReference", null), I3 = r([a("esri.layers.support.LocalMediaElementSource")], I3);

// node_modules/@arcgis/core/layers/MediaLayer.js
var b3 = class extends p3(t2(b(j(S(h))))) {
  constructor(e4) {
    super(e4), this.effectiveSource = null, this.georeference = null, this.copyright = null, this.operationalLayerType = "MediaLayer", this.spatialReference = null, this.type = "media", this._debouncedSaveOperations = k2((async (e5, r6, o6) => {
      const { save: t3, saveAs: s6 } = await import("./mediaLayerUtils-ZEJUQ5FN.js");
      switch (e5) {
        case A.SAVE:
          return t3(this, r6);
        case A.SAVE_AS:
          return s6(this, o6, r6);
      }
    })), this.source = new I3();
  }
  load(e4) {
    return this.addResolvingPromise(this._doLoad(e4)), Promise.resolve(this);
  }
  async _doLoad(e4) {
    await this.loadFromPortal({ supportedTypes: ["Media Layer"] }, e4);
    let t3 = this.source;
    if (!t3) throw new s("media-layer:source-missing", "Set 'MediaLayer.source' before loading the layer.");
    const s6 = this._getSourceOverride(t3, this.georeference);
    s6 && (this.setAtOrigin("source", s6, "web-map"), this.setAtOrigin("source", s6, "web-scene"), t3 = s6);
    const i3 = c3(t3) ? new I3({ elements: new V2([t3]) }) : t3;
    this._set("effectiveSource", i3), this.spatialReference && (i3.spatialReference = this.spatialReference), await i3.load(e4), this.spatialReference = i3.spatialReference;
  }
  destroy() {
    this.effectiveSource?.destroy(), this.effectiveSource !== this.source && this.source?.destroy();
  }
  readGeoreference(e4, r6) {
    return e4 && "itemId" in r6 && r6.itemId ? e4 : void 0;
  }
  get fullExtent() {
    return this.loaded ? this.effectiveSource.fullExtent : null;
  }
  get source() {
    return this._get("source");
  }
  set source(e4) {
    "loaded" !== this.loadStatus && "failed" !== this.loadStatus ? this._set("source", e4) : i.getLogger(this).error("#source", "source cannot be changed after the layer is loaded.");
  }
  castSource(e4) {
    return e4 ? Array.isArray(e4) ? new I3({ elements: new V2(e4) }) : e4 instanceof V2 ? new I3({ elements: e4 }) : e4 : null;
  }
  readSource(e4, r6, o6) {
    if ("itemId" in r6 && r6.itemId) return;
    const t3 = this._createSource(r6);
    return t3?.read(r6, o6), t3;
  }
  writeSource(e4, r6, t3, s6) {
    if (e4 && e4 instanceof I3) {
      const r7 = e4.elements.length;
      if (1 !== r7) return void (s6?.messages && s6.messages.push(new s("media-layer:unsupported-source", `local media element source can only be persisted if it contains exactly one ImageElement, but it has ${r7}.`)));
      e4 = e4.elements.at(0);
    }
    c3(e4) ? e4.write(r6, s6) : s6?.messages && (e4 ? s6.messages.push(new s("media-layer:unsupported-source", "only media elements of type 'ImageElement' or 'VideoElement' can be persisted")) : s6.messages.push(new s("media-layer:unsupported-source", "the media layer is missing a source")));
  }
  async save(e4) {
    return this._debouncedSaveOperations(A.SAVE, e4);
  }
  async saveAs(e4, r6) {
    return this._debouncedSaveOperations(A.SAVE_AS, r6, e4);
  }
  _createSource(e4) {
    if ("mediaType" in e4) switch (e4.mediaType) {
      case "image":
        return new U3();
      case "video":
        return new V4();
    }
    return null;
  }
  _getSourceOverride(e4, r6) {
    if (c3(e4) && this.originIdOf("source") === e.PORTAL_ITEM && r6 && (this.originIdOf("georeference") === e.WEB_MAP || this.originIdOf("georeference") === e.WEB_SCENE)) {
      const o6 = e4.toJSON(), t3 = this._createSource(o6);
      return t3.read({ ...o6 }, { origin: "portal-item" }), t3.read({ georeference: r6 }, { origin: "web-map" }), t3.read({ georeference: r6 }, { origin: "web-scene" }), t3;
    }
    return null;
  }
};
r([m2({ readOnly: true })], b3.prototype, "effectiveSource", void 0), r([m2({ readOnly: true, json: { read: false, write: false, origins: { "web-document": { read: true } } } })], b3.prototype, "georeference", void 0), r([o2("web-document", "georeference")], b3.prototype, "readGeoreference", null), r([m2({ type: String })], b3.prototype, "copyright", void 0), r([m2({ readOnly: true })], b3.prototype, "fullExtent", null), r([m2({ type: ["MediaLayer"] })], b3.prototype, "operationalLayerType", void 0), r([m2({ type: ["show", "hide"] })], b3.prototype, "listMode", void 0), r([m2({ nonNullable: true, json: { write: { enabled: true, allowNull: false, target: { url: { type: String }, mediaType: { type: ["image", "video"] }, georeference: { type: O2 } }, overridePolicy(e4, r6, o6) {
  return { enabled: true, allowNull: false, ignoreOrigin: P2(this, o6?.origin) && c3(e4) && !!e4.georeference && e4.originIdOf("georeference") > e.PORTAL_ITEM };
} } } })], b3.prototype, "source", null), r([s3("source")], b3.prototype, "castSource", null), r([o2("source", ["url"])], b3.prototype, "readSource", null), r([r2("source")], b3.prototype, "writeSource", null), r([m2()], b3.prototype, "spatialReference", void 0), r([m2({ readOnly: true })], b3.prototype, "type", void 0), b3 = r([a("esri.layers.MediaLayer")], b3);
var E3 = b3;
export {
  E3 as default
};
//# sourceMappingURL=MediaLayer-YNJGQGDK.js.map
