import {
  h as h4
} from "./chunk-TJMKM7NV.js";
import {
  j as j2,
  l as l5
} from "./chunk-4R72C3PD.js";
import {
  a as a2,
  t as t3
} from "./chunk-DPYNRAFQ.js";
import {
  e as e5,
  i as i3,
  p
} from "./chunk-3DI2SPTI.js";
import {
  i as i4
} from "./chunk-XMWML5IB.js";
import {
  d as d3
} from "./chunk-4EILUP3Q.js";
import {
  i as i2
} from "./chunk-UKIQRUDT.js";
import {
  E2 as E,
  P as P2,
  e3 as e4
} from "./chunk-OGSQVCBG.js";
import {
  R as R2
} from "./chunk-UIFFN73A.js";
import {
  C2 as C,
  F,
  H2 as H,
  R,
  r as r2
} from "./chunk-LAYRNGXW.js";
import {
  l2 as l4
} from "./chunk-BCSNVZ5T.js";
import "./chunk-PXLVEE2R.js";
import "./chunk-YKE7YQGP.js";
import "./chunk-CRVQAW6F.js";
import "./chunk-CFDUDTHD.js";
import "./chunk-OTD22OSX.js";
import "./chunk-AP7A45V5.js";
import "./chunk-IE6QJMDY.js";
import "./chunk-37USNU2Q.js";
import "./chunk-YERTKO74.js";
import "./chunk-SN2MX6RH.js";
import {
  x
} from "./chunk-2LM2WT2P.js";
import "./chunk-MSLVFZID.js";
import {
  h as h3
} from "./chunk-OG7E7GTZ.js";
import "./chunk-PMQTAUGI.js";
import "./chunk-LRGEISLI.js";
import "./chunk-R62BLGYS.js";
import {
  c as c3
} from "./chunk-TXQFMFGJ.js";
import "./chunk-WHNSSW5C.js";
import "./chunk-ZYWMFOAJ.js";
import "./chunk-IS6QSGYZ.js";
import "./chunk-RHVCSVQD.js";
import "./chunk-DPEZN2CZ.js";
import "./chunk-6T6LJGGM.js";
import "./chunk-V62WAS25.js";
import "./chunk-5YPA3JNT.js";
import "./chunk-CPLLBL2J.js";
import "./chunk-HPADPQJ7.js";
import "./chunk-53T2IMYE.js";
import "./chunk-T2JYPYET.js";
import "./chunk-IUHXT4HG.js";
import "./chunk-QYV34ZYV.js";
import "./chunk-4QM2FHGA.js";
import "./chunk-WE43YRN7.js";
import "./chunk-Q4LJGDN3.js";
import "./chunk-3JKWT76Y.js";
import "./chunk-LOLNWH3R.js";
import "./chunk-RFSLNSEE.js";
import {
  c as c4
} from "./chunk-FBGZNF2J.js";
import {
  _ as _2
} from "./chunk-VJKKOB5K.js";
import "./chunk-3ZX4Y274.js";
import "./chunk-746KDGCX.js";
import "./chunk-6BXYK2GC.js";
import "./chunk-ANUSP5DZ.js";
import "./chunk-QZBNKN5E.js";
import "./chunk-YGH6TKDR.js";
import "./chunk-QNRDEVXA.js";
import {
  l as l3
} from "./chunk-BDYPDR3Y.js";
import {
  h as h2
} from "./chunk-FPALEK52.js";
import "./chunk-BNQMKYX6.js";
import "./chunk-B6C2GOG6.js";
import "./chunk-K3VYMAVM.js";
import "./chunk-3SBQ4BRR.js";
import "./chunk-QEBLKRSV.js";
import "./chunk-3BRAWT3U.js";
import "./chunk-FNXTTV6Z.js";
import "./chunk-P5DG4SNT.js";
import "./chunk-ELYKVFFC.js";
import "./chunk-3FFCJ4YU.js";
import "./chunk-FV6ZNHFI.js";
import "./chunk-B5YXBMAF.js";
import "./chunk-SZ4I37ZN.js";
import "./chunk-FI3Y4ZNX.js";
import "./chunk-M6LH7ANK.js";
import "./chunk-FTX3VFJX.js";
import "./chunk-PHSQVJNW.js";
import "./chunk-KFNWBWN4.js";
import "./chunk-S7GLMIAQ.js";
import "./chunk-AACFCXAP.js";
import {
  d as d2
} from "./chunk-VCKINPGN.js";
import "./chunk-SDCRJECE.js";
import "./chunk-4G42CJX6.js";
import "./chunk-NEI5HAVK.js";
import "./chunk-D7G7U7XX.js";
import "./chunk-2CS746FZ.js";
import "./chunk-UET4BL4J.js";
import "./chunk-YMT7TAQQ.js";
import "./chunk-RZGBA4KS.js";
import "./chunk-FSYN2HHU.js";
import "./chunk-7I4TWCTW.js";
import "./chunk-SCMB64VM.js";
import {
  u as u3
} from "./chunk-MBJ7YPSH.js";
import "./chunk-D34PNYRG.js";
import "./chunk-APMQAZ5Z.js";
import "./chunk-LNLFY27J.js";
import "./chunk-P4O4YCLI.js";
import "./chunk-MSSQA3XK.js";
import "./chunk-R7YP6EQJ.js";
import "./chunk-SPM2JNCJ.js";
import "./chunk-CHGKJUJ3.js";
import "./chunk-3YBQQHIP.js";
import "./chunk-OJQCHQYS.js";
import "./chunk-N3W3EVP3.js";
import "./chunk-SIRTOV2N.js";
import "./chunk-VQWEDC6T.js";
import "./chunk-K55CXVYD.js";
import "./chunk-M4XVX74D.js";
import "./chunk-UZ3YWBWC.js";
import "./chunk-2EOHKZLO.js";
import "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-LQQCPLIT.js";
import "./chunk-4O46EK5T.js";
import "./chunk-A7I2KMJU.js";
import "./chunk-BPI4BR4E.js";
import "./chunk-3L5JZOMH.js";
import "./chunk-N77BULFI.js";
import "./chunk-NEIJCC5O.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-A6R2FXH6.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-4KZLIAP7.js";
import "./chunk-62NATJWT.js";
import "./chunk-FOPBVVXE.js";
import "./chunk-INI6MHIQ.js";
import "./chunk-QUZZIDFR.js";
import "./chunk-CBCDVQSA.js";
import "./chunk-RKF6WUZT.js";
import {
  y
} from "./chunk-RMRI4NYS.js";
import {
  c as c2,
  e as e3,
  m as m2
} from "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-BLBN3L5Q.js";
import "./chunk-XNUSHDFN.js";
import {
  c
} from "./chunk-4AKMPOG7.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-ZJQPHR3K.js";
import {
  g,
  l as l2
} from "./chunk-R4XAU2TW.js";
import {
  d
} from "./chunk-YVMULGDJ.js";
import {
  V
} from "./chunk-74GULGYB.js";
import {
  P,
  U,
  f,
  h,
  j,
  l,
  w
} from "./chunk-HYAO4PVV.js";
import "./chunk-SRNKPAJX.js";
import {
  o
} from "./chunk-VNQUG2TO.js";
import "./chunk-MOMLPET6.js";
import "./chunk-3QHX4R4B.js";
import "./chunk-ORMKIVR7.js";
import "./chunk-TOCH3L2K.js";
import "./chunk-EULNFFHG.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-CBXZL53X.js";
import "./chunk-LPCUYJ2B.js";
import {
  _
} from "./chunk-SMO33YG7.js";
import "./chunk-LCBAL6ER.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import "./chunk-67AKDROO.js";
import "./chunk-CM3TIXEV.js";
import "./chunk-POWGZO3T.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-NJZD7WM5.js";
import "./chunk-CL7VLXUR.js";
import "./chunk-FCX4ZA3Z.js";
import {
  b,
  m2 as m,
  t4 as t2
} from "./chunk-2ZPU5IZX.js";
import {
  a2 as a
} from "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import {
  u
} from "./chunk-JNYZ3I5R.js";
import {
  e,
  e2,
  n2 as n,
  s as s2,
  t,
  u2
} from "./chunk-N626Y23H.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/draw/support/ConnectedReshapeManager.js
var _3;
!(function(e6) {
  e6[e6.FeatureMove = 0] = "FeatureMove", e6[e6.VertexMove = 1] = "VertexMove";
})(_3 || (_3 = {}));
var w2 = () => i.getLogger("esri.views.draw.support.ConnectedReshapeManager");
var G = Symbol();
var L = class extends b {
  constructor(e6) {
    super(e6), this.activeOperationType = null, this.providerFactories = [], this.view = null, this._activeProviders = /* @__PURE__ */ new Set(), this._graphics = /* @__PURE__ */ new Map(), this._modifiedFeatures = /* @__PURE__ */ new Map(), this._modifiedGraphicsLayer = new c3({ listMode: "hide", internal: true, title: "Connected Reshape Modified Graphics (Internal)" }), this._pendingGraphicsLayer = new c3({ listMode: "hide", internal: true, title: "Connected Reshape Pending Graphics (Internal)" }), this._pendingFeatures = /* @__PURE__ */ new Map(), this._updatingHandles = new h2();
  }
  initialize() {
    this.view.map.addMany([this._modifiedGraphicsLayer, this._pendingGraphicsLayer]);
  }
  destroy() {
    this.view.destroyed || this.view.map.removeMany([this._modifiedGraphicsLayer, this._pendingGraphicsLayer]), this._modifiedGraphicsLayer.destroy(), this._pendingGraphicsLayer.destroy(), this._updatingHandles.destroy();
  }
  get updating() {
    return this._updatingHandles.updating || Array.from(this._activeProviders).some(((e6) => e6.updating));
  }
  startFeatureMove(e6) {
    this.activeOperationType = _3.FeatureMove, this._activeProviders.clear();
    for (const i6 of this.providerFactories) t2(this._activeProviders, i6.getFeatureReshapeProvider(e6));
  }
  startVertexMove(e6, i6) {
    this.activeOperationType = _3.VertexMove, this._activeProviders.clear();
    for (const t4 of this.providerFactories) t2(this._activeProviders, t4.getVertexReshapeProvider(e6, i6));
  }
  finish() {
    this.activeOperationType = null, this._activeProviders.clear();
    for (const [e6, i6] of this._pendingFeatures) {
      this._pendingFeatures.delete(e6), this._modifiedFeatures.set(e6, i6);
      const t4 = this._graphics.get(e6);
      t4 && (this._modifiedGraphicsLayer.add(t4), this._pendingGraphicsLayer.remove(t4));
    }
  }
  translate(e6, i6, t4 = 0) {
    if (null === this.activeOperationType) return;
    const r3 = P3(e6), s3 = P3(i6), a3 = P3(t4);
    for (const o2 of this._activeProviders) {
      const e7 = o2.translate(r3, s3, a3);
      this._update(e7);
    }
  }
  async _initializeGraphic(e6, i6) {
    e6.symbol ??= await this._updatingHandles.addPromise(x(e6, { scale: this.view.scale, useSourceLayer: true })), this._pendingFeatures.has(i6.uniqueId) ? this._pendingGraphicsLayer.add(e6) : this._modifiedFeatures.has(i6.uniqueId) && this._modifiedGraphicsLayer.add(e6), this.addHandles(await F2(i6.originalGraphic, e6, this.view), G);
  }
  _update(e6) {
    for (const i6 of e6) {
      const e7 = this._modifiedFeatures.delete(i6.uniqueId);
      this._pendingFeatures.set(i6.uniqueId, i6);
      const t4 = u(this._graphics, i6.uniqueId, (() => {
        const e8 = i6.graphic.cloneShallow();
        return this._initializeGraphic(e8, i6), e8;
      }));
      t4.geometry = i6.graphic.geometry, e7 && (this._modifiedGraphicsLayer.remove(t4), this._pendingGraphicsLayer.add(t4));
    }
  }
  get test() {
    return { activeProviders: this._activeProviders, modifiedFeatures: this._modifiedFeatures, modifiedGraphicsLayer: this._modifiedGraphicsLayer, pendingFeatures: this._pendingFeatures, pendingGraphicsLayer: this._pendingGraphicsLayer };
  }
};
async function F2(e6, i6, a3) {
  const o2 = e6.sourceLayer, d5 = e6.getObjectId();
  if (null == d5) return w2().error("editing:cannot-hide-graphic", "Unable to hide original graphic because it has no objectId."), e();
  let c5 = null;
  function h6(e7) {
    c5?.abort(), c5 = d((async (i7) => {
      const t4 = await b2(a3, o2);
      s2(i7), t4 && t4.setVisibility?.(d5, e7);
    }));
  }
  return await M(a3, i6), h6(false), t([j3(a3, i6, ((e7) => h6(!e7))), e((async () => {
    h6(true);
    const e7 = await b2(a3, o2);
    await j((() => !e7?.updating));
  }))]);
}
function j3(e6, i6, t4) {
  if ("3d" === e6.type) {
    const r3 = new e5({ graphic: i6 });
    return t([e6.trackGraphicState(r3), l((() => r3.displaying), t4)]);
  }
  return l((() => i6.visible), t4);
}
async function M(e6, i6) {
  if ("3d" === e6.type) {
    const t4 = new e5({ graphic: i6 }), r3 = e6.trackGraphicState(t4);
    await j((() => t4.displaying || t4.error)), r3.remove();
  } else await j((() => i6.visible));
}
async function b2(e6, i6) {
  const t4 = g(i6) || l2(i6) ? i6.parent : i6;
  return t4 ? e6.whenLayerView(t4) : null;
}
function P3(e6) {
  return isNaN(e6) ? 0 : e6;
}
r([m()], L.prototype, "activeOperationType", void 0), r([m()], L.prototype, "providerFactories", void 0), r([m()], L.prototype, "updating", null), r([m({ constructOnly: true })], L.prototype, "view", void 0), L = r([a("esri.views.draw.support.ConnectedReshapeManager")], L);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/TranslateVertexTooltipInfo.js
var i5 = class extends r2 {
  constructor(t4) {
    super(t4), this.type = "translate-vertex", this.distance = h3, this.elevation = null, this.area = null, this.totalLength = null;
  }
  clear() {
    this.distance = h3, this.elevation = null, this.area = null, this.totalLength = null;
  }
};
r([m()], i5.prototype, "type", void 0), r([m()], i5.prototype, "distance", void 0), r([m()], i5.prototype, "elevation", void 0), r([m()], i5.prototype, "area", void 0), r([m()], i5.prototype, "totalLength", void 0), i5 = r([a("esri.views.interactive.tooltip.infos.TranslateVertexTooltipInfo")], i5);

// node_modules/@arcgis/core/views/draw/support/reshapeTooltipUtils.js
function y2(t4) {
  const e6 = { sketchOptions: t4, viewType: "2d" };
  return { movePoint: new i3(e6), selectedVertex: new p(e6), translateGraphic: new i4(e6), translateVertices: new i5(e6) };
}
function v(e6, r3) {
  function a3() {
    const t4 = r3(), e7 = t4.sketchOptions.tooltips.effectiveEnabled ? t4.activeTooltipInfo : null;
    return { ...t4, activeTooltipInfo: e7 };
  }
  let s3 = false;
  function l6(t4) {
    s3 || (s3 = true, t4(), s3 = false);
  }
  return t([l((() => {
    const t4 = a3();
    return { context: t4, geometry: t4.graphic?.geometry, vertexGeometry: t4.selectedVertex?.geometry };
  }), (({ context: t4 }) => {
    l6((() => {
      g2(t4), e6.info = t4.activeTooltipInfo;
    }));
  }), w), l((() => {
    const t4 = a3(), { activeTooltipInfo: e7 } = t4;
    if (e7 && "key" in e7) return { context: t4, key: e7.key };
  }), ((t4, e7) => {
    t4 && e7 && t4.key !== e7.key && l6((() => T(t4.context)));
  }), U), C(e6, { onBeforePaste: () => {
    s3 = true;
  }, onAfterPaste: () => {
    T(a3()), s3 = false;
  } })]);
}
function g2(t4) {
  const e6 = t4.activeTooltipInfo;
  if (e6) {
    switch (e6?.type) {
      case "move-point":
        return h5(e6, t4);
      case "selected-vertex":
        return d4(e6, t4);
    }
    e6.sketchOptions = t4.sketchOptions;
  }
}
function h5(t4, { graphic: e6 }) {
  x2(t4, e6, e6?.geometry);
}
function d4(t4, { graphic: e6, selectedVertex: o2, automaticAreaMeasurementUtils: n2, automaticLengthMeasurementUtils: i6 }) {
  x2(t4, e6, o2?.geometry);
  const r3 = e6?.geometry;
  switch (r3?.type) {
    case "polygon":
      t4.geometryType = "polygon", t4.totalLength.visible = false, t4.area.actual = n2.autoArea2D(r3);
      break;
    case "polyline":
      t4.geometryType = "polyline", t4.totalLength.actual = i6.autoLength2D(r3), t4.area.visible = false;
  }
}
function x2(t4, e6, o2) {
  e6 && "point" === o2?.type && (t4.setLocationFromPoint(o2), t4.elevation.actual = R2(o2), t4.elevation.visible = !!e6.geometry?.hasZ, t4.elevation.readOnly = false, t4.elevation.showAsZ = true);
}
function T(t4) {
  function e6(e7, o3) {
    const n3 = o3?.geometry;
    if (!n3 || "point" !== n3.type) return;
    const { dx: i7, dy: r3, dz: c5 } = F(e7, n3);
    if (0 === i7 && 0 === r3 && 0 === c5) return;
    const { x: l6, y: p2, z: m3, m: u4, spatialReference: f2 } = n3, y3 = new _({ x: l6 + i7, y: p2 + r3, z: null != m3 ? m3 + c5 : void 0, m: u4, spatialReference: f2 });
    t4.updateGeometry(o3, y3, n3, i7, r3);
  }
  const { activeTooltipInfo: o2, graphic: n2, selectedVertex: i6 } = t4;
  switch (o2?.type) {
    case "move-point":
      return e6(o2, n2);
    case "selected-vertex":
      return e6(o2, i6);
  }
}
function j4(t4, e6, o2, n2) {
  t4.clear(), U2(t4, e6, n2, o2);
}
function w3(t4, e6, o2, n2, i6) {
  t4.clear();
  const { automaticAreaMeasurementUtils: r3, automaticLengthMeasurementUtils: a3 } = n2;
  "polygon" === o2?.type ? t4.area = r3.autoArea2D(o2) : "polyline" === o2?.type && (t4.totalLength = a3.autoLength2D(o2)), U2(t4, e6, i6, n2);
}
function U2(t4, o2, n2, { automaticLengthMeasurementUtils: i6 }) {
  if (!n2) return;
  const { x: a3, y: c5 } = n2.origin, s3 = o2.toMap(n2), l6 = o2.toMap(c(a3, c5)), p2 = i6.autoDistanceBetweenPoints2D(l6, s3);
  t4.distance = null != p2 ? p2 : h3;
}

// node_modules/@arcgis/core/views/draw/support/Reshape.js
var X = class {
  constructor(e6, t4, i6) {
    this.graphic = e6, this.mover = t4, this.selected = i6, this.type = "reshape-start";
  }
};
var Y = class {
  constructor(e6, t4, i6) {
    this.graphic = e6, this.mover = t4, this.selected = i6, this.type = "reshape";
  }
};
var K = class {
  constructor(e6, t4, i6) {
    this.graphic = e6, this.mover = t4, this.selected = i6, this.type = "reshape-stop";
  }
};
var q = class {
  constructor(e6, t4, i6) {
    this.mover = e6, this.dx = t4, this.dy = i6, this.type = "move-start";
  }
};
var B = class {
  constructor(e6, t4, i6) {
    this.mover = e6, this.dx = t4, this.dy = i6, this.type = "move";
  }
};
var J = class {
  constructor(e6, t4, i6) {
    this.mover = e6, this.dx = t4, this.dy = i6, this.type = "move-stop";
  }
};
var Q = class {
  constructor(e6) {
    this.added = e6, this.type = "vertex-select";
  }
};
var W = class {
  constructor(e6) {
    this.removed = e6, this.type = "vertex-deselect";
  }
};
var $ = class {
  constructor(e6, t4, i6, s3) {
    this.added = e6, this.graphic = t4, this.oldGraphic = i6, this.vertices = s3, this.type = "vertex-add";
  }
};
var ee = class {
  constructor(e6, t4, i6, s3) {
    this.removed = e6, this.graphic = t4, this.oldGraphic = i6, this.vertices = s3, this.type = "vertex-remove";
  }
};
var te = h4.reshapeGraphics;
var ie = { vertices: { default: new u3({ style: "circle", size: te.vertex.size, color: te.vertex.color, outline: { color: te.vertex.outlineColor, width: 1 } }), hover: new u3({ style: "circle", size: te.vertex.hoverSize, color: te.vertex.hoverColor, outline: { color: te.vertex.hoverOutlineColor, width: 1 } }), selected: new u3({ style: "circle", size: te.selected.size, color: te.selected.color, outline: { color: te.selected.outlineColor, width: 1 } }) }, midpoints: { default: new u3({ style: "circle", size: te.midpoint.size, color: te.midpoint.color, outline: { color: te.midpoint.outlineColor, width: 1 } }), hover: new u3({ style: "circle", size: te.midpoint.size, color: te.midpoint.color, outline: { color: te.midpoint.outlineColor, width: 1 } }) } };
var se = class extends o.EventedAccessor {
  constructor(e6) {
    super(e6), this._updateHandlesOnExternalGeometryChange = null, this._activeOperationInfo = null, this._connectedReshapeManager = null, this._editGeometryOperations = null, this._graphicAttributes = { esriSketchTool: "box" }, this._mover = null, this._snappingContext = null, this._snappingGraphicsLayer = null, this._hoverGraphic = null, this._snappingTask = null, this._stagedVertex = null, this.tooltip = null, this.activeTooltipInfo = null, this.callbacks = { onReshapeStart() {
    }, onReshape() {
    }, onReshapeStop() {
    }, onMoveStart() {
    }, onMove() {
    }, onMoveStop() {
    }, onGraphicClick() {
    } }, this.connectedReshapeProviders = null, this.enableMidpoints = true, this.enableMovement = true, this.enableVertices = true, this.graphic = null, this.highlightName = null, this.highlightsEnabled = true, this.layer = null, this.midpointGraphics = new V(), this.midpointSymbol = new u3({ style: "circle", size: 6, color: [200, 200, 200], outline: { color: [100, 100, 100], width: 1 } }), this.selectedVertices = new V(), this.snappingManager = null, this.symbols = ie, this.sketchOptions = new l4(), this.type = "reshape", this.vertexGraphics = new V(), this.view = null;
  }
  initialize() {
    const e6 = this.view;
    this._highlightHelper = new l5({ view: e6 }), this._setup(), this._updateHandlesOnExternalGeometryChange = P((() => this.graphic?.geometry), ((e7) => {
      if (!e7) return;
      const t4 = new Set(this.selectedVertices.map(((e8) => e8.attributes?.pointIndex)));
      this._highlightHelper.removeAll(), this._setUpHighlights(), this._setupGraphics(), this._clearSelection(), this.vertexGraphics.filter(((e8) => t4.has(e8.attributes.pointIndex))).forEach(((e8) => this._addToSelection(e8)));
      const { enableMovement: i6, _mover: s3, graphic: o2, midpointGraphics: r3, vertexGraphics: n2 } = this, h6 = n2.concat(r3).items;
      i6 && h6.push(o2), s3?.set("graphics", h6);
    }), U), this.tooltip = R((() => ({ view: e6, options: this.sketchOptions.tooltips }))), this.tooltipInfos = y2(this.sketchOptions), this.addHandles([f((() => e6?.ready), (() => {
      const { layer: e7, view: t4 } = this;
      t3(t4, e7), this.addHandles(t4.on("key-down", ((e8) => this._keyDownHandler(e8)), _2.TOOL));
    }), { once: true, initial: true }), l((() => this.graphic), (() => this.refresh())), l((() => this.layer), ((e7, t4) => {
      t4 && (this._clearSelection(), this._resetGraphics(t4)), this.refresh();
    })), l((() => [this.highlightsEnabled, this.highlightName]), (() => {
      this._highlightHelper?.removeAll(), this._setUpHighlights();
    })), l((() => this.enableMidpoints), (() => this.refresh())), v(this.tooltip, (() => this._tooltipsContext)), l((() => this.view.effectiveTheme.accentColor), (() => this._updateSymbolsForTheme()), h), this._updateHandlesOnExternalGeometryChange]), this._updateTooltip();
  }
  destroy() {
    this._reset(), this._mover?.destroy(), this._mover = null, this._connectedReshapeManager = u2(this._connectedReshapeManager), this.tooltip = u2(this.tooltip);
  }
  get _coordinateHelper() {
    return this._editGeometryOperations?.data.coordinateHelper ?? P2(!!this.graphic.geometry?.hasZ, !!this.graphic.geometry?.hasM, this.view.spatialReference);
  }
  get _selectedVertex() {
    return 1 === this.selectedVertices.length ? this.selectedVertices.at(0) : void 0;
  }
  get _tooltipsContext() {
    const { automaticAreaMeasurementUtils: e6, automaticLengthMeasurementUtils: t4, sketchOptions: i6, activeTooltipInfo: s3, graphic: o2 } = this;
    return { sketchOptions: i6, activeTooltipInfo: s3, graphic: o2, selectedVertex: this._selectedVertex, automaticAreaMeasurementUtils: e6, automaticLengthMeasurementUtils: t4, updateGeometry: (e7, t5, i7, s4, o3) => {
      this._setUpGeometryHelper();
      const r3 = e7 === this.graphic;
      r3 ? this._emitMoveStartEvent(0, 0) : this._emitReshapeStartEvent(e7);
      const n2 = true;
      if (this._syncGeometryAfterVertexMove(e7, t5, s4, o3, n2), r3) {
        const { view: e8 } = this, s5 = e8.toScreen(i7), o4 = e8.toScreen(t5), r4 = (o4?.x ?? 0) - (s5?.x ?? 0), n3 = (o4?.y ?? 0) - (s5?.y ?? 0);
        this._emitMoveEvent(r4, n3), this._emitMoveStopEvent(r4, n3);
      } else this._emitReshapeEvent(e7), this._emitReshapeStopEvent(e7);
      this._editGeometryOperations = u2(this._editGeometryOperations);
    } };
  }
  get state() {
    const e6 = this.view.ready, t4 = !(!this.graphic || !this.layer);
    return e6 && t4 ? "active" : e6 ? "ready" : "disabled";
  }
  isUIGraphic(e6) {
    const t4 = [];
    return this.graphic && t4.push(this.graphic), t4.concat(this.vertexGraphics.items, this.midpointGraphics.items), t4.length > 0 && t4.includes(e6);
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphic = null;
  }
  clearSelection() {
    this._clearSelection();
  }
  removeSelectedVertices() {
    const { selectedVertices: e6 } = this;
    e6.length && this._removeVertices(e6);
  }
  _setup() {
    const { graphic: e6, layer: t4 } = this;
    if (!t4 || null == e6?.geometry) return;
    const i6 = e6.geometry;
    "mesh" !== i6.type && "extent" !== i6.type ? ("polygon" === i6.type && m2(i6), this._setUpHighlights(), this._setupGraphics(), this._setupMover(), this._setupConnectedReshapeManager()) : this._logGeometryTypeError();
  }
  _setUpHighlights() {
    this.highlightsEnabled && this.graphic && this._highlightHelper?.add(this.graphic, this.highlightName);
  }
  _setUpGeometryHelper() {
    const e6 = this.graphic.geometry;
    if (null == e6 || "mesh" === e6.type || "extent" === e6.type) return void this._logGeometryTypeError();
    const t4 = "multipoint" === e6.type ? new y({ paths: [e6.points], spatialReference: e6.spatialReference }) : e6;
    this._editGeometryOperations = E.fromGeometry(t4, l3.Local);
  }
  _saveSnappingContextForHandle(e6, t4) {
    this._snappingGraphicsLayer = new c3({ listMode: "hide", internal: true, title: "Reshape snapping layer" }), this.view.map.layers.add(this._snappingGraphicsLayer);
    const i6 = this._editGeometryOperations;
    n(i6), this._snappingContext = new e4({ editGeometryOperations: i6, elevationInfo: { mode: "on-the-ground", offset: 0 }, pointer: t4.viewEvent?.pointerType || "mouse", excludeFeature: this.graphic, feature: this.graphic, visualizer: new d3(this._snappingGraphicsLayer), vertexHandle: this._getVertexFromEditGeometry(e6) });
  }
  _reset() {
    this._clearSelection(), this._highlightHelper?.removeAll(), this._updateTooltip(), this._resetGraphics(), this._resetSnappingStateVars(), this._activeOperationInfo = null, this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetSnappingStateVars() {
    null != this.snappingManager && this.snappingManager.doneSnapping(), null != this._snappingGraphicsLayer && (this.view?.map && this.view.map.layers.remove(this._snappingGraphicsLayer), this._snappingGraphicsLayer.destroy()), this._editGeometryOperations = u2(this._editGeometryOperations), this._snappingTask = e2(this._snappingTask), this._snappingTask = null, this._snappingContext = null, this._stagedVertex = null;
  }
  _resetGraphics(e6) {
    this._removeMidpointGraphics(e6), this._removeVertexGraphics(e6), this.selectedVertices.removeAll(), this._updateTooltip();
  }
  _removeMidpointGraphics(e6) {
    const t4 = e6 || this.layer;
    t4 && t4.removeMany(this.midpointGraphics.items), this.midpointGraphics.items.forEach(((e7) => e7.destroy())), this.midpointGraphics.removeAll();
  }
  _removeVertexGraphics(e6) {
    const t4 = e6 || this.layer;
    t4 && t4.removeMany(this.vertexGraphics.items), this.vertexGraphics.items.forEach(((e7) => e7.destroy())), this.vertexGraphics.removeAll();
  }
  _setupGraphics() {
    const e6 = this.graphic.geometry;
    if (null != e6 && ("polyline" === e6.type || "polygon" === e6.type)) {
      const t4 = oe(e6);
      this.enableMidpoints && this._setUpMidpointGraphics(t4), this.enableVertices && this._setUpVertexGraphics(t4);
    }
  }
  _setUpMidpointGraphics(e6) {
    this._removeMidpointGraphics();
    const t4 = this._createMidpointGraphics(e6);
    this.midpointGraphics.addMany(t4), this.layer.addMany(t4);
  }
  _setUpVertexGraphics(e6) {
    this._removeVertexGraphics();
    const t4 = this._createVertexGraphics(e6);
    this.vertexGraphics.addMany(t4), this._storeRelatedVertexIndices(), this.layer.addMany(t4);
  }
  _createVertexGraphics(e6) {
    const { _graphicAttributes: i6, symbols: s3 } = this, o2 = [];
    return e6?.forEach(((e7, r3) => {
      e7.forEach(((e8, n2) => {
        o2.push(new d2({ geometry: this._coordinateHelper.arrayToPoint(e8), symbol: s3?.vertices?.default, attributes: { ...i6, pathIndex: r3, pointIndex: n2 } }));
      }));
    })), o2;
  }
  _createMidpointGraphics(e6) {
    const { _graphicAttributes: i6, symbols: s3 } = this, o2 = [];
    for (let r3 = 0; r3 < e6.length; r3++) {
      const n2 = e6[r3];
      for (let e7 = 0; e7 < n2.length; e7++) {
        const h6 = (e7 + 1) % n2.length;
        if ("polyline" === this.graphic.geometry?.type && 0 === h6) continue;
        const a3 = n2[e7], p2 = n2[h6], c5 = this._getMidpoint(a3, p2);
        o2.push(new d2({ geometry: c5, symbol: s3.midpoints.default, attributes: { ...i6, pathIndex: r3, pointIndexStart: e7, pointIndexEnd: h6 } }));
      }
    }
    return o2;
  }
  _updateSymbolsForTheme() {
    const e6 = this.view.effectiveTheme.accentColor;
    this.symbols = { vertices: { ...this.symbols.vertices, default: this.symbols.vertices.default.clone().set("color", e6), hover: this.symbols.vertices.hover?.clone().set("color", e6) }, midpoints: { ...this.symbols.midpoints } };
    for (const t4 of this.vertexGraphics) this._isSelected(t4) ? t4.symbol = this.symbols.vertices.selected : this._hoverGraphic === t4 ? t4.symbol = this.symbols.vertices.hover : t4.symbol = this.symbols.vertices.default;
  }
  _storeRelatedVertexIndices() {
    const e6 = this.vertexGraphics.items;
    if (!e6) return;
    const t4 = e6.map((({ geometry: e7 }) => ({ x: e7.x, y: e7.y })));
    for (let i6 = 0; i6 < t4.length; i6++) {
      const s3 = [];
      for (let e7 = 0; e7 < t4.length; e7++) {
        if (i6 === e7) continue;
        const o2 = t4[i6], r3 = t4[e7];
        o2.x === r3.x && o2.y === r3.y && s3.push(e7);
      }
      e6[i6].attributes.relatedGraphicIndices = s3;
    }
  }
  _setupMover() {
    const { enableMovement: e6, graphic: t4, midpointGraphics: i6, vertexGraphics: s3, view: o2 } = this, r3 = s3.concat(i6).items;
    e6 && r3.push(t4), this._mover = new j2({ enableMoveAllGraphics: false, highlightsEnabled: false, indicatorsEnabled: false, graphics: r3, view: o2, callbacks: { onGraphicClick: (e7) => this._onGraphicClickCallback(e7), onGraphicMoveStart: (e7) => this._onGraphicMoveStartCallback(e7), onGraphicMove: (e7) => this._onGraphicMoveCallback(e7), onGraphicMoveStop: (e7) => this._onGraphicMoveStopCallback(e7), onGraphicPointerOver: (e7) => this._onGraphicPointerOverCallback(e7), onGraphicPointerOut: (e7) => this._onGraphicPointerOutCallback(e7) } });
  }
  _setupConnectedReshapeManager() {
    const { connectedReshapeProviders: e6 } = this;
    null != e6 && 0 !== e6.length && (this._connectedReshapeManager = new L({ providerFactories: e6, view: this.view }));
  }
  _onGraphicClickCallback(e6) {
    e6.viewEvent.stopPropagation();
    const t4 = e6.graphic;
    if (t4 === this.graphic) this.clearSelection(), this.emit("graphic-click", e6), this.callbacks.onGraphicClick?.(e6);
    else if (this._isMidpoint(t4)) {
      if (2 === e6.viewEvent.button) return;
      const i6 = this.graphic.clone(), s3 = this._createVertexFromMidpoint(t4);
      this.refresh(), this._emitVertexAddEvent([t4], i6, s3);
    } else if (this._isVertex(t4)) if (e6.viewEvent.stopPropagation(), 2 === e6.viewEvent.button) this._removeVertices(t4);
    else {
      e6.viewEvent.native.shiftKey || this._clearSelection(), this.selectedVertices.includes(t4) ? this._removeFromSelection(t4, true) : this._addToSelection(t4);
    }
  }
  _setUpOperation(e6) {
    const { graphic: t4, dx: i6, dy: s3 } = e6, o2 = t4 === this.graphic;
    this._resetSnappingStateVars(), this._setUpGeometryHelper(), this._saveSnappingContextForHandle(t4, e6), this._activeOperationInfo = { target: this.graphic, mover: t4, operationType: o2 ? "move" : "reshape", totalDx: i6, totalDy: s3 };
  }
  _onGraphicMoveStartCallback(e6) {
    const { dx: t4, dy: i6, graphic: s3 } = e6, o2 = this._connectedReshapeManager, r3 = o2 ? he(this.graphic) : null;
    if (s3 === this.graphic) {
      const { geometry: n3 } = s3;
      return this._setUpOperation(e6), this._emitMoveStartEvent(t4, i6), r3 && o2?.startFeatureMove([r3]), void (null != n3 && "point" === n3.type && this._onHandleMove(s3, t4, i6, e6, (() => {
        this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(t4, i6);
      })));
    }
    const { selectedVertices: n2 } = this;
    if (!n2.includes(s3)) {
      if (this._clearSelection(), this._isMidpoint(s3)) {
        const e7 = this.graphic.clone(), t5 = this._createVertexFromMidpoint(s3);
        this._emitVertexAddEvent([s3], e7, t5);
      }
      this._addToSelection(s3);
    }
    this._setUpOperation(e6), r3 && o2?.startVertexMove(r3, ae(n2)), this._emitReshapeStartEvent(s3), this._onHandleMove(s3, t4, i6, e6, (() => {
      this._updateTooltip(s3, e6.viewEvent), this._emitReshapeEvent(s3);
    }));
  }
  _onGraphicMoveCallback(e6) {
    const t4 = this._activeOperationInfo;
    if (!t4) return;
    const { dx: i6, dy: s3, graphic: o2 } = e6;
    t4.totalDx += i6, t4.totalDy += s3;
    const { operationType: r3 } = t4, { geometry: n2 } = o2;
    if (null != n2) {
      if ("move" !== r3) this._onHandleMove(o2, i6, s3, e6, (() => {
        this._updateTooltip(o2, e6.viewEvent), this._emitReshapeEvent(o2);
      }));
      else if ("point" === n2.type) this._onHandleMove(o2, i6, s3, e6, (() => {
        this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(i6, s3);
      }));
      else if ("polyline" === n2.type || "polygon" === n2.type) {
        const t5 = oe(n2);
        this._updateVertexGraphicLocations(t5);
        const { dxMap: o3, dyMap: r4 } = pe(i6, s3, this.view);
        this._connectedReshapeManager?.translate(o3, r4, 0), this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(i6, s3);
      }
    }
  }
  _onGraphicMoveStopCallback(e6) {
    const t4 = this._activeOperationInfo;
    if (!t4) return;
    const { dx: i6, dy: s3, graphic: o2 } = e6, { operationType: r3 } = t4;
    t4.totalDx += i6, t4.totalDy += s3, this._onHandleMove(o2, i6, s3, e6, (() => "move" === r3 ? this._emitMoveStopEvent() : this._emitReshapeStopEvent(o2))), this._isMidpoint(o2) ? this.refresh() : (this._updateTooltip(this._isVertex(o2) ? o2 : null), this._resetSnappingStateVars(), this._connectedReshapeManager?.finish(), this._activeOperationInfo = null);
  }
  _updateVertexGraphicLocations(e6) {
    const { _coordinateHelper: t4 } = this;
    for (const i6 of this.vertexGraphics) {
      const { pathIndex: s3, pointIndex: o2 } = i6.attributes;
      i6.geometry = t4.arrayToPoint(e6[s3][o2]);
    }
    this._updateMidpointGraphicLocations(e6);
  }
  _updateMidpointGraphicLocations(e6) {
    for (const t4 of this.midpointGraphics) {
      const { pathIndex: i6, pointIndexStart: s3, pointIndexEnd: o2 } = t4.attributes, r3 = e6[i6];
      t4.geometry = this._getMidpoint(r3[s3], r3[o2]);
    }
  }
  _getMidpoint(e6, t4) {
    const { _coordinateHelper: i6 } = this, s3 = i6.arrayToVector(e6), o2 = i6.arrayToVector(t4), r3 = i6.toXYZ(s3), n2 = i6.toXYZ(o2), [h6, a3, p2] = c2(r3, n2), c5 = i6.hasM() ? 0 : void 0;
    return new _({ x: h6, y: a3, z: p2, m: c5, spatialReference: i6.spatialReference });
  }
  _getVertexFromEditGeometry(e6) {
    n(this._editGeometryOperations);
    const [t4, i6] = re(e6);
    return this._editGeometryOperations.data.components[t4].vertices[i6];
  }
  _onHandleMove(e6, t4, s3, o2, r3) {
    e2(this._snappingTask);
    const n2 = this._snappingContext;
    if (!n2) return;
    const h6 = e6.geometry, a3 = "graphic-move-stop" === o2.type;
    if (null != this.snappingManager && this.selectedVertices.length < 2 && !a3) {
      const o3 = this.snappingManager;
      this._stagedVertex = o3.update({ point: h6, context: n2 }), this._syncGeometryAfterVertexMove(e6, new _(this._stagedVertex), t4, s3, a3), r3(), this._snappingTask = d((async (i6) => {
        const p2 = await o3.snap({ point: h6, context: n2, signal: i6 });
        p2.valid && (this._stagedVertex = p2.apply(), this._syncGeometryAfterVertexMove(e6, new _(this._stagedVertex), t4, s3, a3), r3());
      }));
    } else {
      const i6 = null != this._stagedVertex ? new _(this._stagedVertex) : h6;
      this._syncGeometryAfterVertexMove(e6, i6, t4, s3, a3), r3();
    }
  }
  _syncGeometryAfterVertexMove(e6, t4, i6, s3, o2 = false) {
    const r3 = this._editGeometryOperations?.data.geometry;
    if (!r3) return;
    const { _coordinateHelper: n2 } = this, h6 = n2.pointToVector(t4), a3 = this._getVertexFromEditGeometry(e6), p2 = n2.getZ(h6), c5 = h6[0] - a3.pos[0], l6 = h6[1] - a3.pos[1], d5 = null != p2 ? p2 - a3.pos[2] : 0;
    if (this._editGeometryOperations?.moveVertices([a3], c5, l6, d5), this._connectedReshapeManager?.translate(c5, l6, d5), "point" === r3.type) e6.geometry = t4;
    else if ("mesh" === r3.type) e6.geometry = r3.centerAt(t4);
    else {
      const [h7, a4] = re(e6);
      let p3 = e3(r3);
      const c6 = p3[h7].length - 1, l7 = n2.pointToArray(t4);
      p3[h7][a4] = l7, "polygon" === r3.type && (0 === a4 ? p3[h7][c6] = l7 : a4 === c6 && (p3[h7][0] = l7)), this._isVertex(e6) && (p3 = this._moveRelatedCoordinates(p3, e6, l7), p3 = this._moveSelectedHandleCoordinates(p3, e6, i6, s3, "polygon" === r3.type), this._updateMidpointGraphicLocations(p3)), this._updateGraphicGeometry(r3.clone()), o2 && (this._mover ? this._mover.updateGeometry(this._mover.graphics.indexOf(e6), t4) : e6.geometry = t4);
    }
  }
  _moveRelatedCoordinates(e6, t4, i6) {
    const { relatedGraphicIndices: s3 } = t4.attributes;
    for (const o2 of s3) {
      const s4 = this.vertexGraphics.at(o2), { pathIndex: r3, pointIndex: n2 } = s4.attributes;
      e6[r3][n2] = i6, s4.geometry = t4.geometry;
    }
    return e6;
  }
  _moveSelectedHandleCoordinates(e6, t4, i6, s3, o2) {
    for (const r3 of this.selectedVertices) if (r3 !== t4) {
      const { pathIndex: t5, pointIndex: n2, relatedGraphicIndices: h6 } = r3.attributes, a3 = i2(r3.geometry, i6, s3, this.view), p2 = e3(a3), c5 = e6[t5].length - 1;
      e6[t5][n2] = p2, r3.geometry = a3, o2 && (0 === n2 ? e6[t5][c5] = p2 : n2 === c5 && (e6[t5][0] = p2));
      for (const i7 of h6) {
        const t6 = this.vertexGraphics.at(i7), { pathIndex: s4, pointIndex: o3 } = t6.attributes;
        e6[s4][o3] = p2, t6.geometry = a3;
      }
    }
    return e6;
  }
  _onGraphicPointerOverCallback(e6) {
    const t4 = e6.graphic;
    this._hoverGraphic = t4;
    const i6 = this._isVertex(t4);
    i6 && !this._isSelected(t4) && (t4.symbol = this.symbols.vertices.hover), this._updateTooltip(i6 ? t4 : null), this._updateHoverCursor(t4);
  }
  _onGraphicPointerOutCallback(e6) {
    const t4 = e6.graphic;
    this._hoverGraphic = null, this._isVertex(t4) && !this._isSelected(t4) && (t4.symbol = this.symbols.vertices.default), this.view.cursor = "default", this._updateTooltip();
  }
  _createVertexFromMidpoint(e6) {
    const { _graphicAttributes: t4, graphic: i6 } = this, s3 = i6.geometry;
    if (null == s3 || "polygon" !== s3.type && "polyline" !== s3.type) return [];
    const o2 = s3.clone(), r3 = [], { pathIndex: n2, pointIndexStart: h6, pointIndexEnd: a3 } = e6.attributes, p2 = e3(e6.geometry), c5 = 0 === a3 ? h6 + 1 : a3, l6 = e3(o2);
    return l6[n2].splice(c5, 0, p2), e6.attributes = { ...t4, pathIndex: n2, pointIndex: c5, relatedGraphicIndices: [] }, r3.push({ coordinates: l6[n2][c5], componentIndex: n2, vertexIndex: c5 }), this._updateGraphicGeometry(o2), r3;
  }
  _addToSelection(e6) {
    const t4 = ne(e6);
    for (const i6 of t4) i6.symbol = this.symbols.vertices.selected, this.selectedVertices.add(i6), this._updateTooltip(i6);
    this._emitSelectEvent(t4);
  }
  _removeFromSelection(e6, t4) {
    const { vertices: i6 } = this.symbols, s3 = t4 ? i6.hover : i6.default;
    this.selectedVertices.remove(e6), e6.symbol = s3, this._emitDeselectEvent([e6]), this._updateTooltip();
  }
  _clearSelection() {
    const e6 = this.selectedVertices.toArray();
    if (e6.length > 0) {
      for (const t4 of e6) t4.set("symbol", this.symbols.vertices.default);
      this.selectedVertices.removeAll(), this._emitDeselectEvent(e6), this._updateTooltip();
    }
  }
  _keyDownHandler(e6) {
    null == this._activeOperationInfo && H(e6, this.tooltip) || c4.delete.includes(e6.key) && !e6.repeat && this.selectedVertices.length && this._removeVertices(this.selectedVertices);
  }
  _removeVertices(e6) {
    const t4 = this.graphic.geometry;
    if (null == t4 || "polygon" !== t4.type && "polyline" !== t4.type) return;
    if ("polygon" === t4.type && this.vertexGraphics.length < 4 || this.vertexGraphics.length < 3) return;
    const i6 = this.graphic.clone(), s3 = t4.clone();
    let o2 = e3(s3);
    const r3 = [], n2 = ne(e6);
    for (const h6 of n2) {
      const { x: e7, y: t5 } = h6.geometry;
      for (let i7 = 0; i7 < o2.length; i7++) {
        const s4 = o2[i7];
        for (let n3 = 0; n3 < s4.length; n3++) {
          const [h7, a3] = s4[n3];
          e7 === h7 && t5 === a3 && (r3.push({ coordinates: o2[i7][n3], componentIndex: i7, vertexIndex: n3 }), o2[i7].splice(Number(n3), 1));
        }
      }
    }
    if ("polygon" === s3.type) o2 = o2.filter(((e7) => {
      if (e7.length < 2) return false;
      const [t5, i7] = e7[0], [s4, o3] = e7[e7.length - 1];
      return (2 !== e7.length || t5 !== s4 || i7 !== o3) && (t5 === s4 && i7 === o3 || e7.push(e7[0]), true);
    })), s3.rings = o2;
    else {
      for (const e7 of o2) 1 === e7.length && o2.splice(o2.indexOf(e7), 1);
      s3.paths = o2;
    }
    this._updateGraphicGeometry(s3), this.refresh(), this._emitVertexRemoveEvent(n2, i6, r3);
  }
  _isVertex(e6) {
    return this.vertexGraphics.includes(e6);
  }
  _isSelected(e6) {
    return this._isVertex(e6) && this.selectedVertices.includes(e6);
  }
  _isMidpoint(e6) {
    return this.midpointGraphics.includes(e6);
  }
  _updateHoverCursor(e6) {
    this.view.cursor = this._isMidpoint(e6) ? "copy" : "move";
  }
  _updateTooltip(e6, t4) {
    let i6 = null;
    const { graphic: s3, view: o2, tooltipInfos: r3 } = this, n2 = s3?.geometry;
    "point" === n2?.type ? i6 = r3.movePoint : this._selectedVertex ? i6 = r3.selectedVertex : e6 === this.graphic ? (i6 = r3.translateGraphic, j4(i6, o2, this._tooltipsContext, t4)) : e6 && this.selectedVertices.length > 1 && (i6 = r3.translateVertices, w3(i6, o2, n2, this._tooltipsContext, t4)), this.activeTooltipInfo = i6;
  }
  _updateGraphicGeometry(e6) {
    this._updateHandlesOnExternalGeometryChange?.pause(), this.graphic.geometry = e6, this._updateHandlesOnExternalGeometryChange?.resume();
  }
  _emitMoveStartEvent(e6, t4) {
    const i6 = new q(this.graphic, e6, t4);
    this.emit("move-start", i6), this.callbacks.onMoveStart?.(i6);
  }
  _emitMoveEvent(e6, t4) {
    const i6 = new B(this.graphic, e6, t4);
    this.emit("move", i6), this.callbacks.onMove?.(i6);
  }
  _emitMoveStopEvent(e6, t4) {
    if (null == e6 || null == t4) {
      const i7 = this._activeOperationInfo;
      if (!i7) return;
      e6 = i7.totalDx, t4 = i7.totalDy;
    }
    const i6 = new J(this.graphic, e6, t4);
    this.emit("move-stop", i6), this.callbacks.onMoveStop?.(i6);
  }
  _emitReshapeStartEvent(e6) {
    const t4 = new X(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape-start", t4), this.callbacks.onReshapeStart?.(t4);
  }
  _emitReshapeEvent(e6) {
    const t4 = new Y(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape", t4), this.callbacks.onReshape?.(t4);
  }
  _emitReshapeStopEvent(e6) {
    const t4 = new K(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape-stop", t4), this.callbacks.onReshapeStop?.(t4);
  }
  _emitSelectEvent(e6) {
    const t4 = new Q(e6);
    this.emit("select", t4), this.callbacks.onVertexSelect?.(t4);
  }
  _emitDeselectEvent(e6) {
    const t4 = new W(e6);
    this.emit("deselect", t4), this.callbacks.onVertexDeselect?.(t4);
  }
  _emitVertexAddEvent(e6, t4, i6) {
    const s3 = new $(e6, this.graphic, t4, i6);
    this.emit("vertex-add", s3), this.callbacks.onVertexAdd?.(s3);
  }
  _emitVertexRemoveEvent(e6, t4, i6) {
    const s3 = new ee(e6, this.graphic, t4, i6);
    this.emit("vertex-remove", s3), this.callbacks.onVertexRemove?.(s3);
  }
  _logGeometryTypeError() {
    i.getLogger(this).error(new s("reshape:invalid-geometry", "Reshape operation not supported for the provided graphic. The geometry type is not supported."));
  }
};
function oe(e6) {
  const t4 = e3(e6.clone());
  if ("polygon" === e6.type) for (const i6 of t4) {
    const e7 = i6[i6.length - 1];
    i6[0][0] === e7[0] && i6[0][1] === e7[1] && i6.length > 2 && i6.pop();
  }
  return t4;
}
function re({ attributes: e6 }) {
  return [e6?.pathIndex || 0, e6?.pointIndex || 0];
}
function ne(e6) {
  return e6 instanceof d2 ? [e6] : [...e6];
}
function he(e6) {
  const t4 = e6.sourceLayer ?? e6.layer;
  return a2(t4) ? { graphic: e6, layer: t4 } : null;
}
function ae(e6) {
  return e6.toArray().map(((e7) => ({ pathIndex: e7.attributes.pathIndex, vertexIndex: e7.attributes.pointIndex })));
}
function pe(e6, t4, i6) {
  const s3 = i6.state.inverseTransform;
  return { dxMap: s3[0] * e6 + s3[2] * t4, dyMap: s3[1] * e6 + s3[3] * t4 };
}
r([m()], se.prototype, "_activeOperationInfo", void 0), r([m()], se.prototype, "_connectedReshapeManager", void 0), r([m()], se.prototype, "_coordinateHelper", null), r([m()], se.prototype, "_editGeometryOperations", void 0), r([m()], se.prototype, "tooltip", void 0), r([m()], se.prototype, "tooltipInfos", void 0), r([m()], se.prototype, "activeTooltipInfo", void 0), r([m({ constructOnly: true })], se.prototype, "automaticAreaMeasurementUtils", void 0), r([m({ constructOnly: true })], se.prototype, "automaticLengthMeasurementUtils", void 0), r([m()], se.prototype, "_selectedVertex", null), r([m()], se.prototype, "_tooltipsContext", null), r([m()], se.prototype, "callbacks", void 0), r([m()], se.prototype, "connectedReshapeProviders", void 0), r([m()], se.prototype, "enableMidpoints", void 0), r([m()], se.prototype, "enableMovement", void 0), r([m()], se.prototype, "enableVertices", void 0), r([m()], se.prototype, "graphic", void 0), r([m()], se.prototype, "highlightName", void 0), r([m()], se.prototype, "highlightsEnabled", void 0), r([m()], se.prototype, "layer", void 0), r([m({ readOnly: true })], se.prototype, "midpointGraphics", void 0), r([m()], se.prototype, "midpointSymbol", void 0), r([m({ readOnly: true })], se.prototype, "selectedVertices", void 0), r([m()], se.prototype, "snappingManager", void 0), r([m({ readOnly: true })], se.prototype, "state", null), r([m()], se.prototype, "symbols", void 0), r([m({ type: l4 })], se.prototype, "sketchOptions", void 0), r([m({ readOnly: true })], se.prototype, "type", void 0), r([m({ readOnly: true })], se.prototype, "vertexGraphics", void 0), r([m()], se.prototype, "view", void 0), se = r([a("esri.views.draw.support.Reshape")], se);
var ce = se;
export {
  ce as default
};
//# sourceMappingURL=Reshape-4ZEDQMUQ.js.map
