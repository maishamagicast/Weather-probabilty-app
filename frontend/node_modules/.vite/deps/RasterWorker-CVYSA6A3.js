import {
  m,
  n,
  t
} from "./chunk-6PPPZL4E.js";
import {
  T as T2
} from "./chunk-UWE6QWWV.js";
import "./chunk-6TQZGAGP.js";
import {
  se,
  v
} from "./chunk-2RN2TIFH.js";
import {
  c
} from "./chunk-LHRFXQHT.js";
import {
  _ as _2,
  h2 as h,
  j,
  p
} from "./chunk-WY7DBVBR.js";
import {
  D,
  I,
  R,
  T,
  c2,
  f3 as f,
  j as j2,
  s2 as s,
  u3 as u
} from "./chunk-VYNLVHME.js";
import "./chunk-LUNNU672.js";
import "./chunk-HQ25T2F7.js";
import "./chunk-HH4Q2NN5.js";
import "./chunk-3CFYBBSV.js";
import "./chunk-RZGBA4KS.js";
import "./chunk-SCMB64VM.js";
import {
  r as r2
} from "./chunk-APMQAZ5Z.js";
import "./chunk-VQWEDC6T.js";
import "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-3L5JZOMH.js";
import "./chunk-N77BULFI.js";
import "./chunk-NEIJCC5O.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-RKF6WUZT.js";
import "./chunk-RMRI4NYS.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-BLBN3L5Q.js";
import "./chunk-XNUSHDFN.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-ZJQPHR3K.js";
import "./chunk-3QHX4R4B.js";
import {
  z
} from "./chunk-CBXZL53X.js";
import {
  _
} from "./chunk-SMO33YG7.js";
import "./chunk-LCBAL6ER.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import "./chunk-67AKDROO.js";
import "./chunk-CM3TIXEV.js";
import "./chunk-POWGZO3T.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-NJZD7WM5.js";
import "./chunk-CL7VLXUR.js";
import "./chunk-FCX4ZA3Z.js";
import "./chunk-2ZPU5IZX.js";
import {
  a2 as a
} from "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import "./chunk-JNYZ3I5R.js";
import "./chunk-N626Y23H.js";
import "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/rasterTransforms/IdentityTransform.js
var e;
var a2 = e = class extends t {
  constructor() {
    super(...arguments), this.type = "identity";
  }
  clone() {
    return new e();
  }
};
r([r2({ IdentityXform: "identity" })], a2.prototype, "type", void 0), a2 = e = r([a("esri.layers.support.rasterTransforms.IdentityTransform")], a2);

// node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js
var n2 = { GCSShiftXform: n, IdentityXform: a2, PolynomialXform: m };
function f2(r3) {
  const o = r3?.type;
  if (!o) return null;
  const t2 = n2[r3?.type];
  if (t2) {
    const o2 = new t2();
    return o2.read(r3), o2;
  }
  return null;
}

// node_modules/@arcgis/core/layers/support/RasterWorker.js
var N = class {
  convertVectorFieldData(r3) {
    const e2 = c2.fromJSON(r3.pixelBlock), t2 = f(e2, r3.type);
    return Promise.resolve(null != t2 ? t2.toJSON() : null);
  }
  computeStatisticsHistograms(r3) {
    const e2 = c2.fromJSON(r3.pixelBlock), t2 = h(e2);
    return Promise.resolve(t2);
  }
  async decode(r3) {
    const e2 = await j(r3.data, r3.options);
    return e2 && e2.toJSON();
  }
  symbolize(e2) {
    e2.pixelBlock = c2.fromJSON(e2.pixelBlock), e2.extent = e2.extent ? z.fromJSON(e2.extent) : null;
    const t2 = this.symbolizer.symbolize(e2);
    return Promise.resolve(null != t2 ? t2.toJSON() : null);
  }
  async updateSymbolizer(r3) {
    this.symbolizer = _2.fromJSON(r3.symbolizerJSON), r3.histograms && "rasterStretch" === this.symbolizer?.rendererJSON.type && (this.symbolizer.rendererJSON.histograms = r3.histograms);
  }
  async updateRasterFunction(r3) {
    this.rasterFunction = T2(r3.rasterFunctionJSON);
  }
  async process(t2) {
    const o = this.rasterFunction.process({ extent: z.fromJSON(t2.extent), primaryPixelBlocks: t2.primaryPixelBlocks.map(((r3) => null != r3 ? c2.fromJSON(r3) : null)), primaryPixelSizes: t2.primaryPixelSizes?.map(((r3) => null != r3 ? _.fromJSON(r3) : null)), primaryRasterIds: t2.primaryRasterIds });
    return null != o ? o.toJSON() : null;
  }
  stretch(r3) {
    const e2 = this.symbolizer.simpleStretch(c2.fromJSON(r3.srcPixelBlock), r3.stretchParams);
    return Promise.resolve(e2?.toJSON());
  }
  estimateStatisticsHistograms(r3) {
    const e2 = p(c2.fromJSON(r3.srcPixelBlock));
    return Promise.resolve(e2);
  }
  split(r3) {
    const e2 = I(c2.fromJSON(r3.srcPixelBlock), r3.tileSize, r3.maximumPyramidLevel ?? 0, false === r3.useBilinear);
    return e2 && e2.forEach(((r4, t2) => {
      e2.set(t2, r4?.toJSON());
    })), Promise.resolve(e2);
  }
  clipTile(r3) {
    const e2 = c2.fromJSON(r3.pixelBlock), t2 = R({ ...r3, pixelBlock: e2 });
    return Promise.resolve(t2?.toJSON());
  }
  async mosaicAndTransform(r3) {
    const e2 = r3.srcPixelBlocks.map(((r4) => r4 ? new c2(r4) : null)), t2 = T(e2, r3.srcMosaicSize, { blockWidths: r3.blockWidths, alignmentInfo: r3.alignmentInfo, clipOffset: r3.clipOffset, clipSize: r3.clipSize });
    let o, i = t2;
    return r3.coefs && (i = D(t2, r3.destDimension, r3.coefs, r3.sampleSpacing, r3.interpolation)), r3.projectDirections && r3.gcsGrid && (o = j2(r3.destDimension, r3.gcsGrid), i = u(i, r3.isUV ? "vector-uv" : "vector-magdir", o)), { pixelBlock: i?.toJSON(), localNorthDirections: o };
  }
  async createFlowMesh(r3, e2) {
    const t2 = { data: new Float32Array(r3.flowData.buffer), mask: new Uint8Array(r3.flowData.maskBuffer), width: r3.flowData.width, height: r3.flowData.height }, { vertexData: s2, indexData: o } = await s(r3.meshType, r3.simulationSettings, t2, e2.signal);
    return { result: { vertexBuffer: s2.buffer, indexBuffer: o.buffer }, transferList: [s2.buffer, o.buffer] };
  }
  async getProjectionOffsetGrid(e2) {
    const s2 = z.fromJSON(e2.projectedExtent), o = z.fromJSON(e2.srcBufferExtent);
    let i = null;
    e2.datumTransformationSteps?.length && (i = new c({ steps: e2.datumTransformationSteps })), await v();
    const n3 = e2.rasterTransform ? f2(e2.rasterTransform) : null;
    return se({ ...e2, projectedExtent: s2, srcBufferExtent: o, datumTransformation: i, rasterTransform: n3 });
  }
};
export {
  N as default
};
//# sourceMappingURL=RasterWorker-CVYSA6A3.js.map
