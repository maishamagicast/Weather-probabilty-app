import {
  i as i8
} from "./chunk-UMJMXEKH.js";
import {
  a as a4
} from "./chunk-44OPRFPJ.js";
import {
  i as i6,
  n as n4,
  r as r5
} from "./chunk-3DDYAE2Z.js";
import {
  F,
  a as a6,
  a2 as a7,
  d2 as d4,
  e as e6,
  m as m6,
  o2 as o7,
  o3 as o8,
  t2 as t4,
  u as u8,
  x2,
  y,
  z as z2
} from "./chunk-PE6RTTM2.js";
import {
  i as i7
} from "./chunk-GOCIDHTW.js";
import {
  I
} from "./chunk-6PL4I2QQ.js";
import {
  S
} from "./chunk-R4ARMIGB.js";
import {
  u as u9
} from "./chunk-M6JFBQWH.js";
import {
  a as a5
} from "./chunk-GY7Z7OPO.js";
import {
  E as E2
} from "./chunk-YGH5IYUW.js";
import {
  n as n3,
  p as p3
} from "./chunk-5TOIA5VY.js";
import {
  o as o6
} from "./chunk-GYPE5A7A.js";
import {
  r as r4,
  s as s5
} from "./chunk-3IQRKLNB.js";
import {
  p
} from "./chunk-BGSPX4Z3.js";
import {
  d as d3
} from "./chunk-WBA6DQSU.js";
import {
  n as n2
} from "./chunk-XOKYRVJ5.js";
import {
  c
} from "./chunk-D2DRG2DH.js";
import {
  J,
  W
} from "./chunk-QZISYUPA.js";
import {
  e as e5
} from "./chunk-BA77LF63.js";
import {
  t as t2
} from "./chunk-KKLYYV7Q.js";
import {
  e as e4
} from "./chunk-W7HTQBDK.js";
import {
  fe,
  o as o5,
  te
} from "./chunk-YF3MIHOZ.js";
import {
  u as u7
} from "./chunk-TIU3P5HE.js";
import {
  i as i5
} from "./chunk-JGQLR7O7.js";
import {
  g as g2
} from "./chunk-YT2ORY5Z.js";
import {
  R as R3
} from "./chunk-JQEV3UIC.js";
import {
  i as i3,
  o as o4
} from "./chunk-K55CXVYD.js";
import {
  i as i4
} from "./chunk-OPQ3FCJ4.js";
import {
  m as m3
} from "./chunk-2EOHKZLO.js";
import {
  ot
} from "./chunk-24S6C5S6.js";
import {
  f as f3
} from "./chunk-UICDKBDP.js";
import {
  h2 as h3,
  r as r6
} from "./chunk-AKZZRLKD.js";
import {
  c as c2
} from "./chunk-746KDGCX.js";
import {
  t as t3
} from "./chunk-SVGSXWMQ.js";
import {
  p as p2
} from "./chunk-DKFJHHQ4.js";
import {
  E,
  N,
  R as R2
} from "./chunk-JUXSLKSN.js";
import {
  e as e3
} from "./chunk-KW37MFF6.js";
import {
  s as s4
} from "./chunk-P3R3JSYO.js";
import {
  h
} from "./chunk-FPALEK52.js";
import {
  R
} from "./chunk-LQYJLB4P.js";
import {
  s as s3
} from "./chunk-7OH24VUH.js";
import {
  D
} from "./chunk-BELQIHLO.js";
import {
  d as d2
} from "./chunk-PBKE5BCM.js";
import {
  m as m5
} from "./chunk-CHAHOTAY.js";
import {
  D as D2,
  L as L3,
  M,
  P,
  Q,
  R as R4,
  T,
  _,
  h as h2,
  j,
  ke,
  w as w2,
  x
} from "./chunk-W5UOLFE2.js";
import {
  e as e2,
  l as l4,
  r as r3,
  u as u5
} from "./chunk-AZ2S2PYZ.js";
import {
  V
} from "./chunk-74GULGYB.js";
import {
  u as u3
} from "./chunk-BLBN3L5Q.js";
import {
  z
} from "./chunk-CBXZL53X.js";
import {
  a as a3,
  l as l2,
  w
} from "./chunk-HYAO4PVV.js";
import {
  o
} from "./chunk-VNQUG2TO.js";
import {
  f as f2
} from "./chunk-LCBAL6ER.js";
import {
  g2 as g
} from "./chunk-2AYGXVZI.js";
import {
  u as u6
} from "./chunk-WO5FLTVY.js";
import {
  m as m4
} from "./chunk-MGA7XBRB.js";
import {
  u as u4
} from "./chunk-4AKMPOG7.js";
import {
  m as m2,
  r as r2
} from "./chunk-ZJQPHR3K.js";
import {
  o as o3
} from "./chunk-NJZD7WM5.js";
import {
  l as l3
} from "./chunk-FCX4ZA3Z.js";
import {
  b as b2,
  m2 as m
} from "./chunk-2ZPU5IZX.js";
import {
  a2
} from "./chunk-S62CSPIH.js";
import {
  o as o2
} from "./chunk-XNYPRDKK.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import {
  L as L2,
  b,
  d,
  e,
  f2 as f,
  s as s2,
  t,
  u2 as u,
  u3 as u2
} from "./chunk-N626Y23H.js";
import {
  a,
  i,
  i3 as i2,
  l2 as l,
  s2 as s
} from "./chunk-TJPLHZCD.js";
import {
  L,
  has,
  n
} from "./chunk-KLFJ5V5G.js";

// node_modules/@arcgis/core/AggregateGraphic.js
var p4 = class extends d2 {
  constructor() {
    super(...arguments), this.isAggregate = true;
  }
  getEffectivePopupTemplate(e12 = false) {
    if (this.popupTemplate) return this.popupTemplate;
    const t11 = this.sourceLayer?.featureReduction;
    return t11 && "popupTemplate" in t11 && t11.popupEnabled ? t11.popupTemplate : null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
r([m({ type: Boolean })], p4.prototype, "isAggregate", void 0), p4 = r([a2("esri.AggregateGraphic")], p4);
var s6 = p4;

// node_modules/@arcgis/core/TrackGraphic.js
var s7 = class extends d2 {
  constructor() {
    super(...arguments), this.isAggregate = true;
  }
  getEffectivePopupTemplate(e12 = false) {
    if (this.popupTemplate) return this.popupTemplate;
    const r12 = this.sourceLayer?.trackInfo;
    return r12?.enabled && r12.popupEnabled ? r12.popupTemplate : null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
r([m({ type: Boolean })], s7.prototype, "isAggregate", void 0), s7 = r([a2("esri.TrackGraphic")], s7);
var p5 = s7;

// node_modules/@arcgis/core/layers/effects/FeatureEffectView.js
var c3 = class extends b2 {
  constructor(e12) {
    super(e12), this._filter = null, this.duration = has("mapview-transitions-duration"), this._excludedEffectView = new a5(e12), this._includedEffectView = new a5(e12);
  }
  get excludedEffects() {
    return this._excludedEffectView.effects;
  }
  set featureEffect(e12) {
    this._get("featureEffect") !== e12 && this._transitionTo(e12);
  }
  get filter() {
    return this._filter || this.featureEffect?.filter || null;
  }
  get hasEffects() {
    return this._excludedEffectView.hasEffects || this._includedEffectView.hasEffects;
  }
  get includedEffects() {
    return this._includedEffectView.effects;
  }
  set scale(e12) {
    this._set("scale", e12), this._excludedEffectView.scale = e12, this._includedEffectView.scale = e12;
  }
  get transitioning() {
    return this._excludedEffectView.transitioning || this._includedEffectView.transitioning;
  }
  get transitioningToEmpty() {
    return !this._excludedEffectView.final && !this._includedEffectView.final;
  }
  transitionStep(e12, t11) {
    this._set("scale", t11), this.transitioning ? (this._includedEffectView.transitionStep(e12, t11), this._excludedEffectView.transitionStep(e12, t11), this.transitioning || (this._filter = null)) : (this._excludedEffectView.scale = t11, this._includedEffectView.scale = t11);
  }
  endTransition() {
    this._includedEffectView.endTransition(), this._excludedEffectView.endTransition(), this._filter = null;
  }
  _transitionTo(e12) {
    const t11 = this._get("featureEffect"), i13 = e12, f7 = i13?.includedEffect, s12 = i13?.excludedEffect, c9 = this._includedEffectView.canTransitionTo(f7) && this._excludedEffectView.canTransitionTo(s12);
    this._includedEffectView.effect = f7, this._excludedEffectView.effect = s12, this._set("featureEffect", i13), this._filter = i13?.filter || t11?.filter || null, c9 || this.endTransition();
  }
};
r([m()], c3.prototype, "_filter", void 0), r([m()], c3.prototype, "_excludedEffectView", void 0), r([m()], c3.prototype, "_includedEffectView", void 0), r([m()], c3.prototype, "duration", void 0), r([m()], c3.prototype, "excludedEffects", null), r([m()], c3.prototype, "featureEffect", null), r([m()], c3.prototype, "filter", null), r([m()], c3.prototype, "hasEffects", null), r([m()], c3.prototype, "includedEffects", null), r([m({ value: 0 })], c3.prototype, "scale", null), r([m()], c3.prototype, "transitioning", null), r([m()], c3.prototype, "transitioningToEmpty", null), c3 = r([a2("esri.layers.effects.FeatureEffectView")], c3);

// node_modules/@arcgis/core/rest/support/AggregateFeatureSet.js
var c4 = class extends g2 {
  constructor() {
    super(...arguments), this.features = [];
  }
  readFeatures(e12, t11) {
    const o17 = f2.fromJSON(t11.spatialReference), s12 = [];
    for (let a12 = 0; a12 < e12.length; a12++) {
      const t12 = e12[a12], p12 = s6.fromJSON(t12), c9 = t12.geometry?.spatialReference;
      null == p12.geometry || c9 || (p12.geometry.spatialReference = o17);
      const i13 = t12.aggregateGeometries, m16 = p12.aggregateGeometries;
      if (i13 && null != m16) for (const e13 in m16) {
        const r12 = m16[e13], t13 = i13[e13], s13 = t13?.spatialReference;
        null == r12 || s13 || (r12.spatialReference = o17);
      }
      s12.push(p12);
    }
    return s12;
  }
};
r([m({ type: [s6], json: { write: true } })], c4.prototype, "features", void 0), r([o3("features")], c4.prototype, "readFeatures", null), c4 = r([a2("esri.rest.support.AggregateFeatureSet")], c4);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/FeatureInstanceStore.js
var n5 = class {
  constructor() {
    this._instanceById = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._instanceById.clear();
  }
  get size() {
    return this._instanceById.size;
  }
  entries() {
    return this._instanceById.entries();
  }
  find(t11) {
    for (const e12 of this.values()) if (e12.techniqueRef.type === t11) return e12;
    return null;
  }
  updateStart(t11) {
    t11 && (this._instanceByIdNext = /* @__PURE__ */ new Map(), this._shaderCountByMesh = /* @__PURE__ */ new Map(), this._shaderIndices = /* @__PURE__ */ new Map());
  }
  updateEnd(t11) {
    if (t11) {
      if (!this._instanceByIdNext) throw new Error("InternalError: Found updateEnd call without corresponding updateStart");
      for (const t12 of this._instanceById.keys()) this._instanceByIdNext.has(t12) || this._instanceById.delete(t12);
      for (const [t12, e12] of this._instanceByIdNext.entries()) {
        const s12 = this._instanceById.get(t12);
        s12 ? s12.setInput(e12.getInput()) : this._instanceById.set(t12, e12);
      }
      this._instanceByIdNext = null, this._shaderCountByMesh = null, this._shaderIndices = null;
    }
  }
  values() {
    return this._instanceById.values();
  }
  ensureInstance(n16, i13) {
    let r12;
    if ("object" == typeof i13 && "optionalAttributes" in i13 && "uniforms" in i13) {
      const t11 = `${n16.type}.${JSON.stringify(i13.optionalAttributes)}`, e12 = t11 + `.${JSON.stringify(i13.uniforms)}`;
      let s12 = 0;
      null != this._instanceByIdNext && (this._shaderIndices.has(e12) ? s12 = this._shaderIndices.get(e12) : (s12 = this._shaderCountByMesh.get(t11) ?? 0, this._shaderCountByMesh.set(t11, s12 + 1), this._shaderIndices.set(e12, s12))), r12 = t11 + `.${s12}`;
    } else r12 = `${n16.type}.${JSON.stringify(i13)}`;
    const a12 = l(r12);
    if (this._instanceByIdNext) {
      const t11 = new i6(r5(a12), n16, i13);
      return this._instanceByIdNext.set(a12, t11), t11;
    }
    if (!this._instanceById.has(a12)) {
      const t11 = new i6(r5(a12), n16, i13);
      this._instanceById.set(a12, t11);
    }
    return this._instanceById.get(a12);
  }
  getInstance(t11) {
    const e12 = this._instanceById.get(t11);
    if (null == e12) throw new Error(`InternalError: Unable to get instance for ${t11}`);
    return e12;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/RenderState.js
var d5 = 1e3;
var l5 = class {
  constructor(t11, i13, s12, o17, n16, r12) {
    this.getStage = t11, this.getSubscriptionVersion = i13, this.version = s12, this._fader = o17, this._container = n16, this._tileInfoView = r12, this._pendingUpdates = new t2(d5), this._locked = false, this._tiles = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const e12 of this.tiles()) this._fader.unregisterFeatureTile(e12), e12.destroy();
    this._pendingUpdates.clear(), this._tiles.clear(), this._container = null, this._fader = null;
  }
  tiles() {
    return this._tiles.values();
  }
  size() {
    return this._tiles.size;
  }
  getTile(e12) {
    return this._tiles.get(e12);
  }
  setTiles(e12) {
    this._tiles.clear();
    for (const t11 of e12) this._tiles.set(t11.key.id, t11);
  }
  lockUploads() {
    this._locked = true;
  }
  unlockUploads() {
    this._locked = false, this.flush();
  }
  enqueueUpdate(e12) {
    this._pendingUpdates.enqueue(e12);
  }
  update(e12) {
    if (!this._locked) for (; this._pendingUpdates.size; ) {
      const t11 = this._pendingUpdates.peek();
      if (null == t11 || t11.inner.attributeEpoch > e12) break;
      this._updateTile(t11), this._pendingUpdates.dequeue();
    }
  }
  removeTile(e12) {
    const t11 = this._tiles.get(e12);
    has("esri-2d-update-debug") && console.debug(`Tile[${e12}] RenderState.removeTile`), t11 && (this._fader.unregisterFeatureTile(t11), t11.destroy()), this._tiles.delete(e12);
  }
  isTileDone(e12) {
    const t11 = this._tiles.get(e12.id);
    return !!t11 && (t11.isReady && t11.decluttered);
  }
  flush() {
    for (; this._pendingUpdates.size; ) {
      const e12 = this._pendingUpdates.dequeue();
      null != e12 && this._updateTile(e12);
    }
    for (const e12 of this._tiles.values()) e12.upload();
  }
  _updateTile(e12) {
    const { inner: t11, objectIdMap: i13 } = e12, s12 = this.getSubscriptionVersion(t11.id);
    if (s12 !== t11.subscriptionVesrion) {
      if (has("esri-2d-update-debug")) {
        const e13 = `${t11.subscriptionVesrion} != ${s12}`;
        console.debug(`Version[${e13}] Tile[${t11.id}] FeatureContainer - Dropping message, outdated version]`, t11);
      }
      return;
    }
    if (has("esri-2d-update-debug")) {
      const e13 = t11.debugInfo?.chunkId ?? "<EnsureEnd>";
      console.debug(`Version[${t11.version}] Tile[${t11.id}] Chunk[${e13}] RenderState.updateTile [${t11.type}]`, t11);
    }
    const o17 = this._ensureTile(t11.id);
    if ("update" === t11.type) {
      const [e13, ...s13] = t11.modify;
      o17.onMessage({ type: "update", modify: e13, remove: t11.remove, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i13 });
      for (const o18 of s13) {
        const e14 = this._tiles.get(o18.tileId);
        e14 && e14.onMessage({ type: "update", modify: o18, remove: t11.remove, end: false, isPixelBuffer: true, attributeEpoch: null, objectIdMap: i13 });
      }
      return;
    }
    if (null == t11.append) return void o17.onMessage({ type: "append", clear: t11.clear, debugInfo: t11.debugInfo, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i13 });
    const [n16, ...r12] = t11.append;
    o17.onMessage({ type: "append", clear: t11.clear, append: n16, debugInfo: t11.debugInfo, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i13 });
    for (const d9 of r12) {
      const e13 = this._tiles.get(d9.tileId);
      e13 && e13.onMessage({ type: "update", modify: d9, remove: [], sort: false, end: false, isPixelBuffer: true, attributeEpoch: null, objectIdMap: i13 });
    }
  }
  _ensureTile(e12) {
    if (!this._tiles.has(e12)) {
      const t11 = this._createTile(e12);
      this._copyPixelBufferedEntitiesInto(t11), this._tiles.set(e12, t11);
    }
    return this._tiles.get(e12);
  }
  _createTile(e12) {
    has("esri-2d-update-debug") && console.debug(`Version[${this.version}] Tile[${e12}] RenderState.createTile`);
    const d9 = new e3(e12), l10 = this._tileInfoView.getTileBounds(u3(), d9), a12 = l10[0], u18 = l10[3], p12 = this._tileInfoView.getTileResolution(d9.level), c9 = this._container.instanceStore.find(e4.Label)?.instanceId, h4 = new I(d9, p12, a12, u18, this._fader, c9, true);
    if (this._fader.registerFeatureTile(h4), h4.stage = this.getStage(), !h4.stage) {
      const e13 = new s("featurelayerview:webgl", "Cannot create tile with empty stage");
      i2.getLogger("esri.views.2d.layers.features.RenderState").error(e13);
    }
    return h4;
  }
  _copyPixelBufferedEntitiesInto(e12) {
    let t11 = 7;
    const i13 = this._tileInfoView.getLODInfoAt(e12.key);
    for (let s12 = -1; s12 <= 1; s12++) for (let o17 = -1; o17 <= 1; o17++) {
      if (0 === s12 && 0 === o17) continue;
      const n16 = e12.key.getNormalizedNeighbor(o17, s12, i13).id, r12 = this._tiles.get(n16);
      if (null != r12) {
        const i14 = 1 << t11;
        e12.copyPixelBufferedEntitesFrom(r12, i14, o17, s12);
      }
      t11--;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureContainer.js
var _2 = class {
  constructor(e12, t11) {
    this.id = e12, this.version = t11, this._resolver = L2(), this._done = false;
  }
  get done() {
    return this._done;
  }
  get promise() {
    return this._resolver.promise;
  }
  end() {
    this._resolver.resolve(), this._done = true;
  }
  destroy() {
    this._resolver.reject();
  }
};
var p6 = class extends n4 {
  constructor(e12) {
    super(e12.view.featuresTilingScheme), this.updatingHandles = new h(), this._hitTestsRequests = [], this._store = new n5(), this._visibleTiles = /* @__PURE__ */ new Set(), this._subscriptions = /* @__PURE__ */ new Map(), this._updateStatisticsRequests = [], this._lockStatisticUpdates = false, this._shouldUnlockAttributeView = false, this._layerView = e12, this.addTransitionable(this._layerView.featureEffectView);
  }
  destroy() {
    super.destroy(), this._renderState = u(this._renderState), this._renderStateNext = u(this._renderStateNext);
  }
  renderChildren(e12) {
    if (this._updateAttributeView(), this._renderState?.update(this.attributeView.currentEpoch), this._layerView.requestUpdate(), this._renderState) {
      const e13 = Array.from(this._renderState.tiles()).filter(((e14) => e14.needsUpload));
      if (e13.length) {
        e13[Math.floor(Math.random() * e13.length)].upload(), e13.length >= 2 && this.requestRender();
      }
      for (const t12 of this._renderState.tiles()) t12.tryReady(this.attributeView.currentEpoch) && (this._subscriptions.get(t12.key.id)?.end(), this._layerView.requestUpdate(), this.hasLabels && this._layerView.view.labelManager.requestUpdate(), this._layerView.view.labelManager.symbolFader.restartDeclutter(), this.requestRender());
    }
    const t11 = this._layerView.subscriptionManager.updateVisibility();
    this.setVisibleTiles(t11);
    for (const s12 of this.children) s12.setTransform(e12.state);
    switch (super.renderChildren(e12), e12.drawPhase) {
      case E.MAP:
        return this._renderMapPhase(e12);
      case E.HIGHLIGHT:
        return this._renderHighlightPhase(e12);
      case E.LABEL:
        return this._renderLabelPhase(e12);
    }
  }
  subscriptions() {
    return this._subscriptions.values();
  }
  get _instanceStore() {
    return this._store;
  }
  get instanceStore() {
    return this._store;
  }
  get layerView() {
    return this._layerView;
  }
  get hasLabels() {
    return this._layerView.labelingCollisionInfos.length > 0;
  }
  get hasHighlight() {
    return this._layerView.hasHighlight;
  }
  get _layer() {
    return this._layerView.layer;
  }
  _getHeatmapInstance(e12) {
    if (null == this._instanceStore || !(e12.drawPhase & F.heatmap.drawPhase)) return null;
    for (const t11 of this._instanceStore.values()) if (f4(t11)) return t11;
    return null;
  }
  get tiles() {
    return this._renderState?.tiles();
  }
  get children() {
    return this._renderState ? Array.from(this._renderState.tiles()).filter(((e12) => this._visibleTiles.has(e12.key.id))) : [];
  }
  updateAttributeView(e12) {
    this.requestRender(), this.attributeView.requestUpdate(e12), this.hasLabels && (this._layerView.view.labelManager.requestUpdate(), this._layerView.view.labelManager.symbolFader.restartDeclutter());
  }
  updateSubscriptions(e12) {
    for (const { tileId: t11, version: s12 } of e12.subscribe) if (this._subscriptions.has(t11)) this._subscriptions.get(t11).version = s12;
    else {
      const e13 = new _2(t11, s12);
      this._subscriptions.set(t11, e13), this.updatingHandles.addPromise(e13.promise);
    }
    for (const t11 of e12.unsubscribe) {
      const e13 = this._subscriptions.get(t11);
      e13?.destroy(), this._subscriptions.delete(t11), this.removeTile(t11);
    }
  }
  isDone(e12) {
    return !!this._renderState && this._renderState.isTileDone(e12);
  }
  async updateRenderState(e12) {
    has("esri-2d-update-debug") && console.debug(`Version[${e12}] FeatureContainer.updateRenderState`), this._renderStateNext = new l5((() => this._stage), ((e13) => this._subscriptions.get(e13)?.version), e12, this.layerView.view.labelManager.symbolFader, this, this.tileInfoView);
  }
  getDisplayStatistics(e12, t11) {
    const s12 = this._statisticsByLevel.get(e12);
    return s12 ? s12.get(t11) : null;
  }
  updateStatistics(e12, t11) {
    if (this._lockStatisticUpdates) return void this._updateStatisticsRequests.push({ level: e12, statistics: t11 });
    let s12 = this._statisticsByLevel.get(e12);
    s12 || (s12 = /* @__PURE__ */ new Map(), this._statisticsByLevel.set(e12, s12));
    for (const r12 of t11) s12.set(r12.fieldName, { minValue: r12.minValue, maxValue: r12.maxValue });
  }
  lockForOverrides() {
    this._renderState?.lockUploads(), this._lockStatisticUpdates = true, this.attributeView.locked || (this.attributeView.lockTextureUploads(), this._shouldUnlockAttributeView = true);
  }
  unlockForOverrides() {
    this._renderState?.unlockUploads(), this._shouldUnlockAttributeView && (this.attributeView.unlockTextureUploads(), this._shouldUnlockAttributeView = false), this._lockStatisticUpdates = false;
    for (const e12 of this._updateStatisticsRequests) this.updateStatistics(e12.level, e12.statistics);
    this._updateStatisticsRequests = [], this._renderState?.flush(), this.requestRender();
  }
  trySwapRenderState() {
    if (this._renderStateNext) {
      has("esri-2d-update-debug") && console.debug(`Version[${this._renderStateNext.version}] FeatureContainer.update.swapRenderState`);
      const e12 = /* @__PURE__ */ new Map();
      for (const t11 of this._renderState?.tiles() || []) e12.set(t11.id, t11.metricsVisibility);
      this._renderState?.destroy(), this._renderState = this._renderStateNext, this._renderState.flush();
      for (const t11 of this._renderState.tiles()) t11.copyMetricsVisibility(e12.get(t11.id) || /* @__PURE__ */ new Set());
      this._renderStateNext = null;
    }
    this.requestRender();
  }
  setVisibleTiles(e12) {
    this._visibleTiles = e12;
    for (const t11 of this.tiles ?? []) t11.rendering = e12.has(t11.key.id);
  }
  async onMessage(e12, s12) {
    s2(s12);
    const r12 = e12.inner;
    if (!this._subscriptions.has(r12.id)) return;
    const i13 = this._subscriptions.get(r12.id);
    if (i13.version !== r12.subscriptionVesrion) {
      if (has("esri-2d-update-debug")) {
        const e13 = `${r12.subscriptionVesrion} != ${i13.version}`;
        console.debug(`Version[${e13}] Tile[${r12.id}] FeatureContainer - Dropping message, outdated version]`, r12);
      }
      return;
    }
    const n16 = this._renderStateNext ?? this._renderState;
    if (!n16) throw new Error("InternalError: No renderState defined");
    n16.version !== r12.version && console.error(`InternalError: Version mismatch. [renderState: ${n16.version}, message: ${r12.version}]`), n16.enqueueUpdate(e12), this.requestRender(), this._layerView.view.labelManager.requestUpdate(), this._layerView.requestUpdate();
  }
  removeTile(e12) {
    (this._renderState || this._renderStateNext) && (this._renderState && this._renderState.removeTile(e12), this._renderStateNext && this._renderStateNext.removeTile(e12));
  }
  hitTest(e12) {
    let t11 = this._hitTestsRequests.find((({ x: t12, y: s12 }) => t12 === e12.x && s12 === e12.y));
    const r12 = L2();
    return t11 ? t11.resolvers.push(r12) : (t11 = { x: e12.x, y: e12.y, resolvers: [r12] }, this._hitTestsRequests.push(t11)), this.requestRender(), r12.promise;
  }
  getSortKeys(e12) {
    const t11 = new Set(e12), s12 = /* @__PURE__ */ new Map();
    for (const r12 of this.children) if (r12.getSortKeys(t11).forEach(((e13, t12) => s12.set(t12, e13))), s12.size === t11.size) break;
    return s12;
  }
  get hasAnimation() {
    return this.hasLabels;
  }
  doRender(e12) {
    const { minScale: t11, maxScale: s12 } = this._layer.effectiveScaleRange, r12 = e12.state.scale;
    r12 <= (t11 || 1 / 0) && r12 >= s12 && super.doRender(e12);
  }
  afterRender(e12) {
    super.afterRender(e12), this._hitTestsRequests.length && this.requestRender();
  }
  setStencilReference(e12) {
    if (null == this._getHeatmapInstance(e12)) super.setStencilReference(e12);
    else for (const t11 of this.children) t11.stencilRef = F.heatmap.getStencilReference(t11);
  }
  _renderMapPhase(e12) {
    this._layerView.featureEffectView.hasEffects ? (this._renderOutsideEffect(e12), this._renderInsideEffect(e12)) : this._renderFeatures(e12, R2.All), this._hitTestsRequests.length > 0 && this._renderHittest(e12);
  }
  _renderHighlightPhase(e12) {
    this.hasHighlight && h3(e12, false, ((e13) => {
      this._renderFeatures(e13, R2.Highlight);
    }));
  }
  _renderLabelPhase(e12) {
    this._renderFeatures(e12, R2.All);
  }
  _renderInsideEffect(e12) {
    const t11 = e12.painter.effects.insideEffect;
    t11.bind(e12), this._renderFeatures(e12, R2.InsideEffect), t11.draw(e12, this._layerView.featureEffectView.includedEffects), t11.unbind();
  }
  _renderOutsideEffect(e12) {
    const t11 = e12.painter.effects.outsideEffect;
    t11.bind(e12), this._renderFeatures(e12, R2.OutsideEffect), t11.draw(e12, this._layerView.featureEffectView.excludedEffects), t11.unbind();
  }
  _renderHittest(e12) {
    const { context: t11 } = e12, s12 = e12.painter.effects.hittest, r12 = t11.getBoundFramebufferObject(), i13 = t11.getViewport(), o17 = e12.passOptions, h4 = e12.drawPhase;
    s12.bind(e12), e12.passOptions = s12.createOptions(e12, this._hitTestsRequests), e12.drawPhase = E.HITTEST;
    const { distance: d9, smallSymbolDistance: l10 } = e12.passOptions, u18 = Math.max(d9, l10);
    for (const n16 of this.children) n16.visible && n16.containsScreenPoint(e12.state, e12.passOptions.position, 2 * u18) && this._renderTile(n16, e12, R2.All);
    s12.draw(e12), s12.unbind(), t11.bindFramebuffer(r12), t11.restoreViewport(i13), e12.passOptions = o17, e12.drawPhase = h4;
  }
  _renderFeatures(e12, t11) {
    const s12 = this._getHeatmapInstance(e12);
    null != s12 ? this._renderHeatmapFeatures(e12, t11, s12) : this._renderGeometryFeatures(e12, t11);
  }
  _renderGeometryFeatures(e12, t11) {
    for (const s12 of this.children) s12.visible && this._renderTile(s12, e12, t11);
  }
  _renderHeatmapFeatures(e12, t11, s12) {
    for (const r12 of this.children) r12.visible && this._renderTile(r12, e12, t11, e4.Heatmap);
    s12.techniqueRef.renderResolvePass(e12, s12);
  }
  _renderTile(e12, t11, s12, r12) {
    const i13 = has("featurelayer-strict-draw-order") ? N.STRICT_ORDER : has("featurelayer-force-marker-text-draw-order") ? N.STRICT_MARKERS_AND_TEXT : N.BATCHING, n16 = e12.getDisplayList(this._instanceStore, i13);
    t11.selection = s12, n16?.render(t11, r12);
  }
};
function f4(e12) {
  return e12.techniqueRef.type === e4.Heatmap;
}

// node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorkerProxy.js
async function t5(t11) {
  const o17 = await p2("FeaturePipelineWorker", { client: t11, strategy: "dedicated" });
  return new n6(o17);
}
var n6 = class {
  constructor(e12) {
    this._connection = e12, this.pipeline = this._connection.createInvokeProxy(), this.features = this._connection.createInvokeProxy("features"), this.aggregates = this._connection.createInvokeProxy("aggregates"), this.streamMessenger = this._connection.createInvokeProxy("streamMessenger");
  }
  destroy() {
    this._connection.destroy();
  }
  get closed() {
    return this._connection.closed;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureSourceEventLog.js
var n7 = 10;
var l6 = class extends b2 {
  constructor() {
    super(...arguments), this.events = new o(), this._updatingStrategy = true, this._tileToEvent = new s3(), this._fetchStatus = { outstanding: 0, done: 0 };
  }
  get hasAllData() {
    return !this._updatingStrategy && this._hasAllTileData();
  }
  get willQueryAllFeatures() {
    return this._strategyInfo?.willQueryAllFeatures ?? false;
  }
  get willQueryFullResolutionGeometry() {
    return this._strategyInfo?.willQueryAllFeatures ?? false;
  }
  onEvent(t11) {
    switch (t11.type) {
      case "subscribe":
      case "unsubscribe":
      case "loaded":
      case "error":
        this._handleTileEvent(t11);
        break;
      case "updateStrategyStart":
        this._updatingStrategy = true, this._fetchStatus = { done: 0, outstanding: 0 }, this._strategyInfo = t11.about;
        break;
      case "updateStrategyEnd":
        this._updatingStrategy = false;
        break;
      case "updateFieldsStart":
        this._fetchStatus = { done: 0, outstanding: 0 };
        break;
      case "updateFieldsEnd":
        break;
      case "updateFieldsError":
        this.events.emit("error", t11);
        break;
      case "fetchStart":
        this._fetchStatus.outstanding += 1, this.events.emit("status", this._fetchStatus);
        break;
      case "fetchEnd":
        this._fetchStatus.done += 1, this.events.emit("status", this._fetchStatus), t11.done && (this._fetchStatus = { done: 0, outstanding: 0 });
    }
  }
  _hasAllTileData() {
    for (const t11 of this._tileToEvent.values()) {
      const e12 = t11.peekLast();
      if ("loaded" !== e12?.type) return false;
    }
    return true;
  }
  _handleTileEvent(t11) {
    switch (t11.type) {
      case "subscribe": {
        const e12 = new t2(n7);
        e12.enqueue(t11), this._tileToEvent.set(t11.tile, e12);
        break;
      }
      case "unsubscribe":
        this._tileToEvent.delete(t11.tile);
        break;
      case "loaded": {
        const e12 = this._tileToEvent.get(t11.tile);
        if (!e12) return;
        e12.enqueue(t11), this._tileToEvent.set(t11.tile, e12);
        break;
      }
      case "error": {
        const e12 = this._tileToEvent.get(t11.tile);
        if (!e12) return;
        e12.enqueue(t11), this._tileToEvent.set(t11.tile, e12), this.events.emit("error", t11);
        break;
      }
    }
  }
};
r([m({ readOnly: true })], l6.prototype, "hasAllData", null), r([m()], l6.prototype, "willQueryAllFeatures", null), r([m()], l6.prototype, "willQueryFullResolutionGeometry", null), r([m()], l6.prototype, "_updatingStrategy", void 0), r([m()], l6.prototype, "_strategyInfo", void 0), r([m()], l6.prototype, "_tileToEvent", void 0), l6 = r([a2("esri.views.2d.layers.features.FeatureSourceEventLog")], l6);

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/geometryUtils.js
function e7(e12) {
  switch (e12.geometryType) {
    case "point":
      return "esriGeometryPoint";
    case "polyline":
      return "esriGeometryPolyline";
    case "mesh":
    case "polygon":
      return "esriGeometryPolygon";
    case "multipatch":
      return "esriGeometryMultiPatch";
    case "multipoint":
      return "esriGeometryMultipoint";
    default:
      return null;
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/featureReductionUtils.js
function e8(e12, a12) {
  const c9 = e12.featureReduction;
  return c9 && "selection" !== c9.type && (!("maxScale" in c9) || !c9.maxScale || c9.maxScale < a12.scale) ? c9 : null;
}

// node_modules/@arcgis/core/views/2d/layers/support/visualVariableSimpleUtils.js
var r7 = Math.PI;
function i9(e12, t11) {
  switch (t11.transformationType) {
    case i4.Additive:
      return s8(e12, t11);
    case i4.Constant:
      return o9(t11, e12);
    case i4.ClampedLinear:
      return u10(e12, t11);
    case i4.Proportional:
      return l7(e12, t11);
    case i4.Stops:
      return c5(e12, t11);
    case i4.RealWorldSize:
      return m7(e12, t11);
    case i4.Identity:
      return e12;
    case i4.Unknown:
      return null;
  }
}
function a8(e12, t11) {
  return "number" == typeof e12 ? e12 : i9(t11, e12);
}
function s8(e12, t11) {
  return e12 + (a8(t11.minSize, e12) || t11.minDataValue);
}
function o9(e12, t11) {
  const n16 = e12.stops;
  let r12 = n16?.length && n16[0].size;
  return null == r12 && (r12 = e12.minSize), a8(r12, t11);
}
function u10(e12, t11) {
  const n16 = t11.minDataValue, r12 = t11.maxDataValue, i13 = (e12 - n16) / (r12 - n16), s12 = a8(t11.minSize, e12), o17 = a8(t11.maxSize, e12);
  return e12 <= n16 ? s12 : e12 >= r12 ? o17 : s12 + i13 * (o17 - s12);
}
function l7(t11, n16) {
  const r12 = t11 / n16.minDataValue, i13 = a8(n16.minSize, t11), s12 = a8(n16.maxSize, t11);
  let o17 = null;
  return o17 = r12 * i13, r2(o17, i13, s12);
}
function c5(e12, t11) {
  const [n16, r12, i13] = p7(e12, t11.cache.ipData);
  if (n16 === r12) return a8(t11.stops[n16].size, e12);
  {
    const s12 = a8(t11.stops[n16].size, e12);
    return s12 + (a8(t11.stops[r12].size, e12) - s12) * i13;
  }
}
function m7(n16, i13) {
  const s12 = m3[i13.valueUnit], o17 = a8(i13.minSize, n16), u18 = a8(i13.maxSize, n16), { valueRepresentation: l10 } = i13;
  let c9 = null;
  return c9 = "area" === l10 ? 2 * Math.sqrt(n16 / r7) / s12 : "radius" === l10 || "distance" === l10 ? 2 * n16 / s12 : n16 / s12, r2(c9, o17, u18);
}
function p7(e12, t11) {
  if (!t11) return;
  let n16 = 0, r12 = t11.length - 1;
  return t11.some(((t12, i13) => e12 < t12 ? (r12 = i13, true) : (n16 = i13, false))), [n16, r12, (e12 - t11[n16]) / (t11[r12] - t11[n16])];
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/labelingUtils.js
function l8(n16) {
  return (n16.labelsVisible && n16.labelingInfo?.every(((n17) => "none" !== n17.deconflictionStrategy))) ?? false;
}
function r8(n16, i13) {
  const l10 = e8(n16, i13);
  if (l10?.labelsVisible && l10.labelingInfo?.length) return l10.labelingInfo.every(((n17) => "none" !== n17.deconflictionStrategy));
}
function t6(e12) {
  return (l10) => u4(i9(l10, e12));
}
function o10(n16) {
  const e12 = null != n16 && "visualVariables" in n16 && n16.visualVariables;
  if (!e12) return null;
  for (const i13 of e12) if ("size" === i13.type) return t6(i13);
  return null;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/SourceSchema.js
function t7(t11, i13, s12, o17) {
  const l10 = null != t11.subtypeCode ? `${t11.subtypeField} = ${t11.subtypeCode}` : null, n16 = r3(t11.definitionExpression, l10), r12 = t11.customParameters ?? {}, a12 = i13.displayFilterEnabled && t11.displayFilterInfo ? t11.displayFilterInfo.toJSON() : null;
  return o17 && (r12.token = o17), { type: "feature", mutable: { sourceRefreshVersion: s12, availableFields: i13.availableFields, displayFilterInfo: a12, dataFilter: { definitionExpression: n16, customParameters: r12, gdbVersion: t11.gdbVersion, historicMoment: t11.historicMoment?.getTime(), queryScaleRanges: t11.queryScaleRanges ?? [], timeExtent: t11.timeExtent?.toJSON() } } };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/color.js
function u11(n16, r12, t11 = 0) {
  if (null == r12) return n16[t11] = 0, n16[t11 + 1] = 0, n16[t11 + 2] = 0, void (n16[t11 + 3] = 0);
  const { r: o17, g: u18, b: i13, a: c9 } = r12;
  n16[t11] = o17 * c9 / 255, n16[t11 + 1] = u18 * c9 / 255, n16[t11 + 2] = i13 * c9 / 255, n16[t11 + 3] = c9;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/symbols/SymbolSchema.js
async function g3(i13, a12) {
  if (!i13) return [];
  switch (i13.type) {
    case "simple-fill":
      return j2(i13, a12);
    case "picture-fill":
      return F2(i13, a12);
    case "simple-marker":
      return w3(i13, a12);
    case "picture-marker":
      return A(i13, a12);
    case "simple-line":
      return P2(i13, a12, false);
    case "text":
      return L4(i13, a12);
    case "label":
      return R5(i13, a12);
    case "cim":
      return u8(i13.data, a12);
    case "web-style":
      return g3(await i13.fetchSymbol({ acceptedFormats: ["cim", "web"] }), a12);
    case "line-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i13.type}" unsupported in MapView. Defaulting to simple-line`), P2(new m4(), a12, false);
    case "point-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i13.type}" unsupported in MapView. Defaulting to simple-marker`), w3(new u6(), a12);
    case "polygon-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i13.type}" unsupported in MapView. Defaulting to simple-fill`), j2(new m5(), a12);
    case "mesh-3d":
    case "label-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i13.type}" unsupported in MapView. Ignoring`), [];
    case "CIMSymbolReference":
      throw new Error("InternalError: CIMSymbolReference should already be resolved");
  }
}
async function M2(e12, i13) {
  const { schemaOptions: a12 } = i13, { store: r12 } = a12, t11 = new Array(s4), o17 = new Array(s4 / 4);
  for (let l10 = 0; l10 < s4; l10++) {
    const i14 = l10 < e12.attributes.length ? e12.attributes[l10].color : null;
    t11[l10] = [0, 0, 0, 0], u11(t11[l10], i14);
  }
  for (let l10 = 0; l10 < s4 / 4; l10++) o17[l10] = [0, 0, 0, 0], o17[l10][0] = 4 * l10 < e12.attributes.length ? 1 : 0, o17[l10][1] = 4 * l10 + 1 < e12.attributes.length ? 1 : 0, o17[l10][2] = 4 * l10 + 2 < e12.attributes.length ? 1 : 0, o17[l10][3] = 4 * l10 + 3 < e12.attributes.length ? 1 : 0;
  const s12 = { uniforms: { isActive: o17, colors: t11, dotValue: e12.dotValue, dotScale: e12.referenceScale, blending: e12.dotBlendingEnabled, dotSize: e12.dotSize, seed: e12.seed }, optionalAttributes: {} }, n16 = r12.ensureInstance(F.dotDensity, s12).createMeshInfo({ effects: null }), u18 = [], c9 = new m5({ color: e12.backgroundColor ?? [0, 0, 0, 0], outline: null }), p12 = await g3(c9, i13);
  if (u18.push(...p12), u18.push(n16), e12.outline) {
    const a13 = P2(e12.outline, i13, true);
    u18.push(...a13);
  }
  return u18;
}
async function C(e12, l10) {
  const { store: r12 } = l10, { radius: t11, minDensity: o17, maxDensity: s12, referenceScale: n16, field: u18, valueExpression: c9, colorStops: p12 } = e12, f7 = f3(p12);
  return [r12.ensureInstance(F.heatmap, { uniforms: { radius: u4(t11), minDensity: o17, maxDensity: s12, referenceScale: n16, isFieldActive: !(!u18 && !c9), gradient: f7, gradientHash: f7.join(",") }, optionalAttributes: {} }).createMeshInfo({ effects: null })];
}
async function x3(e12, a12) {
  const { store: l10 } = a12, r12 = e12.outline?.width || 0, t11 = y(e12), o17 = l10.ensureInstance(F.pieChart, { uniforms: { shader: { outlineWidth: Math.round(u4(r12)), defaultColor: t4(e12.defaultColor), outlineColor: t4(e12.outline?.color), othersColor: t4(e12.othersCategory?.color), donutRatio: e12.holePercentage, sectorThreshold: e12.othersCategory?.threshold || 0, colors: e12.attributes.map(((e13) => t4(e13.color))), visualVariableOpacity: t11.visualVariableOpacity, visualVariableSizeMinMaxValue: t11.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: t11.visualVariableSizeScaleStops, visualVariableSizeStops: t11.visualVariableSizeStops, visualVariableSizeUnitValue: t11.visualVariableSizeUnitValue, hittestUniforms: null, highlightUniforms: null }, numberOfFields: e12.attributes.length }, optionalAttributes: {} }).createMeshInfo({ size: e12.size, outlineWidth: r12, effects: null, scaleInfo: null, minPixelBuffer: x2(t11) });
  return [...e12.backgroundFillSymbol ? await j2(e12.backgroundFillSymbol, { schemaOptions: a12, uniforms: z2 }) : [], o17];
}
function I2(e12) {
  if ("path" === e12.style) {
    if (null == e12.path) throw new Error("Symbol with a style of type path must define a path");
    return { type: "sprite-rasterization-param", overrides: [], resource: { type: "path", path: e12.path, asFill: true } };
  }
  const i13 = te.fromSimpleMarker(e12);
  if ("outline" in e12 && e12.outline && "none" !== e12.outline.style) {
    if ("solid" !== e12.outline.style) {
      if (!i13 || !i13.symbolLayers) throw new Error("Error handling marker! ");
      return { type: "sprite-rasterization-param", resource: i13.symbolLayers[0], overrides: [] };
    }
  }
  return { type: "sprite-rasterization-param", resource: a4(i13), overrides: [] };
}
async function w3(e12, i13) {
  const { uniforms: a12, schemaOptions: l10 } = i13, { store: r12 } = l10;
  if ("path" === e12.style || e12.outline && "solid" !== e12.outline.style && "none" !== e12.outline.style) {
    const l11 = te.fromSimpleMarker(e12);
    if (!l11 || !l11.symbolLayers) throw new Error("Error handling marker! ");
    if (a12.visualVariableRotation && (l11.angleAlignment = "Map"), "path" !== e12.style) {
      const e13 = l11.symbolLayers[0];
      if (e6(i13.uniforms)) {
        const a13 = x2(i13.uniforms, 0, 1);
        if (a13 > e13.size) {
          const i14 = a13 / e13.size;
          e13.size = a13;
          const l12 = e13.markerGraphics?.[0].symbol;
          (l12.symbolLayers && l12.symbolLayers[0]).width *= i14;
        }
      }
    }
    return u8({ type: "CIMSymbolReference", symbol: l11 }, i13);
  }
  const t11 = r12.ensureInstance(F.marker, { uniforms: { visualVariableColor: a12.visualVariableColor, visualVariableOpacity: a12.visualVariableOpacity, visualVariableSizeMinMaxValue: a12.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a12.visualVariableSizeScaleStops, visualVariableSizeStops: a12.visualVariableSizeStops, visualVariableSizeUnitValue: a12.visualVariableSizeUnitValue, visualVariableRotation: a12.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), s12 = I2(e12);
  let u18 = e12.color?.toArray() ?? [0, 0, 0, 0];
  "CIMVectorMarker" === s12.resource.type && (u18 = [255, 255, 255, 255]);
  const c9 = "triangle" === e12.style ? 124 / 116 : 1, p12 = e12.size, f7 = p12 * c9, b4 = null != a12.visualVariableColor && ("cross" === e12.style || "x" === e12.style);
  return [t11.createMeshInfo({ type: "simple", color: u18, height: p12, width: f7, offsetX: e12.xoffset, offsetY: e12.yoffset, angle: e12.angle, alignment: a6(a12) ? i3.MAP : i3.SCREEN, outlineColor: e12.outline?.color?.toArray() ?? [0, 0, 0, 0], outlineSize: e12.outline?.width ?? 1, referenceSize: p12, sprite: s12, overrideOutlineColor: b4, hasSizeVV: e6(a12), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: x2(a12) })];
}
function A(e12, i13) {
  const { uniforms: a12, schemaOptions: l10 } = i13, { store: r12 } = l10, t11 = r12.ensureInstance(F.marker, { uniforms: { visualVariableColor: a12.visualVariableColor, visualVariableOpacity: a12.visualVariableOpacity, visualVariableSizeMinMaxValue: a12.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a12.visualVariableSizeScaleStops, visualVariableSizeStops: a12.visualVariableSizeStops, visualVariableSizeUnitValue: a12.visualVariableSizeUnitValue, visualVariableRotation: a12.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), s12 = te.createPictureMarkerRasterizationParam(e12);
  if (!s12) return [];
  return [t11.createMeshInfo({ type: "picture", color: [255, 255, 255, 255], height: e12.height, width: e12.width, offsetX: e12.xoffset, offsetY: e12.yoffset, angle: e12.angle, alignment: a6(a12) ? i3.MAP : i3.SCREEN, outlineColor: null, outlineSize: 0, referenceSize: e12.height, sprite: s12, overrideOutlineColor: false, hasSizeVV: e6(a12), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: x2(a12) })];
}
function O(e12, i13, a12) {
  const { uniforms: l10, schemaOptions: r12 } = a12, { store: t11 } = r12, o17 = t11.ensureInstance(F.marker, { uniforms: { visualVariableColor: l10.visualVariableColor, visualVariableOpacity: l10.visualVariableOpacity, visualVariableSizeMinMaxValue: l10.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: l10.visualVariableSizeScaleStops, visualVariableSizeStops: l10.visualVariableSizeStops, visualVariableSizeUnitValue: l10.visualVariableSizeUnitValue, visualVariableRotation: l10.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), s12 = I2(e12), c9 = 6, p12 = c9 * i13.width, f7 = p12, b4 = e12.color?.toArray() ?? i13.color?.toArray() ?? [0, 0, 0, 0], S3 = "cross" === e12.style || "x" === e12.style;
  let V2;
  switch (e12.placement) {
    case "begin-end":
      V2 = o4.Both;
      break;
    case "begin":
      V2 = o4.JustBegin;
      break;
    case "end":
      V2 = o4.JustEnd;
      break;
    default:
      V2 = o4.None;
  }
  const v = { type: "cim-marker-placement-param", placement: { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: V2, offsetAlongLine: 0 }, overrides: [] };
  return [o17.createMeshInfo({ type: "simple", color: b4, height: f7, width: p12, offsetX: 0, offsetY: 0, angle: 0, alignment: a6(l10) ? i3.MAP : i3.SCREEN, outlineColor: b4, outlineSize: S3 ? i13.width : 0, referenceSize: f7 / c9, sprite: s12, overrideOutlineColor: S3 && null != l10.visualVariableColor, hasSizeVV: e6(l10), placement: v, transforms: null, effects: null, scaleInfo: null, minPixelBuffer: x2(l10) })];
}
function L4(e12, i13) {
  const { uniforms: a12, schemaOptions: l10 } = i13, { store: r12 } = l10;
  return [r12.ensureInstance(F.text, { uniforms: { visualVariableColor: a12.visualVariableColor, visualVariableOpacity: a12.visualVariableOpacity, visualVariableRotation: a12.visualVariableRotation, visualVariableSizeMinMaxValue: a12.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a12.visualVariableSizeScaleStops, visualVariableSizeStops: a12.visualVariableSizeStops, visualVariableSizeUnitValue: a12.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: false, clipAngle: false, referenceSymbol: false, visibility: false } }).createMeshInfo({ boxBackgroundColor: e12.backgroundColor?.toArray(), boxBorderLineColor: e12.borderLineColor?.toArray(), boxBorderLineSize: e12.borderLineSize ?? 0, color: e12.color?.toArray() ?? [0, 0, 0, 0], offsetX: e12.xoffset, offsetY: e12.yoffset, postAngle: e12.angle, fontSize: e12.font.size, decoration: e12.font.decoration, haloColor: e12.haloColor?.toArray() ?? [0, 0, 0, 0], haloSize: e12.haloSize ?? 0, outlineColor: [0, 0, 0, 0], outlineSize: 0, lineWidth: e12.lineWidth, lineHeightRatio: e12.lineHeight, horizontalAlignment: e12.horizontalAlignment, verticalAlignment: e12.verticalAlignment, useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: e12.font.toJSON(), textString: e12.text, symbol: te.createCIMTextSymbolfromTextSymbol(e12) }, overrides: [] }, referenceSize: null, effects: null, placement: null, scaleInfo: null, transforms: null, scaleFactor: 1, minPixelBuffer: x2(a12), repeatLabel: null, repeatLabelDistance: null, allowOverrun: null, labelPosition: null, labelClassId: -1 })];
}
function R5(e12, a12) {
  const { schemaOptions: l10, uniforms: r12 } = a12, { store: t11 } = l10, s12 = e12.symbol, { allowOverrun: n16, repeatLabel: u18, repeatLabelDistance: c9 } = e12, f7 = { maxScale: e12.maxScale ?? 0, minScale: e12.minScale ?? 0 }, b4 = t11.ensureInstance(F.label, { uniforms: { visualVariableColor: null, visualVariableOpacity: null, visualVariableRotation: r12.visualVariableRotation, visualVariableSizeMinMaxValue: r12.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: r12.visualVariableSizeScaleStops, visualVariableSizeStops: r12.visualVariableSizeStops, visualVariableSizeUnitValue: r12.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: true, clipAngle: true, referenceSymbol: true, visibility: true } }), S3 = e12.labelPlacement, [V2, v] = o5(S3);
  return [b4.createMeshInfo({ boxBackgroundColor: s12.backgroundColor?.toArray(), boxBorderLineColor: s12.borderLineColor?.toArray(), boxBorderLineSize: s12.borderLineSize ?? 0, color: s12.color?.toArray() ?? [0, 0, 0, 0], offsetX: s12.xoffset, offsetY: s12.yoffset, postAngle: s12.angle, fontSize: s12.font.size, decoration: s12.font.decoration, outlineColor: [0, 0, 0, 0], outlineSize: 0, haloColor: s12.haloColor?.toArray() ?? [0, 0, 0, 0], haloSize: s12.haloSize ?? 0, lineWidth: s12.lineWidth, lineHeightRatio: s12.lineHeight, horizontalAlignment: V2, verticalAlignment: v, repeatLabel: u18, repeatLabelDistance: u4(c9), allowOverrun: n16, labelPosition: e12.labelPosition, scaleInfo: f7, minPixelBuffer: x2(r12), useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: s12.font.toJSON(), textString: s12.text, symbol: te.createCIMTextSymbolfromTextSymbol(s12), primitiveName: "label-override" }, useLegacyLabelEvaluationRules: null == e12.labelExpressionInfo?.expression, overrides: [{ valueExpressionInfo: { type: "CIMExpressionInfo", expression: e12.labelExpressionInfo?.expression ?? e12.labelExpression, returnType: "String" }, primitiveName: "label-override", propertyName: "textString", defaultValue: "" }] }, referenceSize: null, effects: null, placement: null, transforms: null, scaleFactor: 1, labelClassId: a12.labelClassId })];
}
function k(e12, i13) {
  const a12 = e12.width;
  return { outlineColor: e12.color?.toArray() || [0, 0, 0, 1], width: a12, referenceWidth: a12, capType: e12.cap ?? "round", joinType: e12.join ?? "round", miterLimit: e12.miterLimit, hasSizeVV: i13, outlineUsesColorVV: false };
}
function U(e12, i13) {
  const { uniforms: a12, schemaOptions: l10 } = i13, { store: r12 } = l10, t11 = e12.color?.toArray() ?? [0, 0, 0, 0], o17 = { type: "sprite-rasterization-param", resource: { type: "fill-style", style: e12.style }, overrides: [] };
  if ("solid" === e12.outline?.style) {
    return [r12.ensureInstance(F.patternOutlineFill, { uniforms: { visualVariableColor: a12.visualVariableColor, visualVariableOpacity: a12.visualVariableOpacity, visualVariableSizeScaleStops: a12.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, ...k(e12.outline, !!a12.visualVariableSizeOutlineScaleStops), sprite: o17, scaleInfo: null, effects: null })];
  }
  const s12 = [], n16 = r12.ensureInstance(F.patternFill, { uniforms: { visualVariableColor: a12.visualVariableColor, visualVariableOpacity: a12.visualVariableOpacity }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: e12.color?.toArray() ?? [0, 0, 0, 0], sprite: o17, scaleInfo: null, effects: null });
  return s12.push(n16), e12.outline && s12.push(...P2(e12.outline, i13, true)), s12;
}
function E3(e12, i13) {
  const { uniforms: a12, schemaOptions: l10 } = i13, { store: r12 } = l10, t11 = e12.color?.toArray() ?? [0, 0, 0, 0];
  if ("none" !== e12.style && "solid" === e12.outline?.style) {
    return [r12.ensureInstance(F.outlineFill, { uniforms: { visualVariableColor: a12.visualVariableColor, visualVariableOpacity: a12.visualVariableOpacity, visualVariableSizeScaleStops: a12.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, ...k(e12.outline, !!a12.visualVariableSizeOutlineScaleStops), scaleInfo: null, effects: null })];
  }
  const o17 = [];
  if ("none" !== e12.style) {
    const e13 = r12.ensureInstance(F.fill, { uniforms: { visualVariableColor: a12.visualVariableColor, visualVariableOpacity: a12.visualVariableOpacity }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, scaleInfo: null, effects: null });
    o17.push(e13);
  }
  return e12.outline && o17.push(...P2(e12.outline, i13, true)), o17;
}
async function j2(e12, i13) {
  if ("cim" === e12.type) return u8(e12.data, i13);
  const { style: a12 } = e12;
  return a12 && "none" !== a12 && "solid" !== a12 ? U(e12, i13) : E3(e12, i13);
}
function F2(e12, i13) {
  const { outline: a12 } = e12, { uniforms: l10, schemaOptions: r12 } = i13, { store: t11 } = r12, s12 = [], n16 = te.createPictureFillRasterizationParam(e12);
  if (!n16) return [];
  const { width: u18, height: c9, xoffset: p12, yoffset: f7, xscale: b4, yscale: S3 } = e12, V2 = { color: [255, 255, 255, 255], sprite: n16, height: c9, aspectRatio: u18 / c9, offsetX: p12, offsetY: f7, scaleX: b4, scaleY: S3, angle: 0, applyRandomOffset: false, sampleAlphaOnly: false, scaleProportionally: false, effects: null, scaleInfo: null };
  if ("solid" === a12?.style) {
    return [t11.ensureInstance(F.complexOutlineFill, { uniforms: { visualVariableColor: l10.visualVariableColor, visualVariableOpacity: l10.visualVariableOpacity, visualVariableSizeScaleStops: l10.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ ...V2, ...k(a12, !!l10.visualVariableSizeOutlineScaleStops) })];
  }
  const y4 = t11.ensureInstance(F.complexFill, { uniforms: { visualVariableColor: l10.visualVariableColor, visualVariableOpacity: l10.visualVariableOpacity }, optionalAttributes: { zoomRange: false } });
  return s12.push(y4.createMeshInfo(V2)), a12 && s12.push(...P2(a12, i13, true)), s12;
}
function P2(e12, i13, a12) {
  const { color: l10, style: r12, width: t11, cap: o17, join: n16 } = e12, { schemaOptions: u18 } = i13, { store: c9 } = u18, p12 = [], f7 = a12 ? { ...z2, visualVariableSizeScaleStops: i13.uniforms.visualVariableSizeOutlineScaleStops } : i13.uniforms, b4 = { uniforms: { visualVariableColor: f7.visualVariableColor, visualVariableOpacity: f7.visualVariableOpacity, visualVariableSizeMinMaxValue: f7.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: f7.visualVariableSizeScaleStops, visualVariableSizeStops: f7.visualVariableSizeStops, visualVariableSizeUnitValue: f7.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: false } }, S3 = { color: l10?.toArray() ?? [0, 0, 0, 0], width: t11, referenceWidth: t11, capType: o17, joinType: n16, miterLimit: e12.miterLimit, hasSizeVV: e6(f7), effects: null, scaleInfo: null };
  if (null == r12 || "solid" === r12) {
    const e13 = c9.ensureInstance(F.line, b4).createMeshInfo(S3);
    p12.push(e13);
  } else if ("none" !== r12) {
    const e13 = c9.ensureInstance(F.texturedLine, b4).createMeshInfo({ ...S3, offsetAlongLine: 0, shouldScaleDash: true, shouldSampleAlphaOnly: false, isSDF: true, sprite: { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: fe(r12, o17) }, overrides: [] } });
    p12.push(e13);
  }
  return null != e12.marker && p12.push(...O(e12.marker, e12, i13)), p12;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/LabelMatcherSchema.js
async function a9(e12, o17, a12) {
  const r12 = o17.labelsVisible && o17.labelingInfo || [], i13 = e7(o17), t11 = c(r12, i13);
  return { type: "label", classes: await Promise.all(t11.map(((s12, l10) => n8(e12, s12, o17.labelsVisible, o17.labelingInfoSource, l10, i13, a12)))) };
}
async function n8(s12, l10, a12, n16, r12, i13, t11) {
  const m16 = l(`${n16} ${r12}`), c9 = await g3(l10, { schemaOptions: s12, uniforms: t11, labelClassId: m16 });
  return { maxScale: l10.maxScale, minScale: l10.minScale, deconflictionEnabled: "none" !== l10.deconflictionStrategy && a12, expression: l10.labelExpressionInfo?.expression ?? l10.labelExpression, where: l10.where, meshes: c9, labelClassId: m16, geometryType: i13 };
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/MatcherSchema.js
async function l9(e12, i13) {
  if (!i13) return { type: "simple", meshes: [] };
  switch (i13.type) {
    case "simple":
      return o11(e12, i13);
    case "dot-density":
      return r9(e12, i13);
    case "class-breaks":
      return u12(e12, i13);
    case "unique-value":
      return m9(e12, i13);
    case "dictionary":
      return c6(i13);
    case "heatmap":
      return p8(e12, i13);
    case "pie-chart":
      return f5(e12, i13);
  }
}
async function o11(i13, a12) {
  const n16 = a12.symbols, t11 = n16.length ? n16[0] : null, l10 = y(a12);
  return { type: "simple", meshes: await g3(t11, { schemaOptions: i13, uniforms: l10 }) };
}
async function r9(i13, a12) {
  const n16 = y(a12);
  return { type: "dot-density", meshes: await M2(a12, { schemaOptions: i13, uniforms: n16 }) };
}
async function u12(a12, n16) {
  const t11 = y(n16), l10 = n16.backgroundFillSymbol, o17 = n16.normalizationType, r12 = "log" === o17 ? "esriNormalizeByLog" : "percent-of-total" === o17 ? "esriNormalizeByPercentOfTotal" : "field" === o17 ? "esriNormalizeByField" : null, u18 = n16.classBreakInfos.map((async (e12) => ({ meshes: await g3(e12.symbol, { path: `renderer-stop-${e12.minValue}-${e12.maxValue}`, schemaOptions: a12, uniforms: t11 }), min: e12.minValue, max: e12.maxValue }))), m16 = (await Promise.all(u18)).sort(((e12, i13) => e12.min - i13.min)), c9 = await g3(l10, { schemaOptions: a12, uniforms: { ...z2, visualVariableSizeOutlineScaleStops: t11.visualVariableSizeOutlineScaleStops } }), p12 = await g3(n16.defaultSymbol, { schemaOptions: a12, uniforms: t11 });
  return { type: "interval", field: n16.field, expression: n16.valueExpression, backgroundFill: c9, defaultSymbol: p12, intervals: m16, normalizationField: n16.normalizationField, normalizationTotal: n16.normalizationTotal, normalizationType: r12, isMaxInclusive: n16.isMaxInclusive };
}
async function m9(a12, n16) {
  const t11 = [], l10 = y(n16), o17 = await g3(n16.backgroundFillSymbol, { schemaOptions: a12, uniforms: { ...z2, visualVariableSizeOutlineScaleStops: l10.visualVariableSizeOutlineScaleStops } }), r12 = await g3(n16.defaultSymbol, { schemaOptions: a12, uniforms: l10 });
  for (const e12 of n16.uniqueValueInfos ?? []) {
    const i13 = await g3(e12.symbol, { path: `renderer-unique-value-${e12.value}`, schemaOptions: a12, uniforms: l10 });
    t11.push({ value: "" + e12.value, symbol: i13 });
  }
  return { type: "map", field: n16.field, expression: n16.valueExpression, field2: n16.field2, field3: n16.field3, fieldDelimiter: n16.fieldDelimiter, backgroundFill: o17, defaultSymbol: r12, map: t11 };
}
async function c6(i13) {
  const a12 = y(i13), n16 = await i13.getDictionaryInfo(), s12 = i13.scaleExpression, t11 = null != s12 && "1" !== s12 ? { valueExpressionInfo: { type: "CIMExpressionInfo", expression: i13.scaleExpression, returnType: "Numeric" }, defaultValue: 1 } : void 0;
  return { type: "dictionary", dictionaryInfo: n16, userConfig: i13.config ?? {}, fieldMap: i13.fieldMap ?? {}, scaleExpression: t11, visualVariableUniforms: a12 };
}
async function p8(e12, i13) {
  return { type: "heatmap", meshes: await C(i13, e12) };
}
async function f5(e12, i13) {
  return { type: "pie-chart", meshes: await x3(i13, e12) };
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SimpleProcessorSchema.js
async function o12(e12, r12) {
  const t11 = r12.renderer, n16 = y(t11);
  return { symbology: await l9(e12, t11), labels: await a9(e12, r12, n16) };
}
async function c7(e12, r12, t11, i13) {
  const s12 = t11.featureReduction;
  if (s12) switch (s12.type) {
    case "binning":
      return b3(s12, e12, r12, t11, i13);
    case "cluster":
      return p9(s12, e12, r12, t11, i13);
  }
  if (t11.trackInfo?.enabled) return y2(t11.trackInfo, e12, r12, t11, i13);
  const a12 = m10(t11.orderBy, t11.renderer, t11.objectIdField), l10 = a7(t11.renderer, r12.filters), c9 = await o12(e12, t11), u18 = g4(c9.symbology);
  return { storage: l10, mesh: { properties: { sortKey: a12, timeZone: r12.timeZone, returnMeshObjectId: u18, displayRefreshVersion: i13, currentUser: r12.currentUser }, strategy: { type: "feature" }, factory: c9 }, expressionProperties: { timeExtent: r12.timeExtent?.toJSON() } };
}
function u13(e12, r12) {
  return e12.fields.map(((e13) => ({ ...e13.toJSON(), type: f6(e13, r12) })));
}
function f6(e12, r12) {
  const { onStatisticExpression: t11, onStatisticField: i13, statisticType: s12 } = e12;
  switch (s12) {
    case "min":
    case "max":
    case "avg":
    case "avg_angle":
    case "sum":
    case "count":
      return "esriFieldTypeDouble";
    case "mode": {
      if (t11) {
        const { returnType: e14 } = t11;
        return e14 ? "string" === e14 ? "esriFieldTypeString" : "esriFieldTypeDouble" : "esriFieldTypeString";
      }
      const e13 = r12.find(((e14) => e14.name === i13));
      return e13 ? e13.type : "esriFieldTypeString";
    }
  }
}
async function b3(r12, t11, a12, o17, c9) {
  const f7 = u13(r12, o17.fields), b4 = r12.renderer, p12 = await l9(t11, b4), y4 = a7(b4, [null, null]), m16 = y(b4), d9 = await a9(t11, { geometryType: "polygon", labelingInfoSource: o17.labelingInfoSource + "-binning", labelingInfo: r12.labelingInfo, labelsVisible: r12.labelsVisible }, m16), v = g4(p12), h4 = "geohash" === r12.binType ? { type: "geohash", fixBinLevel: r12.fixedBinLevel ?? 3 } : { type: "grid", size: u4(r12.size), fixedBinLevel: r12.fixedBinLevel };
  return { storage: y4, mesh: { properties: { sortKey: null, timeZone: a12.timeZone, returnMeshObjectId: v, displayRefreshVersion: c9, currentUser: a12.currentUser }, strategy: { type: "binning", fields: f7, index: h4, featureFilter: a12.filters[0] }, factory: { labels: d9, symbology: p12 } }, expressionProperties: { timeExtent: a12.timeExtent?.toJSON() } };
}
async function p9(r12, t11, a12, o17, c9) {
  const f7 = u13(r12, o17.fields), b4 = { type: "cluster", feature: await l9(t11, r12.effectiveFeatureRenderer), cluster: await l9(t11, r12.effectiveClusterRenderer) }, p12 = y(r12.effectiveFeatureRenderer), y4 = { type: "cluster", feature: await a9(t11, o17, p12), cluster: await a9(t11, { geometryType: "point", labelingInfoSource: o17.labelingInfoSource + "-clusters", labelingInfo: r12.labelingInfo, labelsVisible: r12.labelsVisible }, p12) }, m16 = a7(r12.effectiveFeatureRenderer, [null, null]), d9 = g4(b4);
  return { storage: m16, mesh: { properties: { sortKey: null, timeZone: a12.timeZone, displayRefreshVersion: c9, returnMeshObjectId: d9, currentUser: a12.currentUser }, strategy: { type: "cluster", fields: f7, featureFilter: a12.filters[0], clusterRadius: u4(r12.clusterRadius / 2) }, factory: { labels: y4, symbology: b4 } }, expressionProperties: { timeExtent: a12.timeExtent?.toJSON() } };
}
async function y2(e12, r12, t11, n16, o17) {
  const c9 = u13(e12, n16.fields), f7 = { type: "track", previousObservation: await l9(r12, e12.previousObservations.renderer), latestObservation: await l9(r12, e12.latestObservations.renderer), trackLine: await l9(r12, e12.trackLines.renderer) }, b4 = { type: "track", previousObservation: await a9(r12, { geometryType: n16.geometryType, labelingInfoSource: n16.labelingInfoSource + "-track-prev", labelingInfo: e12.previousObservations.labelingInfo, labelsVisible: e12.previousObservations.labelsVisible }, y(e12.previousObservations.renderer)), latestObservation: await a9(r12, { geometryType: n16.geometryType, labelingInfoSource: n16.labelingInfoSource + "-track-latest", labelingInfo: e12.latestObservations.labelingInfo, labelsVisible: e12.latestObservations.labelsVisible }, y(e12.latestObservations.renderer)), trackLine: await a9(r12, { geometryType: "polyline", labelingInfoSource: n16.labelingInfoSource + "-track-line", labelingInfo: e12.trackLines.labelingInfo, labelsVisible: e12.trackLines.labelsVisible }, y(e12.trackLines.renderer)) }, p12 = o7(e12, [null, null]), y4 = g4(f7);
  return { storage: p12, mesh: { properties: { sortKey: null, timeZone: t11.timeZone, returnMeshObjectId: y4, displayRefreshVersion: o17, currentUser: t11.currentUser }, strategy: { type: "track", featureFilter: t11.filters[0], fields: c9, maxDisplayDuration: e12.maxDisplayDuration?.toMilliseconds() ?? 0, maxDisplayObservationsPerTrack: e12.maxDisplayObservationsPerTrack, showLatestObservation: e12.latestObservations.visible, showPreviousObservations: e12.previousObservations.visible, showTrackLine: e12.trackLines.visible, timeField: e12.timeField }, factory: { labels: b4, symbology: f7 } }, expressionProperties: { timeExtent: t11.timeExtent?.toJSON() } };
}
function m10(e12, t11, i13) {
  const s12 = null != t11 && "unique-value" === t11.type && t11.orderByClassesEnabled;
  if ("default" !== e12 || s12 || (e12 = [new n2({ field: i13, order: "descending" })]), "default" !== e12 && e12?.length) {
    e12.length;
    const r12 = e12[0], t12 = "ascending" === r12.order ? "asc" : "desc";
    return r12.field ? { field: r12.field, order: t12 } : r12.valueExpression ? { expression: r12.valueExpression, order: t12 } : null;
  }
  if (s12) {
    return { byRenderer: true, order: "asc" };
  }
  return null;
}
function d6(e12) {
  return e12.techniqueType === e4.AnimatedMarker;
}
function g4(e12) {
  if ("simple" === e12.type && e12.meshes.some(d6)) return true;
  if ("interval" === e12.type) {
    if (e12.intervals.some(((e13) => e13.meshes.some(d6)))) return true;
    if (e12.backgroundFill.some(d6)) return true;
  }
  if ("map" === e12.type) {
    if (e12.map.some(((e13) => e13.symbol.some(d6)))) return true;
    if (e12.backgroundFill.some(d6)) return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/CatalogFootprintLayerAdapter.js
var n9 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const t11 = this.layer, r12 = l8(t11);
    return [{ vvEvaluators: { 0: o10(t11.renderer) }, deconflictionEnabled: r12 }];
  }
  async createServiceOptions(o17) {
    const i13 = this.layer, { capabilities: s12, editingInfo: a12, objectIdField: l10, globalIdField: n16, datesInUnknownTimezone: p12, dateFieldsTimeZone: d9, orderBy: u18, parsedUrl: c9 } = i13, y4 = i13.fieldsIndex.toJSON(), m16 = e7(i13), f7 = i13.timeInfo?.toJSON(), h4 = i13.spatialReference.toJSON(), g5 = a(c9);
    let b4 = l10;
    if (u18?.length) {
      const e12 = !u18[0].valueExpression && u18[0].field;
      e12 && (b4 = e12);
    }
    const I3 = g(g5.path), S3 = o17.spatialReference.toJSON();
    return { type: "feature-service", source: g5, isSourceHosted: I3, orderByFields: b4, outSpatialReference: S3, metadata: { timeReferenceUnknownClient: p12, dateFieldsTimeZone: d9, globalIdField: n16, fieldsIndex: y4, geometryType: m16, featureIdInfo: { type: "object-id", fieldName: l10 }, timeInfo: f7, spatialReference: h4, outSpatialReference: S3, subtypeField: null, subtypes: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: s12.query.maxRecordCount, supportsCompactGeometry: s12.query.supportsCompactGeometry, supportsDefaultSpatialReference: s12.query.supportsDefaultSpatialReference, supportsFormatPBF: s12.query.supportsFormatPBF, supportsMaxRecordCountFactor: s12.query.supportsMaxRecordCountFactor, supportsQuantization: s12.query.supportsQuantization, lastEditDate: a12?.lastEditDate?.getTime(), snapshotInfo: null } };
  }
  createSourceSchema(e12, t11) {
    const { definitionExpression: r12, displayFilterInfo: o17, customParameters: i13, timeExtent: a12, apiKey: l10 } = this.layer;
    return t7({ definitionExpression: r12, displayFilterInfo: o17, customParameters: i13, timeExtent: a12 }, e12, t11, l10);
  }
  createProcessorSchema(e12, t11, r12) {
    const { fields: o17, geometryType: i13, orderBy: s12, objectIdField: l10, renderer: n16, labelingInfo: p12, labelsVisible: d9 } = this.layer, u18 = { featureReduction: null, labelingInfoSource: this.layer.id, fields: o17.map(((e13) => e13.toJSON())), geometryType: i13, labelingInfo: p12, labelsVisible: d9, objectIdField: l10, orderBy: s12 ?? "default", renderer: n16?.clone() };
    return c7(e12, t11, u18, r12);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.apiKey, () => this.layer.customParameters, () => this.layer.definitionExpression, () => this.layer.outFields, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => this.layer.orderBy];
  }
  setGraphicOrigin(e12) {
    e12.origin = { type: "catalog", layer: this.layer };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/featureServiceUtils.js
function e9(e12) {
  const { objectIdField: t11, uniqueIdFields: r12 } = e12;
  return r12?.length ? r12.length >= 2 ? { type: "unique-id-composite", fieldNames: r12 } : { type: "unique-id-simple", fieldName: r12[0] } : { type: "object-id", fieldName: t11 };
}
function t8(e12, t11, s12, a12, l10, u18) {
  const m16 = o13(a12);
  if (!(!!has("featurelayer-snapshot-enabled") && s12?.query.supportsPagination && !s12?.operations.supportsEditing && !t11)) return null;
  const h4 = i10(l10, u18), { min: p12, max: c9 } = m16, y4 = h4 ? c9 : p12, d9 = n10(a12);
  let f7 = has("featurelayer-snapshot-initial-tolerance");
  return "esriGeometryPoint" !== a12 && "esriGeometryMultipoint" !== a12 || (f7 = null), { supportsExceedsLimit: r10(e12, s12), initialTolerance: f7, maxFeatureCount: y4, maxVertexCount: d9 };
}
function r10(e12, t11) {
  return !(!e12 && !has("featurelayer-snapshot-non-hosted-exceedslimit-enabled")) && t11?.operations.supportsExceedsLimitStatistics;
}
function n10(e12) {
  switch (e12) {
    case "esriGeometryPoint":
      return null;
    case "esriGeometryPolyline":
    case "esriGeometryPolygon":
    case "esriGeometryMultiPatch":
    case "esriGeometryMultipoint":
      return has("featurelayer-snapshot-max-vertex-count");
  }
}
function i10(e12, t11) {
  const r12 = t11?.clone().intersection(e12), n16 = null != r12 ? r12.width * r12.height : 0, i13 = t11 ? t11.width * t11.height : 0, o17 = 0 === i13 ? 0 : n16 / i13, s12 = has("featurelayer-snapshot-coverage");
  return !isNaN(o17) && o17 >= s12;
}
function o13(e12) {
  switch (e12) {
    case "esriGeometryMultipoint":
      return { min: has("featurelayer-snapshot-multipoint-min-threshold"), max: has("featurelayer-snapshot-multipoint-max-threshold") };
    case "esriGeometryPoint":
      return { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") };
    case "esriGeometryMultiPatch":
    case "esriGeometryPolygon":
      return { min: has("featurelayer-snapshot-polygon-min-threshold"), max: has("featurelayer-snapshot-polygon-max-threshold") };
    case "esriGeometryPolyline":
      return { min: has("featurelayer-snapshot-polyline-min-threshold"), max: has("featurelayer-snapshot-polyline-max-threshold") };
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/floorFilterUtils.js
function o14(e12, l10) {
  return null != e12.floorInfo && (e12.floorInfo.viewAllLevelIds.length > 0 || l10.floors.length > 0);
}
function r11(e12, o17, r12) {
  const t11 = n11(e12, o17?.where, r12);
  return t11 ? (o17 ??= new d3(), o17.where = t11, o17) : o17;
}
function n11(l10, o17, r12) {
  if (null == l10.floorInfo || !r12.floors?.length) return o17;
  let n16 = r12.floors;
  const { floorField: t11, viewAllLevelIds: f7 } = l10.floorInfo;
  f7.length && (n16 = f7);
  const s12 = n16.filter(((e12) => "" !== e12)).map(((e12) => "'" + e12 + "'"));
  if (s12.push("''"), o17?.includes(t11)) {
    let e12 = new RegExp("AND \\(" + t11 + ".*NULL\\)", "g");
    o17 = o17.replace(e12, ""), e12 = new RegExp("\\(" + t11 + ".*NULL\\)", "g"), o17 = (o17 = o17.replace(e12, "")).replaceAll(/\s+/g, " ").trim();
  }
  let i13 = "(" + t11 + " IN ({ids}) OR " + t11 + " IS NULL)";
  return i13 = i13.replace("{ids}", s12.join(", ")), r3(o17, i13);
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/FeatureLayerAdapter.js
var m11 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const t11 = this.layer, i13 = r8(t11, e12) ?? l8(t11), o17 = e8(t11, e12), s12 = [...t11.labelingInfo || [], ...o17?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o10(t11.renderer) }, deconflictionEnabled: i13, labelingInfo: s12 }];
  }
  async createServiceOptions(r12) {
    const s12 = this.layer, { capabilities: a12, editingInfo: n16, typeIdField: p12, globalIdField: d9, datesInUnknownTimezone: u18, dateFieldsTimeZone: y4, orderBy: c9, subtypeField: m16, refreshInterval: f7 } = s12, h4 = s12.fieldsIndex.toJSON(), b4 = e7(s12), I3 = s12.timeInfo?.toJSON(), g5 = s12.spatialReference.toJSON(), S3 = s12.types?.map(((e12) => e12.toJSON())), F3 = a(this.layer.parsedUrl);
    this.layer.dynamicDataSource && (F3.query = { layer: JSON.stringify({ source: this.layer.dynamicDataSource }) });
    let x4 = this.layer.objectIdField;
    if (c9?.length) {
      const e12 = !c9[0].valueExpression && c9[0].field;
      e12 && (x4 = e12);
    }
    const R6 = g(F3.path), j3 = t8(R6, !(null != n16?.lastEditDate) && f7 > 0, a12, b4, r12.extent, s12.fullExtent), E4 = r12.spatialReference.toJSON();
    return { type: "feature-service", source: F3, isSourceHosted: R6, orderByFields: x4, outSpatialReference: E4, metadata: { typeIdField: p12 ?? void 0, types: S3, timeReferenceUnknownClient: u18, dateFieldsTimeZone: y4, subtypeField: m16, globalIdField: d9, fieldsIndex: h4, geometryType: b4, featureIdInfo: e9(s12), timeInfo: I3, spatialReference: g5, outSpatialReference: E4, subtypes: this.layer.subtypes?.map(((e12) => e12.toJSON())) }, queryMetadata: { maxRecordCount: a12.query.maxRecordCount, supportsCompactGeometry: a12.query.supportsCompactGeometry, supportsDefaultSpatialReference: a12.query.supportsDefaultSpatialReference, supportsFormatPBF: a12.query.supportsFormatPBF, supportsMaxRecordCountFactor: a12.query.supportsMaxRecordCountFactor, supportsQuantization: a12.query.supportsQuantization, lastEditDate: n16?.lastEditDate?.getTime(), snapshotInfo: j3 } };
  }
  createSourceSchema(e12, t11) {
    const { apiKey: r12, definitionExpression: i13, displayFilterInfo: o17, customParameters: s12, gdbVersion: a12, historicMoment: l10, subtypeCode: n16, subtypeField: p12, timeExtent: d9 } = this.layer;
    return t7({ definitionExpression: i13, displayFilterInfo: o17, customParameters: s12, gdbVersion: a12, historicMoment: l10, subtypeCode: n16, subtypeField: p12, timeExtent: d9 }, e12, t11, r12);
  }
  createProcessorSchema(e12, t11, i13) {
    const { fields: o17, renderer: s12, geometryType: a12, labelingInfo: l10, labelsVisible: n16, orderBy: p12, objectIdField: d9, trackInfo: u18 } = this.layer, c9 = { fields: o17.map(((e13) => e13.toJSON())), renderer: s12?.clone(), labelingInfoSource: this.layer.id, featureReduction: e8(this.layer, t11), geometryType: a12, labelingInfo: l10, labelsVisible: n16, objectIdField: d9, orderBy: p12 ?? "default", trackInfo: u18 };
    return c7(e12, t11, c9, i13);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  addFilters(e12, t11) {
    return r11(this.layer, e12, t11);
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.apiKey, () => this.layer.customParameters, () => this.layer.definitionExpression, () => e8(this.layer, e12), () => o14(this.layer, e12) ? e12.floors : null, () => this.layer.gdbVersion, () => this.layer.historicMoment, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => this.layer.orderBy, () => this.layer.outFields, () => this.layer.renderer, () => this.layer.subtypeCode, () => this.layer.trackInfo];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/InMemoryLayerAdapter.js
function u14(t11) {
  if (!("openPorts" in t11)) throw new s("featurelayer:source-not-supported", "source is not supported");
}
var p10 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const r12 = this.layer, l10 = r8(r12, e12) ?? l8(r12), s12 = e8(r12, e12), a12 = [...r12.labelingInfo || [], ...s12?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o10(r12.renderer) }, deconflictionEnabled: l10, labelingInfo: a12 }];
  }
  async createServiceOptions(e12) {
    const t11 = this.layer, { capabilities: o17, objectIdField: i13 } = t11, n16 = t11.fieldsIndex.toJSON(), l10 = e7(t11), s12 = t11.timeInfo?.toJSON(), a12 = t11.spatialReference.toJSON();
    u14(t11.source);
    const p12 = await t11.source.openPorts(), c9 = i13, d9 = e12.spatialReference.toJSON();
    return { type: "memory", source: p12, orderByFields: c9, outSpatialReference: d9, metadata: { fieldsIndex: n16, geometryType: l10, featureIdInfo: { type: "object-id", fieldName: t11.objectIdField }, timeInfo: s12, spatialReference: a12, outSpatialReference: d9, subtypes: null, subtypeField: null, globalIdField: null, typeIdField: null, types: null, timeReferenceUnknownClient: "datesInUnknownTimezone" in t11 ? t11.datesInUnknownTimezone : null, dateFieldsTimeZone: "dateFieldsTimeZone" in t11 ? t11.dateFieldsTimeZone : null }, queryMetadata: { maxRecordCount: o17.query.maxRecordCount, supportsCompactGeometry: o17.query.supportsCompactGeometry, supportsDefaultSpatialReference: o17.query.supportsDefaultSpatialReference, supportsFormatPBF: o17.query.supportsFormatPBF, supportsMaxRecordCountFactor: o17.query.supportsMaxRecordCountFactor, supportsQuantization: o17.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e12, t11) {
    const { definitionExpression: r12, timeExtent: o17, displayFilterInfo: i13 } = this.layer;
    return t7({ customParameters: null, definitionExpression: r12, displayFilterInfo: i13, timeExtent: o17 }, e12, t11, null);
  }
  createProcessorSchema(e12, r12, o17) {
    const { fields: i13, renderer: n16, geometryType: l10, labelingInfo: a12, labelsVisible: u18, orderBy: p12, objectIdField: c9 } = this.layer, d9 = "trackInfo" in this.layer ? this.layer.trackInfo : null, f7 = { fields: i13.map(((e13) => e13.toJSON())), renderer: n16?.clone(), labelingInfoSource: this.layer.id, featureReduction: e8(this.layer, r12), geometryType: l10, labelingInfo: a12, labelsVisible: u18, objectIdField: c9, orderBy: p12 ?? "default", trackInfo: d9 };
    return c7(e12, r12, f7, o17);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.definitionExpression, () => this.layer.displayFilterInfo, () => this.layer.orderBy, () => "outFields" in this.layer ? this.layer.outFields : null, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e8(this.layer, e12), () => "trackInfo" in this.layer ? this.layer.trackInfo : null];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/KnowledgeGraphSublayerAdapter.js
var c8 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const r12 = this.layer, t11 = r8(r12, e12) ?? l8(r12);
    return [{ vvEvaluators: { 0: o10(r12.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(e12) {
    const r12 = this.layer, { capabilities: t11, objectIdField: o17 } = r12, i13 = r12.fieldsIndex.toJSON(), a12 = e7(r12), l10 = r12.spatialReference.toJSON(), n16 = await r12.source.openPorts(), p12 = o17, u18 = e12.spatialReference.toJSON();
    return { type: "memory", source: n16, orderByFields: p12, outSpatialReference: u18, metadata: { fieldsIndex: i13, geometryType: a12, featureIdInfo: { type: "object-id", fieldName: r12.objectIdField }, spatialReference: l10, outSpatialReference: u18, globalIdField: null, subtypeField: null, subtypes: null, timeInfo: r12.timeInfo?.toJSON(), timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: t11.query.maxRecordCount, supportsCompactGeometry: t11.query.supportsCompactGeometry, supportsDefaultSpatialReference: t11.query.supportsDefaultSpatialReference, supportsFormatPBF: t11.query.supportsFormatPBF, supportsMaxRecordCountFactor: t11.query.supportsMaxRecordCountFactor, supportsQuantization: t11.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e12, r12) {
    const { definitionExpression: t11, displayFilterInfo: o17 } = this.layer;
    return t7({ definitionExpression: t11, displayFilterInfo: o17, customParameters: null }, e12, r12, null);
  }
  createProcessorSchema(e12, r12, t11) {
    const { fields: s12, renderer: i13, geometryType: a12, labelingInfo: l10, labelsVisible: n16, objectIdField: u18 } = this.layer, c9 = { fields: s12.map(((e13) => e13.toJSON())), renderer: i13?.clone(), labelingInfoSource: this.layer.id, featureReduction: e8(this.layer, r12), geometryType: a12, labelingInfo: l10, labelsVisible: n16, objectIdField: u18, orderBy: "default" };
    return c7(e12, r12, c9, t11);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.definitionExpression, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e8(this.layer, e12), () => d7(this.layer)];
  }
  hasFilters(e12) {
    return d7(this.layer);
  }
  addFilters(o17, s12) {
    if (d7(this.layer)) {
      const s13 = r3(o17?.where, `${E2}=1`);
      if (!s13) return o17;
      o17 ??= new d3(), o17.where = s13;
    }
    return o17;
  }
};
function d7(e12) {
  return "link-chart" === e12.parentCompositeLayer.type && "hidden" === e12.parentCompositeLayer.linkChart?.linkChartProperties.nonspatialDataDisplay?.mode;
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OGCFeatureLayerAdapter.js
var u15 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const t11 = this.layer, r12 = r8(t11, e12) ?? l8(t11);
    return [{ vvEvaluators: { 0: o10(t11.renderer) }, deconflictionEnabled: r12, labelingInfo: t11.labelingInfo }];
  }
  async createServiceOptions(t11) {
    const o17 = this.layer, { capabilities: a12 } = o17, s12 = o17.fieldsIndex.toJSON(), l10 = e7(o17), i13 = o17.timeInfo?.toJSON(), n16 = o17.spatialReference.toJSON(), u18 = o17.source.getSource(), c9 = this.layer.objectIdField, p12 = a(a12);
    p12.query.maxRecordCount = u18.maxRecordCount;
    const d9 = t11.spatialReference.toJSON();
    return { type: "ogc", source: u18, orderByFields: c9, outSpatialReference: d9, metadata: { fieldsIndex: s12, geometryType: l10, featureIdInfo: { type: "object-id", fieldName: o17.objectIdField }, timeInfo: i13, spatialReference: n16, outSpatialReference: d9, globalIdField: null, subtypeField: null, subtypes: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: p12.query.maxRecordCount, supportsCompactGeometry: p12.query.supportsCompactGeometry, supportsDefaultSpatialReference: p12.query.supportsDefaultSpatialReference, supportsFormatPBF: p12.query.supportsFormatPBF, supportsMaxRecordCountFactor: p12.query.supportsMaxRecordCountFactor, supportsQuantization: p12.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e12, t11) {
    const { customParameters: r12, timeExtent: o17, apiKey: a12 } = this.layer;
    return t7({ customParameters: r12, timeExtent: o17 }, e12, t11, a12);
  }
  createProcessorSchema(e12, r12, o17) {
    const { fields: a12, renderer: s12, geometryType: l10, labelingInfo: n16, labelsVisible: u18, orderBy: c9, objectIdField: p12 } = this.layer, d9 = { fields: a12.map(((e13) => e13.toJSON())), renderer: s12?.clone(), labelingInfoSource: this.layer.id, featureReduction: e8(this.layer, r12), geometryType: l10, labelingInfo: n16, labelsVisible: u18, objectIdField: p12, orderBy: c9 ?? "default" };
    return c7(e12, r12, d9, o17);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.apiKey, () => this.layer.customParameters, () => e8(this.layer, e12), () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => this.layer.orderBy, () => this.layer.renderer];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OrientedImageryLayerAdapter.js
var m12 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const r12 = this.layer, t11 = r8(r12, e12) ?? l8(r12);
    return [{ vvEvaluators: { 0: o10(r12.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(t11) {
    const s12 = this.layer, { capabilities: i13, globalIdField: a12, orderBy: n16, refreshInterval: p12 } = s12, u18 = s12.fieldsIndex.toJSON(), d9 = e7(s12), c9 = s12.timeInfo?.toJSON(), m16 = s12.spatialReference.toJSON(), f7 = a(this.layer.parsedUrl);
    let y4 = this.layer.objectIdField;
    if (n16?.length) {
      const e12 = !n16[0].valueExpression && n16[0].field;
      e12 && (y4 = e12);
    }
    const h4 = p12 > 0, b4 = g(f7.path), I3 = t11.spatialReference.toJSON(), F3 = t8(b4, h4, i13, d9, t11.extent, s12.fullExtent);
    return { type: "feature-service", source: f7, isSourceHosted: b4, orderByFields: y4, outSpatialReference: I3, metadata: { globalIdField: a12, fieldsIndex: u18, geometryType: d9, featureIdInfo: { type: "object-id", fieldName: s12.objectIdField }, timeInfo: c9, spatialReference: m16, outSpatialReference: I3, timeReferenceUnknownClient: s12.datesInUnknownTimezone, dateFieldsTimeZone: s12.dateFieldsTimeZone, subtypeField: null, subtypes: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: i13.query.maxRecordCount, supportsCompactGeometry: i13.query.supportsCompactGeometry, supportsDefaultSpatialReference: i13.query.supportsDefaultSpatialReference, supportsFormatPBF: i13.query.supportsFormatPBF, supportsMaxRecordCountFactor: i13.query.supportsMaxRecordCountFactor, supportsQuantization: i13.query.supportsQuantization, lastEditDate: null, snapshotInfo: F3 } };
  }
  createSourceSchema(e12, r12) {
    const { definitionExpression: t11, displayFilterInfo: o17, customParameters: s12, timeExtent: i13 } = this.layer;
    return t7({ definitionExpression: t11, displayFilterInfo: o17, customParameters: s12, timeExtent: i13 }, e12, r12, null);
  }
  createProcessorSchema(e12, r12, o17) {
    const { fields: s12, renderer: i13, geometryType: l10, labelingInfo: a12, labelsVisible: n16, orderBy: p12, objectIdField: u18 } = this.layer, c9 = { fields: s12.map(((e13) => e13.toJSON())), renderer: i13?.clone(), labelingInfoSource: this.layer.id, featureReduction: e8(this.layer, r12), geometryType: l10, labelingInfo: a12, labelsVisible: n16, objectIdField: u18, orderBy: p12 ?? "default" };
    return c7(e12, r12, c9, o17);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  addFilters(e12, r12) {
    return r11(this.layer, e12, r12);
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.outFields, () => this.layer.orderBy, () => this.layer.definitionExpression, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e8(this.layer, e12), () => this.layer.customParameters, () => o14(this.layer, e12) ? e12.floors : null];
  }
};

// node_modules/@arcgis/core/layers/support/ParquetEncodingLocation.js
var s9 = class extends l3 {
  constructor(o17) {
    super(o17), this.type = "location", this.latitudeFieldName = null, this.longitudeFieldName = null;
  }
};
r([m({ type: ["location"], readOnly: true, json: { write: true } })], s9.prototype, "type", void 0), r([m({ json: { write: true } })], s9.prototype, "latitudeFieldName", void 0), r([m({ json: { write: true } })], s9.prototype, "longitudeFieldName", void 0), s9 = r([a2("esri.layers.support.ParquetEncodingLocation")], s9);

// node_modules/@arcgis/core/layers/support/ParquetEncodingWkb.js
var s10 = class extends l3 {
  constructor(o17) {
    super(o17), this.type = "wkb", this.primaryFieldName = null;
  }
};
r([m({ type: ["wkb"], readOnly: true, json: { write: true } })], s10.prototype, "type", void 0), r([m({ json: { write: true } })], s10.prototype, "multiscale", void 0), r([m({ json: { write: true } })], s10.prototype, "orientation", void 0), r([m({ json: { write: true } })], s10.prototype, "primaryFieldName", void 0), s10 = r([a2("esri.layers.support.ParquetEncodingWkb")], s10);

// node_modules/@arcgis/core/layers/support/parquetUtils.js
var u16 = new o2({ esriGeometryPoint: "point", esriGeometryPolygon: "polygon", esriGeometryPolyline: "polyline", esriGeometryMultipoint: "multipoint" });
function m14(e12) {
  return u16.toJSON(e12);
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/ParquetLayerAdapter.js
var y3 = class {
  constructor(e12) {
    this.layer = e12;
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return null;
  }
  getLabelingDeconflictionInfo(e12) {
    const r12 = this.layer, l10 = r8(r12, e12) ?? l8(r12), o17 = e8(r12, e12), n16 = [...r12.labelingInfo || [], ...o17?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o10(r12.renderer) }, deconflictionEnabled: l10, labelingInfo: n16 }];
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.outFields, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e8(this.layer, e12), () => this.layer.customParameters, () => this.layer.orderBy, () => this.layer.renderer, () => this.layer.popupTemplate];
  }
  async createServiceOptions(t11) {
    const a12 = e7(this.layer), i13 = t11.spatialReference.toJSON(), s12 = this.layer.encoding;
    if (null == s12) throw new s("parquet-layer:unsupported", "creating a parquet layer view requires an encoding", { layer: this.layer });
    return { type: "parquet", source: { urls: this.layer.urls.items }, outSpatialReference: i13, geometryInfo: { geometryType: m14(this.layer.geometryType), spatialReference: this.layer.spatialReference.toJSON(), encoding: s12.toJSON() }, metadata: { spatialReference: this.layer.spatialReference, outSpatialReference: i13, fieldsIndex: this.layer.fieldsIndex.toJSON(), featureIdInfo: { type: "object-id", fieldName: this.layer.objectIdField }, geometryType: a12, types: null, subtypes: null, timeInfo: null, typeIdField: null, subtypeField: null, globalIdField: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null } };
  }
  createSourceSchema(e12, r12) {
    return { type: "parquet", mutable: { sourceRefreshVersion: r12, availableFields: e12.availableFields.includes("*") ? this.layer.fields.map(((e13) => e13.name)) : e12.availableFields, dataFilter: { customParameters: this.layer.customParameters ?? null } } };
  }
  createProcessorSchema(e12, r12, l10) {
    const a12 = { fields: this.layer.fields.map(((e13) => e13.toJSON())), renderer: this.layer.renderer?.clone(), labelingInfoSource: this.layer.id, featureReduction: e8(this.layer, r12), geometryType: this.layer.geometryType, labelingInfo: this.layer.labelingInfo, labelsVisible: this.layer.labelsVisible, objectIdField: this.layer.objectIdField, orderBy: this.layer.orderBy };
    return c7(e12, r12, a12, l10);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/StreamLayerAdapter.js
var a10 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(t11) {
    const n16 = this.layer, o17 = r8(n16, t11) ?? l8(n16), a12 = e8(n16, t11), s12 = [...n16.labelingInfo || [], ...a12?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o10(n16.renderer) }, deconflictionEnabled: o17, labelingInfo: s12 }];
  }
  async createServiceOptions(e12) {
    const r12 = this.layer, i13 = e7(r12), l10 = r12.timeInfo?.toJSON() || null, n16 = r12.spatialReference ? r12.spatialReference.toJSON() : null, o17 = e12.spatialReference.toJSON();
    return { type: "stream", source: this.layer.parsedUrl, outSpatialReference: o17, metadata: { fieldsIndex: this.layer.fieldsIndex.toJSON(), geometryType: i13, featureIdInfo: { type: "object-id", fieldName: this.layer.objectIdField }, timeInfo: l10, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, spatialReference: n16, outSpatialReference: o17, subtypeField: null, subtypes: null, globalIdField: null, typeIdField: null, types: null } };
  }
  createSourceSchema(e12, t11) {
    const { definitionExpression: r12, geometryDefinition: i13, customParameters: l10 } = this.layer;
    return { type: "stream", mutable: { sourceRefreshVersion: t11, availableFields: e12.availableFields, dataFilter: { geometryDefinition: i13?.toJSON(), definitionExpression: r12, customParameters: l10 ?? null, maxReconnectionAttempts: this.layer.maxReconnectionAttempts, maxReconnectionInterval: this.layer.maxReconnectionInterval, purgeOptions: this.layer.purgeOptions.toJSON() } } };
  }
  createProcessorSchema(t11, r12, i13) {
    const { fields: l10, renderer: o17, geometryType: a12, labelingInfo: s12, labelsVisible: c9, objectIdField: d9, trackInfo: f7 } = this.layer, m16 = { fields: l10.map(((e12) => e12.toJSON())), renderer: o17?.clone(), labelingInfoSource: this.layer.id, featureReduction: e8(this.layer, r12), geometryType: a12, labelingInfo: s12, labelsVisible: c9, objectIdField: d9, orderBy: "default", trackInfo: f7 };
    return c7(t11, r12, m16, i13);
  }
  get hasRequiredSupport() {
    return m6(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(t11) {
    return [() => this.layer.definitionExpression, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e8(this.layer, t11), () => this.layer.customParameters, () => this.layer.geometryDefinition, () => this.layer.definitionExpression, () => this.layer.trackInfo];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SubtypeProcessorSchema.js
async function a11(e12, { subtypeField: t11, sublayers: s12 }) {
  const i13 = await Promise.all(s12.map((({ renderer: t12 }) => l9(e12, t12))));
  return { type: "subtype", subtypeField: t11, renderers: s12.reduce(((e13, { subtypeCode: r12 }, t12) => ({ ...e13, [r12]: i13[t12] })), {}) };
}
function n13(e12, r12) {
  const s12 = t3();
  return { type: "multi", filters: e12.filters, capabilities: { maxTextureSize: s12.maxTextureSize }, keyField: r12.subtypeField, target: "feature", bindings: r12.sublayers.reduce(((e13, { renderer: r13, subtypeCode: s13 }) => {
    const i13 = d4(r13);
    return { ...e13, [s13]: i13 };
  }), {}) };
}
async function o16(r12, { subtypeField: t11, sublayers: i13, labelingInfoSource: a12 }) {
  const n16 = await Promise.all(i13.map(((t12) => {
    const i14 = y(t12.renderer), n17 = { ...t12, geometryType: t12.geometryType ?? null, labelingInfoSource: a12 };
    return a9(r12, n17, i14);
  })));
  return { type: "subtype", subtypeField: t11, renderers: i13.reduce(((e12, { subtypeCode: r13 }, t12) => ({ ...e12, [r13]: n16[t12] })), {}) };
}
async function u17(e12, r12, t11, s12) {
  return { storage: n13(r12, t11), mesh: { properties: { timeZone: r12.timeZone, displayRefreshVersion: s12, returnMeshObjectId: false, sortKey: null, currentUser: r12.currentUser }, strategy: { type: "feature" }, factory: { symbology: await a11(e12, t11), labels: await o16(e12, t11) } }, expressionProperties: { timeExtent: r12.timeExtent?.toJSON() } };
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/SubtypeGroupLayerAdapter.js
var m15 = class {
  constructor(e12) {
    this.layer = e12;
  }
  getLabelingDeconflictionInfo(e12) {
    const t11 = this.layer;
    return [{ vvEvaluators: {}, deconflictionEnabled: t11.sublayers.some(((e13) => l8(e13))), labelingInfo: t11.sublayers.toArray().filter(((e13) => !!e13.labelingInfo)).flatMap(((e13) => e13.labelingInfo)) }];
  }
  async createServiceOptions(t11) {
    const r12 = this.layer, { capabilities: a12, datesInUnknownTimezone: o17, dateFieldsTimeZone: n16, editingInfo: p12, globalIdField: c9, objectIdField: y4, refreshInterval: m16, subtypeField: d9 } = r12, f7 = r12.fieldsIndex.toJSON(), b4 = e7(r12), h4 = r12.timeInfo?.toJSON(), S3 = r12.spatialReference.toJSON(), g5 = a(this.layer.parsedUrl), F3 = y4, I3 = !(null != p12?.lastEditDate) && m16 > 0, x4 = g(g5.path), R6 = t11.spatialReference.toJSON(), j3 = t8(x4, I3, a12, b4, t11.extent, r12.fullExtent);
    return { type: "feature-service", source: g5, isSourceHosted: x4, orderByFields: F3, outSpatialReference: R6, metadata: { timeReferenceUnknownClient: o17, dateFieldsTimeZone: n16, subtypeField: d9, globalIdField: c9, fieldsIndex: f7, geometryType: b4, featureIdInfo: e9(this.layer), timeInfo: h4, spatialReference: S3, outSpatialReference: R6, subtypes: this.layer.subtypes?.map(((e12) => e12.toJSON())), typeIdField: null, types: null }, queryMetadata: { maxRecordCount: a12.query.maxRecordCount, supportsCompactGeometry: a12.query.supportsCompactGeometry, supportsDefaultSpatialReference: a12.query.supportsDefaultSpatialReference, supportsFormatPBF: a12.query.supportsFormatPBF, supportsMaxRecordCountFactor: a12.query.supportsMaxRecordCountFactor, supportsQuantization: a12.query.supportsQuantization, lastEditDate: p12?.lastEditDate?.getTime(), snapshotInfo: j3 } };
  }
  createSourceSchema(e12, t11) {
    const { definitionExpression: r12, customParameters: s12, gdbVersion: a12, historicMoment: i13, subtypeField: l10, timeExtent: o17, apiKey: n16, displayFilterInfo: u18 } = this.layer, p12 = { queryScaleRanges: this.layer.sublayers.items.map(((e13) => ({ subtypeCode: e13.subtypeCode, minScale: e13.minScale, maxScale: e13.maxScale }))), definitionExpression: r12, displayFilterInfo: u18, customParameters: s12, gdbVersion: a12, historicMoment: i13, subtypeField: l10, timeExtent: o17 };
    return t7(p12, e12, t11, n16);
  }
  createProcessorSchema(e12, t11, r12) {
    const s12 = { labelingInfoSource: this.layer.id, subtypeField: this.layer.subtypeField, sublayers: Array.from(this.layer.sublayers, ((e13, t12) => ({ featureReduction: null, geometryType: this.layer.geometryType, labelingInfoSource: this.layer.id + `-${t12}`, labelingInfo: e13.labelingInfo, labelsVisible: e13.labelsVisible, renderer: e13.renderer, subtypeCode: e13.subtypeCode, orderBy: null }))) };
    return u17(e12, t11, s12, r12);
  }
  addFilters(e12, t11) {
    e12 = r11(this.layer, e12, t11);
    const s12 = this.layer.sublayers.filter(((e13) => !d8(e13, t11))).map(((e13) => e13.subtypeCode));
    if (!s12.length) return e12;
    e12 ??= new d3();
    const i13 = `NOT ${this.layer.subtypeField} IN (${s12.join(",")})`;
    return e12.where = r3(e12.where, i13), e12;
  }
  get hasRequiredSupport() {
    return true;
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e12) {
    return [() => this.layer.apiKey, () => this.layer.customParameters, () => this.layer.definitionExpression, () => o14(this.layer, e12) ? e12.floors : null, () => this.layer.outFields, () => this.layer.gdbVersion, () => this.layer.historicMoment, () => this.layer.sublayers.map((({ renderer: e13, labelsVisible: t11, labelingInfo: r12, visible: s12, minScale: a12, maxScale: i13 }) => ({ renderer: e13, labelsVisible: t11, labelingInfo: r12, visible: s12, minScale: a12, maxScale: i13 })))];
  }
  setGraphicOrigin(e12) {
    const t11 = this.layer.fieldsIndex.get(this.layer.subtypeField), r12 = e12.attributes[t11.name], s12 = this.layer.sublayers.find(((e13) => e13.subtypeCode === r12));
    e12.layer = e12.sourceLayer = s12;
  }
};
function d8(e12, r12) {
  return e12.visible && (0 === e12.minScale || m2(r12.scale, e12.minScale) || r12.scale < e12.minScale) && (0 === e12.maxScale || m2(r12.scale, e12.maxScale) || r12.scale > e12.maxScale);
}

// node_modules/@arcgis/core/views/2d/layers/support/DebouncedFeatureOverride.js
var e10 = class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._historicMoment = null;
  }
  add(e12) {
    switch (e12.type) {
      case "override":
        return this._addOverride(e12);
      case "override-by-id":
        return this._addOverrideById(e12);
    }
  }
  toMessage() {
    const e12 = { historicMoment: this._historicMoment, commands: { updateByIdWeak: [], updateWeak: [], removeWeak: [], update: [], remove: [], release: [] } };
    for (const [s12, r12] of this._commands.entries()) switch (r12.type) {
      case "override-update-by-id":
        e12.commands.updateByIdWeak.push(s12);
        break;
      case "override-update":
        r12.isWeak ? e12.commands.updateWeak.push(r12.feature) : e12.commands.update.push(r12.feature);
        break;
      case "override-remove":
        r12.isWeak ? e12.commands.removeWeak.push(s12) : e12.commands.remove.push(s12);
        break;
      case "override-release":
        e12.commands.release.push(s12);
    }
    return e12;
  }
  _addOverrideById(e12) {
    this._historicMoment = e12.historicMoment;
    for (const s12 of e12.updates) this._commands.set(s12, { type: "override-update-by-id", isWeak: e12.isWeak });
    for (const s12 of e12.removed) this._commands.set(s12, { type: "override-remove", isWeak: e12.isWeak });
  }
  _addOverride(e12) {
    this._historicMoment = e12.historicMoment;
    for (const s12 of e12.updates) this._commands.set(s12.objectId, { type: "override-update", feature: s12, isWeak: e12.isWeak });
    for (const s12 of e12.removed) this._commands.set(s12, { type: "override-remove", isWeak: e12.isWeak });
    for (const s12 of e12.release) this._commands.set(s12, { type: "override-release" });
  }
};

// node_modules/@arcgis/core/views/2d/layers/support/handleNoEngineError.js
async function n14(n16, r12) {
  try {
    return await n16;
  } catch (t11) {
    if ("no-queryEngine" !== t11.name) throw t11;
    return r12;
  }
}

// node_modules/@arcgis/core/views/2d/tiling/FeatureTileSubscriptionManager.js
function e11(s12, e12) {
  const i13 = /* @__PURE__ */ new Set();
  for (const t11 of s12 instanceof Set ? s12.values() : s12.keys()) e12.has(t11) || i13.add(t11);
  return i13;
}
var i12 = class {
  constructor(s12, e12, i13) {
    const t11 = i13 ? s12.getTileCoverage(i13, 0, true, "closest") : null, n16 = s12.getTileCoverage(e12, 0, true, "closest");
    if (this._tileKeys = /* @__PURE__ */ new Map(), t11) for (const o17 of t11.keys()) this._tileKeys.set(o17.id, o17);
    if (n16) for (const o17 of n16.keys()) this._tileKeys.set(o17.id, o17);
  }
  get coverageSet() {
    return new Set(this._tileKeys.keys());
  }
  keys() {
    return this._tileKeys.values();
  }
};
var t9 = class {
  constructor(s12) {
    this.version = s12;
  }
};
var n15 = class {
  constructor(s12) {
    this._subscriptions = /* @__PURE__ */ new Map(), this._visible = /* @__PURE__ */ new Set(), this._paused = /* @__PURE__ */ new Set(), this._version = 0, this._config = s12;
  }
  destroy() {
  }
  get coverageSet() {
    return this._coverage?.coverageSet ?? /* @__PURE__ */ new Set();
  }
  get subscriptions() {
    return new Set(this._subscriptions.keys());
  }
  suspend() {
    this._suspendedOverage = this._coverage, this._coverage = null, this._updateSubscriptions();
  }
  resume() {
    null == this._coverage && (this._coverage = this._suspendedOverage, this._suspendedOverage = null, this._updateSubscriptions());
  }
  update(s12, e12) {
    return this._version = (this._version + 1) % Number.MAX_SAFE_INTEGER, this._updateCoverage(s12, e12), this._updateSubscriptions(), new Set(this._visible);
  }
  updateVisibility() {
    const s12 = this._updateVisibility();
    return this._visible = s12, this._visible;
  }
  _updateCoverage(s12, e12) {
    this._coverage = new i12(this._config.tileInfoView, s12, e12);
  }
  _updateSubscriptions() {
    const s12 = this.coverageSet, i13 = this._updateVisibility(), n16 = e11(i13, s12), o17 = e11(this._subscriptions, i13), r12 = e11(s12, this._subscriptions), a12 = e11(o17, s12), u18 = e11(n16, a12), c9 = e11(u18, this._paused);
    this._visible = i13;
    for (const e12 of r12.values()) this._subscriptions.set(e12, new t9(this._version));
    for (const e12 of c9.values()) this._paused.add(e12);
    for (const e12 of a12.values()) this._subscriptions.delete(e12), this._paused.delete(e12);
    (r12.size || a12.size || c9.size) && this._sendUpdateSubscriptions(r12, a12, c9);
  }
  _sendUpdateSubscriptions(s12, e12, i13) {
    const t11 = Array.from(s12.values()).map(((s13) => ({ tileId: s13, version: this._subscriptions.get(s13).version })));
    this._config.updateSubscriptions({ subscribe: t11, unsubscribe: Array.from(e12.values()), pause: Array.from(i13.values()) });
  }
  _updateVisibility() {
    const s12 = /* @__PURE__ */ new Set(), e12 = /* @__PURE__ */ new Set();
    if (!this._coverage) return s12;
    for (const i13 of this._coverage.keys()) {
      if (this._config.isDone(i13)) {
        s12.add(i13.id);
        continue;
      }
      if (this._addVisibleParent(s12, e12, i13)) continue;
      this._addVisibleChildren(s12, i13) || s12.add(i13.id);
    }
    return s12;
  }
  _addVisibleParent(e12, i13, t11) {
    let n16 = false;
    for (const o17 of this._visible.values()) {
      new e3(o17).containsChild(t11) && (e12.add(o17), i13.add(o17), n16 = true);
    }
    return n16;
  }
  _addVisibleChildren(e12, i13) {
    let t11 = false;
    for (const n16 of this._visible.values()) {
      const o17 = new e3(n16);
      i13.containsChild(o17) && (e12.add(n16), t11 = true);
    }
    return t11;
  }
};

// node_modules/@arcgis/core/networks/support/networkFieldUtils.js
function t10(e12, t11) {
  if ("feature" !== t11.type && "subtype-group" !== t11.type) return [];
  if (!t11.url) return [];
  const o17 = "utilityNetworks" in e12.map ? e12.map.utilityNetworks ?? [] : [];
  for (const n16 of o17) if (n16.isUtilityLayer(t11)) {
    const e13 = t11.fieldsIndex.get("assetgroup"), o18 = t11.fieldsIndex.get("assettype");
    return [e13?.name, o18?.name].filter(((e14) => null != e14));
  }
  return [];
}

// node_modules/@arcgis/core/views/layers/support/WhereClauseVisitor.js
var s11 = class {
  constructor(i13) {
    this._fieldsIndex = i13, this._clauses = [];
  }
  async finish() {
    return { requiresCurrentUser: (await Promise.all(this._clauses)).some(((i13) => i13.currentUserRequired)) };
  }
  visitClientWhereClause(s12) {
    s12 && this._clauses.push(e2(s12, this._fieldsIndex));
  }
  visitFeatureReduction(i13) {
    if (i13) switch (i13.type) {
      case "binning":
      case "cluster":
        this.visitLabelingInfo(i13.labelsVisible, i13.labelingInfo);
    }
  }
  visitLabelingInfo(i13, s12) {
    if (i13 && null != s12) for (const e12 of s12) this.visitClientWhereClause(e12.where);
  }
  visitDisplayFilter(i13, s12) {
    if (i13) for (const e12 of s12?.filters ?? []) this.visitClientWhereClause(e12.where);
  }
  visitFilter(i13) {
    this.visitClientWhereClause(i13?.where);
  }
  visitTrackInfo(i13) {
    null != i13 && (this.visitLabelingInfo(i13?.latestObservations.labelsVisible, i13?.latestObservations.labelingInfo), this.visitLabelingInfo(i13?.previousObservations.labelsVisible, i13?.previousObservations.labelingInfo), this.visitLabelingInfo(i13?.trackLines.labelsVisible, i13?.trackLines.labelingInfo));
  }
};

// node_modules/@arcgis/core/views/layers/FeatureLayerView.js
var S2 = (S3) => {
  let N2 = class extends S3 {
    constructor(...e12) {
      super(...e12), this._updatingRequiredPromise = null, this.filter = null, this.layer = null, this.requiresCurrentUser = false, this.requiredFields = [], this.view = null;
    }
    initialize() {
      this.addHandles([l2((() => {
        const e12 = this.layer, t11 = this.view;
        return [e12 && "elevationInfo" in e12 ? e12.elevationInfo?.featureExpressionInfo : null, e12 && "displayField" in e12 ? e12.displayField : null, e12 && "timeInfo" in e12 && e12.timeInfo, e12 && "renderer" in e12 && e12.renderer, e12 && "labelingInfo" in e12 && e12.labelingInfo, e12 && "floorInfo" in e12 && e12.floorInfo, t11?.requiredFieldsOptions?.featureTitleFields && e12 && "featureTitleFields" in e12 && e12.featureTitleFields, t11?.requiredFieldsOptions?.utilityNetworkFields && t10(t11, e12), e12.displayFilterInfo, this.displayFilterEnabled, this.filter, this.featureEffect, this.timeExtent, "knowledge-graph-sublayer" === e12?.type && "link-chart" === e12.parentCompositeLayer.type && e12.parentCompositeLayer.linkChart?.linkChartProperties.nonspatialDataDisplay?.mode, "parquet" === e12?.type && e12.popupTemplate];
      }), (() => this._handleChange()), w), a3((() => this.view?.floors), "change", (() => this._handleChange())), a3((() => this.layer.displayFilterInfo?.filters), "change", (() => this._handleChange())), a3((() => this.layer && "sublayers" in this.layer ? this.layer.sublayers : null), "change", (() => this._handleChange()))]);
    }
    get availableFields() {
      if (!this.layer) return [];
      const { layer: e12, layer: { fieldsIndex: t11 }, requiredFields: r12 } = this;
      return "outFields" in e12 && e12.outFields ? w2(t11, [...h2(t11, e12.outFields), ...r12]) : w2(t11, r12);
    }
    get displayFilterEnabled() {
      return (this.view?.displayFilterEnabled ?? true) && (!("displayFilterEnabled" in this.layer) || (this.layer?.displayFilterEnabled ?? true));
    }
    get effectiveDisplayFilter() {
      const e12 = this.layer;
      return this.displayFilterEnabled && e12.displayFilterInfo ? u7(e12.displayFilterInfo, this.view) : null;
    }
    get featureEffect() {
      return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null;
    }
    set featureEffect(e12) {
      this._override("featureEffect", e12);
    }
    get maximumNumberOfFeatures() {
      return 0;
    }
    set maximumNumberOfFeatures(e12) {
      i2.getLogger(this).error("#maximumNumberOfFeatures=", "Setting maximum number of features is not supported");
    }
    get maximumNumberOfFeaturesExceeded() {
      return false;
    }
    get signedInUser() {
      return this.layer?.url ? J(this.layer.url) : Promise.resolve(null);
    }
    highlight(e12, t11) {
      throw new Error("missing implementation");
    }
    createQuery() {
      const e12 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference }, t11 = null != this.filter ? this.filter.createQuery(e12) : new R(e12);
      return "floorInfo" in this.layer && this.layer.floorInfo && (t11.where = r3(t11.where, o6(this))), this.displayFilterEnabled && (t11.where = r3(t11.where, this.effectiveDisplayFilter?.where)), null != this.timeExtent && (t11.timeExtent = null != t11.timeExtent ? t11.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()), t11;
    }
    createAggregateQuery() {
      const e12 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
      return new R(e12);
    }
    queryFeatures(e12, t11) {
      throw new Error("missing implementation");
    }
    queryObjectIds(e12, t11) {
      throw new Error("missing implementation");
    }
    queryFeatureCount(e12, t11) {
      throw new Error("missing implementation");
    }
    queryExtent(e12, t11) {
      throw new Error("missing implementation");
    }
    async fetchPopupFeaturesFromGraphics(e12, t11) {
      const r12 = await this._createPopupQuery(e12.map(((e13) => e13.origin?.layer ?? e13.layer)), t11);
      return await s5(this.layer, e12, r12, { getPopupTemplate: (e13) => e13 && "popupEnabled" in e13 && e13.popupEnabled ? p3(e13, t11) : null, hasRequiredFields: (e13, t12) => this._popupFeatureHasRequiredFields(e13, t12), ...t11 });
    }
    _handleChange() {
      const e12 = Promise.all([this._updateRequiredFields(), this._updateClientWhereClauseRequirements()]).then((() => {
      }));
      return this._set("_updatingRequiredPromise", e12), e12.then((() => {
        this._updatingRequiredPromise === e12 && this._set("_updatingRequiredPromise", null);
      })), e12;
    }
    async _updateClientWhereClauseRequirements() {
      if (!this.layer || !this.view) return;
      const { layer: e12 } = this, r12 = new s11(e12.fieldsIndex);
      if (r12.visitFilter(this.filter), "featureReduction" in e12 && r12.visitFeatureReduction(e12.featureReduction), "labelingInfo" in e12 && r12.visitLabelingInfo(e12.labelsVisible, e12.labelingInfo), "trackInfo" in e12 && r12.visitTrackInfo(e12.trackInfo), "2d" === this.view.type && (r12.visitFilter(this.featureEffect?.filter), r12.visitDisplayFilter(this.displayFilterEnabled, e12.displayFilterInfo), "featureReduction" in e12 && r12.visitFeatureReduction(e12.featureReduction)), "subtype-group" === e12.type) for (const t11 of e12.sublayers) r12.visitLabelingInfo(t11.labelsVisible, t11.labelingInfo);
      try {
        const e13 = await r12.finish();
        this._set("requiresCurrentUser", e13.requiresCurrentUser);
      } catch (i13) {
        i2.getLogger(this).error(i13);
      }
    }
    async _updateRequiredFields() {
      if (!this.layer || !this.view) return;
      const e12 = "3d" === this.view.type, { layer: r12, layer: { fieldsIndex: i13 } } = this, l10 = "renderer" in r12 && r12.renderer, s12 = "orderBy" in r12 && r12.orderBy, o17 = "featureReduction" in r12 ? r12.featureReduction : null, n16 = /* @__PURE__ */ new Set(), a12 = [l10 ? l10.collectRequiredFields(n16, i13) : null, Q(n16, r12), e12 && "elevationInfo" in r12 ? L3(n16, r12) : null, null != this.filter ? R4(n16, r12, this.filter) : null, e12 || null == this.featureEffect ? null : R4(n16, r12, this.featureEffect.filter), !e12 && o17 ? D2(n16, r12, o17) : null, !e12 && s12 ? j(n16, r12, s12) : null];
      if ("timeInfo" in r12 && r12.timeInfo && this.timeExtent && T(n16, r12.fieldsIndex, [r12.timeInfo.startField, r12.timeInfo.endField]), "timeInfo" in r12 && r12.timeInfo && "trackInfo" in r12 && r12.trackInfo) {
        const { trackInfo: e13 } = r12;
        T(n16, r12.fieldsIndex, [r12.timeInfo.trackIdField]), "feature" !== r12.type && "startTimeField" !== e13.timeField || T(n16, r12.fieldsIndex, [r12.timeInfo.startField]), "endTimeField" === e13.timeField && T(n16, r12.fieldsIndex, [r12.timeInfo.endField]), await M(n16, r12);
      }
      if ("floorInfo" in r12 && r12.floorInfo && T(n16, r12.fieldsIndex, [r12.floorInfo.floorField]), "featureTitleFields" in r12 && this.view?.requiredFieldsOptions?.featureTitleFields && r12.featureTitleFields && T(n16, r12.fieldsIndex, r12.featureTitleFields), "feature" === r12.type && r12.globalIdField && this.view?.requiredFieldsOptions?.globalIdField && T(n16, r12.fieldsIndex, [r12.globalIdField]), this.displayFilterEnabled && a12.push(P(n16, r12, r12.displayFilterInfo)), "feature" === r12.type && e12 && null != r12.infoFor3D && (null == r12.globalIdField && i2.getLogger(this).error("globalIdField missing on 3DObjectFeatureLayer"), T(n16, r12.fieldsIndex, [r12.globalIdField])), "subtype-group" === r12.type) {
        x(n16, i13, r12.subtypeField);
        const e13 = r12.sublayers.map(((e14) => Promise.all([e14.renderer?.collectRequiredFields(n16, i13), Q(n16, e14)])));
        a12.push(Promise.all(e13));
      }
      if ("catalog-footprint" === r12.type && r12.parent) {
        const e13 = r12.parent;
        T(n16, i13, [e13.itemNameField, e13.itemSourceField, e13.itemTypeField, e13.maxScaleField, e13.minScaleField]);
      }
      "knowledge-graph-sublayer" === r12.type && "link-chart" === r12.parentCompositeLayer.type && x(n16, i13, E2), "parquet" === r12.type && a12.push(n3(r12, r12.popupTemplate).then(((e13) => {
        for (const t11 of e13) n16.add(t11);
      })));
      const p12 = await Promise.allSettled(a12);
      if (e12) x(n16, i13, r12.objectIdField);
      else for (const t11 of e5(e9(r12))) x(n16, i13, t11);
      e12 && "displayField" in r12 && r12.displayField && x(n16, i13, r12.displayField);
      for (const u18 of p12) "rejected" === u18.status && i2.getLogger(this).error(u18.reason);
      const f7 = Array.from(n16).sort();
      this._set("requiredFields", f7);
    }
    _popupFeatureHasRequiredFields(e12, t11) {
      return ke(e12, t11);
    }
    async _createPopupQuery(e12, t11) {
      const i13 = this.layer.createQuery(), l10 = /* @__PURE__ */ new Set();
      let s12 = false;
      const n16 = e12 ?? [this.layer];
      for (const o17 of n16) {
        if (!("popupEnabled" in o17)) continue;
        const e13 = p3(o17, t11);
        if (null == e13) continue;
        const i14 = await r4(e13);
        s2(t11);
        const n17 = i14 && i14.arcadeUtils.hasGeometryOperations(e13);
        s12 = !("point" !== this.layer.geometryType && !n17);
        const a12 = await n3(this.layer, e13);
        s2(t11);
        for (const t12 of a12) l10.add(t12);
      }
      return i13.returnGeometry = s12, i13.returnZ = s12, i13.returnM = s12, i13.outFields = Array.from(l10), i13.outSpatialReference = this.view.spatialReference, "floorInfo" in this.layer && this.layer.floorInfo && (i13.where = r3(i13.where, o6(this))), i13;
    }
    canResume() {
      return !!super.canResume() && (null == this.timeExtent || !this.timeExtent.isEmpty);
    }
    getTest() {
    }
    get test() {
    }
  };
  return r([m()], N2.prototype, "_updatingRequiredPromise", void 0), r([m({ readOnly: true })], N2.prototype, "availableFields", null), r([m({ readOnly: true })], N2.prototype, "displayFilterEnabled", null), r([m({ readOnly: true })], N2.prototype, "effectiveDisplayFilter", null), r([m({ type: p })], N2.prototype, "featureEffect", null), r([m({ type: d3 })], N2.prototype, "filter", void 0), r([m()], N2.prototype, "layer", void 0), r([m({ type: Number })], N2.prototype, "maximumNumberOfFeatures", null), r([m({ readOnly: true, type: Boolean })], N2.prototype, "maximumNumberOfFeaturesExceeded", null), r([m()], N2.prototype, "requiresCurrentUser", void 0), r([m({ readOnly: true })], N2.prototype, "requiredFields", void 0), r([m({ readOnly: true })], N2.prototype, "signedInUser", null), r([m()], N2.prototype, "suspended", void 0), r([m()], N2.prototype, "view", void 0), N2 = r([a2("esri.views.layers.FeatureLayerView")], N2), N2;
};

// node_modules/@arcgis/core/views/2d/layers/FeatureLayerView2D.js
function ue(e12, t11) {
  const r12 = /* @__PURE__ */ new Set();
  return e12 && e12.forEach(((e13) => r12.add(e13))), t11 && t11.forEach(((e13) => r12.add(e13))), r12.has("*") ? ["*"] : Array.from(r12);
}
var le = 4294967294;
function he(e12, t11) {
  return t(e12.map(((e13) => l2((() => {
    const t12 = e13();
    return t12 && "object" == typeof t12 ? "getTime" in t12 && "function" == typeof t12.getTime ? t12.getTime() : JSON.stringify(t12) : t12;
  }), t11))));
}
var ce = class extends S2(i7(S(u9))) {
  constructor() {
    super(...arguments), this._commandsQueue = new o8({ process: (e12) => {
      switch (e12.type) {
        case "override-batch":
          return this._doOverride(e12);
        case "update":
          return this._doUpdate();
        case "highlight":
          return this._updateHighlights();
      }
    } }), this._visibilityOverrides = /* @__PURE__ */ new Set(), this._lastAvailableFields = [], this._lastTargetState = null, this.eventLog = new l6(), this._sourceRefreshVersion = 1, this._displayRefreshVersion = 1, this._pipelineUpdating = false, this._editUpdatingHandles = new h(), this._fields = null, this._sourceUpdating = false, this.featureEffectView = new c3();
  }
  destroy() {
    this._workerProxy?.destroy(), this._workerAttached.reject(u2()), this._commandsQueue.destroy();
  }
  initialize() {
    this._workerAttached = L2(), d(this._workerAttached.promise), this.addResolvingPromise(this._initProxy()), this.featureEffectView.featureEffect = this.featureEffect, this.featureEffectView.endTransition();
  }
  async _initProxy() {
    const e12 = this.layer;
    if ("isTable" in e12 && e12.isTable) throw new s("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: e12 });
    if (("feature" === e12.type || "subtype-group" === e12.type) && false === D(e12)?.operations.supportsQuery) throw new s("featurelayerview:query-not-supported", "layer view requires a layer with query capability", { layer: e12 });
    this._workerProxy && this._workerProxy.destroy();
    const t11 = this._createClientOptions();
    this._workerProxy = await t5(t11);
  }
  async _attachProxy() {
    const e12 = { service: await this.layerAdapter.createServiceOptions(this.view), tileInfoJSON: this.view?.featuresTilingScheme?.tileInfo?.toJSON() };
    let t11 = [];
    Array.isArray(e12.service.source) && (t11 = e12.service.source);
    try {
      await this._workerProxy.pipeline.onAttach(e12, { transferList: t11 }), this._workerAttached.resolve();
    } catch (r12) {
      this._workerAttached.reject(u2()), f(r12);
    }
  }
  async _detachProxy() {
    return this._workerProxy.pipeline.onDetach();
  }
  async getWorker() {
    return await this._workerAttached.promise, this._workerProxy;
  }
  get dataUpdating() {
    return this._sourceUpdating || this._editUpdatingHandles.updating;
  }
  get effectiveDisplayFilterClause() {
    const e12 = this.effectiveDisplayFilter?.where ?? null;
    return e12 && this.hasHighlight ? u5(e12, l4(this.layer.objectIdField, this.highlightIds)) : e12;
  }
  get hasAllFeatures() {
    return this.layer.visible && !this.suspended && this.eventLog.hasAllData && this.eventLog.willQueryAllFeatures;
  }
  get hasAllFeaturesInView() {
    const e12 = this.effectiveDisplayFilter?.where || null, t11 = !this.eventLog.willQueryAllFeatures && null != e12 && "1=1" !== e12;
    return this.layer.visible && !this.suspended && this.eventLog.hasAllData && !t11;
  }
  get hasFullGeometries() {
    return this.layer.visible && !this.suspended && this.eventLog.hasAllData && this.eventLog.willQueryFullResolutionGeometry;
  }
  get labelingCollisionInfos() {
    const e12 = this.layerAdapter.getLabelingDeconflictionInfo(this.view), t11 = this.layer.geometryType, r12 = !this.suspended;
    return e12.map((({ vvEvaluators: e13, deconflictionEnabled: s12, labelingInfo: i13 }) => ({ labelingInfo: i13, container: this.featureContainer, vvEvaluators: e13, deconflictionEnabled: s12, geometryType: t11, visible: r12 })));
  }
  get layerAdapter() {
    switch (this.layer.type) {
      case "feature":
        return "memory" === this.layer.source.type ? new p10(this.layer) : new m11(this.layer);
      case "geojson":
      case "csv":
      case "wfs":
        return new p10(this.layer);
      case "parquet":
        return new y3(this.layer);
      case "subtype-group":
        return new m15(this.layer);
      case "ogc-feature":
        return new u15(this.layer);
      case "stream":
        return new a10(this.layer);
      case "oriented-imagery":
        return new m12(this.layer);
      case "knowledge-graph-sublayer":
        return new c8(this.layer);
      case "catalog-footprint":
        return new n9(this.layer);
      default:
        n(this.layer);
    }
    return null;
  }
  get timeExtent() {
    return i8(this.layerAdapter.timeOptions, this.view?.timeExtent, this._get("timeExtent"));
  }
  getDisplayStatistics(e12, t11) {
    return this.featureContainer?.getDisplayStatistics(e12, t11);
  }
  async queryHeatmapStatistics(e12) {
    return (await this.getWorker()).pipeline.queryHeatmapStatistics(e12);
  }
  highlight(e12, t11) {
    let s12;
    e12 instanceof d2 ? s12 = [e12.getObjectId()] : "number" == typeof e12 || "string" == typeof e12 ? s12 = [e12] : V.isCollection(e12) && e12.length > 0 ? s12 = e12.map(((e13) => e13?.getObjectId())).toArray() : Array.isArray(e12) && e12.length > 0 && (s12 = "number" == typeof e12[0] || "string" == typeof e12[0] ? e12 : e12.map(((e13) => e13?.getObjectId())));
    const o17 = s12?.filter(L);
    if (!o17?.length) return e();
    const n16 = t11?.name ?? c2;
    return this._addHighlights(o17, n16), e((() => !this.destroyed && this._removeHighlights(o17, n16)));
  }
  async hitTest(e12, i13) {
    const a12 = await this.featureContainer.hitTest(i13);
    if (0 === a12.length) return null;
    const o17 = await this.getWorker(), { features: n16, aggregates: u18, tracks: l10 } = await o17.pipeline.getDisplayFeatures(a12), h4 = this.featureContainer.getSortKeys(a12), c9 = ({ displayId: e13 }, { displayId: t11 }) => h4.has(e13) && h4.has(t11) ? h4.get(e13) - h4.get(t11) : e13 - t11;
    return n16.sort(c9).reverse(), u18.sort(c9).reverse(), [...u18.map(((r12) => this._createGraphicHit(e12, s6.fromJSON(r12)))), ...l10.map(((t11) => this._createGraphicHit(e12, p5.fromJSON(t11)))), ...n16.map(((t11) => this._createGraphicHit(e12, d2.fromJSON(t11))))];
  }
  async queryStatistics() {
    const e12 = await this.getWorker();
    return n14(e12.pipeline.queryStatistics(), { featureCount: 0, ringCount: 0, vertexCount: 0 });
  }
  async querySummaryStatistics(e12, t11, r12) {
    const s12 = await this.getWorker(), i13 = { ...t11, scale: this.view.scale }, a12 = s12.features.executeQueryForSummaryStatistics(this._cleanUpQuery(e12), i13, r12);
    return n14(a12, {});
  }
  async queryAggregateSummaryStatistics(e12, t11, r12) {
    const s12 = { ...t11, scale: this.view.scale }, i13 = (await this.getWorker()).aggregates.executeQueryForSummaryStatistics(this._cleanUpAggregateQuery(e12), s12, r12);
    return n14(i13, {});
  }
  async queryUniqueValues(e12, t11, r12) {
    const s12 = await this.getWorker(), i13 = { ...t11, scale: this.view.scale }, a12 = s12.features.executeQueryForUniqueValues(this._cleanUpQuery(e12), i13, r12);
    return n14(a12, { uniqueValueInfos: [] });
  }
  async queryAggregateUniqueValues(e12, t11, r12) {
    const s12 = await this.getWorker(), i13 = { ...t11, scale: this.view.scale }, a12 = s12.aggregates.executeQueryForUniqueValues(this._cleanUpAggregateQuery(e12), i13, r12);
    return n14(a12, { uniqueValueInfos: [] });
  }
  async queryClassBreaks(e12, t11, r12) {
    const s12 = await this.getWorker(), i13 = { ...t11, scale: this.view.scale }, a12 = s12.features.executeQueryForClassBreaks(this._cleanUpQuery(e12), i13, r12);
    return n14(a12, { classBreakInfos: [] });
  }
  async queryAggregateClassBreaks(e12, t11, r12) {
    const s12 = await this.getWorker(), i13 = { ...t11, scale: this.view.scale }, a12 = s12.aggregates.executeQueryForClassBreaks(this._cleanUpAggregateQuery(e12), i13, r12);
    return n14(a12, { classBreakInfos: [] });
  }
  async queryHistogram(e12, t11, r12) {
    const s12 = await this.getWorker(), i13 = { ...t11, scale: this.view.scale }, a12 = s12.features.executeQueryForHistogram(this._cleanUpQuery(e12), i13, r12);
    return n14(a12, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  async queryAggregateHistogram(e12, t11, r12) {
    const s12 = await this.getWorker(), i13 = { ...t11, scale: this.view.scale }, a12 = s12.aggregates.executeQueryForHistogram(this._cleanUpAggregateQuery(e12), i13, r12);
    return n14(a12, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  queryFeatures(e12, t11) {
    return this.queryFeaturesJSON(e12, t11).then(((e13) => {
      const t12 = g2.fromJSON(e13);
      return t12.features.forEach(((e14) => this._setLayersForFeature(e14))), t12;
    }));
  }
  async queryVisibleFeatures(e12, t11) {
    const r12 = (await this.getWorker()).pipeline.queryVisibleFeatures(this._cleanUpQuery(e12), t11), s12 = await n14(r12, { features: [] }), i13 = g2.fromJSON(s12);
    return i13.features.forEach(((e13) => this._setLayersForFeature(e13))), i13;
  }
  async queryAggregates(e12, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e12), t11), s12 = await n14(r12, { features: [] }), i13 = c4.fromJSON(s12);
    return i13.features.forEach(((e13) => this._setLayersForFeature(e13))), i13;
  }
  async queryAggregateIds(e12, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQueryForIds(this._cleanUpAggregateQuery(e12), t11);
    return n14(r12, []);
  }
  async queryAggregateCount(e12, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQueryForCount(this._cleanUpAggregateQuery(e12), t11);
    return n14(r12, 0);
  }
  async queryAggregateJSON(e12, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e12), t11);
    return n14(r12, { features: [] });
  }
  async queryFeaturesJSON(e12, t11) {
    const r12 = (await this.getWorker()).features.executeQuery(this._cleanUpQuery(e12), t11);
    return n14(r12, { features: [] });
  }
  async queryObjectIds(e12, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForIds(this._cleanUpQuery(e12), t11);
    return n14(r12, []);
  }
  async queryFeatureCount(e12, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForCount(this._cleanUpQuery(e12), t11);
    return n14(r12, 0);
  }
  async queryExtent(e12, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForExtent(this._cleanUpQuery(e12), t11), s12 = await n14(r12, { count: 0, extent: null });
    return { count: s12.count, extent: z.fromJSON(s12.extent) };
  }
  async queryAttributeBins(e12, t11) {
    const r12 = (await this.getWorker()).features.executeAttributeBinsQuery(this._cleanUpAttributeBinsQuery(e12), t11), s12 = await n14(r12, { features: [] });
    return i5.fromJSON(s12);
  }
  async getSampleFeatures(e12) {
    return (await this.getWorker()).pipeline.getSampleFeatures(e12);
  }
  setVisibility(e12, t11) {
    t11 ? this._visibilityOverrides.delete(e12) : this._visibilityOverrides.add(e12), this._update();
  }
  update(e12) {
    if (!this.subscriptionManager) return;
    this.view.animation && !this._lastTargetState && (this._lastTargetState = e12.state.clone()), !this.view.animation && this._lastTargetState && (this._lastTargetState = null);
    const t11 = this.subscriptionManager.update(e12.targetState, this._lastTargetState), r12 = this.subscriptionManager.coverageSet;
    for (const s12 of this.featureContainer.tiles || []) s12.isCoverage = r12.has(s12.id), s12.neededForCoverage = t11.has(s12.id) || s12.isCoverage;
    this.featureContainer.setVisibleTiles(t11);
  }
  attach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.attach"), d(this._updatingHandles.addPromise(this._workerAttached.promise)), d(this._attachProxy()), this.featureContainer = new p6(this), this.container.addChild(this.featureContainer), this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`), this.subscriptionManager = new n15({ tileInfoView: this.view.featuresTilingScheme, updateSubscriptions: (e12) => {
      this.featureContainer.updateSubscriptions(e12), d(this._updatingHandles.addPromise(this.getWorker().then(((t11) => t11.pipeline.updateSubscriptions(e12)))));
    }, isDone: (e12) => this.featureContainer.isDone(e12) }), this.requestUpdate(), this.addAttachHandles([he([() => this._displayRefreshVersion, () => this.layer.displayFilterInfo, () => this.timeExtent, () => this.clips, () => this.filter, () => this.effectiveDisplayFilterClause, () => this.featureEffect, () => this._sourceRefreshVersion, () => this.view.timeZone, () => this.view.timeExtent, ...this.layerAdapter.getUpdateHashProperties(this.view)], (() => this._update())), l2((() => this.updateSuspended), ((e12) => {
      e12 || (this.subscriptionManager.resume(), this.view.labelManager.requestUpdate());
    })), l2((() => this.visible), ((e12) => {
      this.view.labelManager.requestUpdate();
    }))]), this._update(), "stream" !== this.layer.type && "parquet" !== this.layer.type && "catalog-footprint" !== this.layer.type && this.addAttachHandles(this.layer.on("edits", ((e12) => this._editUpdatingHandles.addPromise(this._edit(e12)))));
  }
  detach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.detach"), this._detachProxy(), this._fields = null, this.view.labelManager.removeContainer(this.featureContainer), this.featureContainer.destroy(), this.featureContainer = null, this._commandsQueue.clear(), this.container.removeAllChildren(), this.subscriptionManager = u(this.subscriptionManager), this._workerProxy.pipeline.onDetach(), this._workerAttached = L2(), d(this._workerAttached.promise), this._lastAvailableFields = [], this._lastSchema = null;
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  addOverrides(e12) {
    return this._commandsQueue.push({ type: "override", options: { ...e12, release: [] } });
  }
  removeOverrides(e12) {
    for (const r12 of e12) if (null == r12) throw new s("featurelayerview:bad-override", "Tried to remove an override for an invalid objectId", { objectId: r12 });
    const t11 = { added: [], updated: [], removed: [], release: e12, isWeak: false, historicMoment: null };
    return this._commandsQueue.push({ type: "override", options: t11 });
  }
  isUpdating() {
    const e12 = "renderer" in this.layer && null != this.layer.renderer, t11 = this._commandsQueue.updateTracking.updating, r12 = null != this._updatingRequiredPromise, s12 = this.featureContainer.updatingHandles.updating, i13 = this.updateRequested || e12 && (t11 || r12) || s12 || this._pipelineUpdating || this.dataUpdating;
    if (has("esri-2d-log-updating")) {
      console.log(`Updating FLV2D (${this.layer.id}): ${i13}
  -> updateRequested ${this.updateRequested}
  -> hasRenderer ${e12}
  -> updatingRequiredFields ${r12}
  -> hasPendingCommand ${t11}
  -> dataUpdating ${this.dataUpdating}
  -> processing ${this._pipelineUpdating}
  -> updatingContainer ${s12}
`);
      for (const e13 of this.featureContainer.subscriptions()) console.log(`    -> Tile[${e13.id}] Done: ${e13.done}`);
    }
    return i13;
  }
  _createClientOptions() {
    const e12 = this;
    return { get container() {
      return e12.featureContainer;
    }, setUpdating: (e13) => {
      this._set("_pipelineUpdating", e13.pipeline), this._set("_sourceUpdating", e13.source);
    }, emitEvent: (e13) => {
      this.emit(e13.name, e13.event);
    }, get eventLog() {
      return e12.eventLog;
    }, fetch: async (t11) => {
      if (has("esri-2d-stabilize-glyphs")) {
        const r12 = [];
        for (const s12 of t11) r12.push(await e12.view.stage.painter.textureManager.rasterizeItem(s12));
        return r12;
      }
      return Promise.all(t11.map(((t12) => e12.view.stage.painter.textureManager.rasterizeItem(t12))));
    }, fetchDictionary: (e13) => Promise.all(e13.map(((e14) => this._fetchDictionaryRequest(e14)))) };
  }
  async _fetchDictionaryRequest(e12) {
    try {
      if ("subtype-group" === this.layer.type) throw new Error("InternalError: SubtypeGroupLayer does not support dictionary renderer");
      const t11 = this.layer.renderer;
      if (!t11 || "dictionary" !== t11.type) throw new Error("InternalError: Expected layer to have a DictionaryRenderer");
      const r12 = this._lastSchema.processor.mesh.factory.symbology;
      if ("dictionary" !== r12.type) throw new Error("InternalError: Expected schema to be of type 'dictionary'");
      const s12 = { cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, store: this.featureContainer.instanceStore, scaleExpression: r12.scaleExpression };
      this._fields || (this._fields = this.layer.fields.map(((e13) => e13.toJSON())));
      const i13 = r12.visualVariableUniforms, a12 = r6(this.layer.geometryType), o17 = await t11.getSymbolForControlString(e12.controlString, a12, false);
      if (!o17 || !o17.data) return { type: "dictionary-response", meshes: [] };
      return { type: "dictionary-response", meshes: await u8({ ...o17.data, hasTextStringTemplates: true }, { uniforms: i13, path: "renderer", schemaOptions: s12 }) };
    } catch (t11) {
      return { type: "dictionary-response", meshes: [] };
    }
  }
  _cleanUpQuery(e12) {
    const t11 = R.from(e12) || this.createQuery();
    return t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference), t11.toJSON();
  }
  _cleanUpAttributeBinsQuery(e12) {
    const t11 = R3.from(e12);
    return t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference), t11.toJSON();
  }
  _cleanUpAggregateQuery(e12) {
    const t11 = R.from(e12) || this.createAggregateQuery();
    t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference);
    const r12 = t11.objectIds ?? [];
    for (const s12 of t11.aggregateIds ?? []) r12.push(s12);
    return t11.objectIds = r12, t11.aggregateIds = [], t11.toJSON();
  }
  async _update() {
    return this._commandsQueue.push({ type: "update" });
  }
  _edit(e12) {
    return this.updateSuspended ? (this.subscriptionManager.suspend(), Promise.resolve()) : this._commandsQueue.push({ type: "edit", event: e12 });
  }
  async doRefresh(e12) {
    this.attached && (this.updateSuspended && e12 || (e12 ? this.incrementSourceRefreshVersion() : this.incrementDisplayRefreshVersion()));
  }
  incrementSourceRefreshVersion() {
    this._sourceRefreshVersion = (this._sourceRefreshVersion + 1) % le + 1;
  }
  incrementDisplayRefreshVersion() {
    this._displayRefreshVersion = (this._displayRefreshVersion + 1) % le + 1;
  }
  async _resolveIdenifiers(e12) {
    const t11 = [], r12 = [];
    for (const a12 of e12) null == a12.objectId || -1 === a12.objectId ? null == a12.globalId ? i2.getLogger(this).warn("mapview-apply-edits", "A feature identifier must contain either a GlobalId or ObjectId. Ignoring", { identifier: a12 }) : r12.push(a12.globalId) : t11.push(a12.objectId);
    const s12 = "globalIdField" in this.layer && this.layer.globalIdField, i13 = s12 && this.availableFields.includes(s12);
    if (r12.length && !i13) return i2.getLogger(this).error(new s("mapview-apply-edits", `Editing the specified service requires the layer's globalIdField, ${s12} to be included the layer's outFields for updates to be reflected on the map`)), t11;
    if (r12.length) {
      const e13 = await this._workerProxy.pipeline.getObjectIdsFromGlobalIds(r12);
      for (const r13 of e13) t11.push(r13);
    }
    return t11;
  }
  _resolveOverrides(e12) {
    const t11 = false, r12 = false, s12 = r6(this.layer.geometryType), i13 = e9(this.layer), a12 = [];
    for (const o17 of e12.added) {
      const e13 = ot(o17, s12, t11, r12, i13);
      if (null == e13.objectId) throw new s("featurelayerview:bad-override", "Feature does not have an objectId", { feature: o17 });
      a12.push(e13);
    }
    for (const o17 of e12.updated) {
      const e13 = ot(o17, s12, t11, r12, i13);
      if (null == e13.objectId) throw new s("featurelayerview:bad-override", "Feature does not have an objectId", { feature: o17 });
      a12.push(e13);
    }
    for (const o17 of e12.removed) if (null == o17) throw new s("featurelayerview:bad-override", "Tried to remove an invalid objectId", { objectId: o17 });
    return { type: "override", updates: a12, removed: e12.removed, release: e12.release, isWeak: e12.isWeak ?? false, historicMoment: e12.historicMoment ?? null };
  }
  async _resolveEdit(e12) {
    const t11 = this.layer, r12 = e12.historicMoment?.getTime() ?? null, s12 = "layerId" in t11 && e12.editedFeatures?.find(((e13) => e13.layerId === t11.layerId));
    if (s12 && this._canEditByFeature(s12)) {
      const { adds: e13, deletes: t12, updates: i14 } = s12.editedFeatures, a13 = this.layer.objectIdField, o18 = i14.map(((e14) => e14.current)), n16 = t12.map(((e14) => "attributes" in e14 ? { objectId: a13 ? e14.attributes[a13] : null } : e14)), u18 = await this._resolveIdenifiers(n16);
      return this._resolveOverrides({ added: e13, updated: o18, removed: u18, historicMoment: r12, isWeak: true, release: [] });
    }
    const [i13, a12, o17] = await Promise.all([this._resolveIdenifiers(e12.addedFeatures), this._resolveIdenifiers(e12.updatedFeatures), this._resolveIdenifiers(e12.deletedFeatures)]);
    return { type: "override-by-id", updates: [...i13, ...a12], removed: o17, historicMoment: r12, isWeak: true };
  }
  _canEditByFeature(e12) {
    const { adds: t11, updates: r12 } = e12.editedFeatures;
    return t11.every(((e13) => this.view.spatialReference.equals(e13.geometry?.spatialReference))) && r12.every(((e13) => this.view.spatialReference.equals(e13.current.geometry?.spatialReference)));
  }
  async _doUpdate() {
    "featureReduction" in this.layer && this.layer.featureReduction && this.layer.featureReduction !== this._lastFeatureReduction && (this.layer.featureReduction = this.layer.featureReduction?.clone(), this._lastFeatureReduction = this.layer.featureReduction);
    try {
      if (await Promise.allSettled([this._handleChange(), W(this.layer)]), this.destroyed || !this.layerAdapter?.hasRequiredSupport || !this.subscriptionManager) return;
      const e12 = this.featureContainer.instanceStore;
      this.featureContainer.attributeView.lockTextureUploads();
      const t11 = this._lastSchema?.processor.mesh.factory.symbology?.type;
      let r12 = true;
      "subtype-group" !== this.layer.type && "dictionary" === this.layer.renderer?.type && "dictionary" === t11 && (r12 = false), e12.updateStart(r12);
      const s12 = this.featureEffect, i13 = { store: e12, cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, scaleExpression: void 0 }, a12 = await this._createViewSchemaConfig(), o17 = { source: this.layerAdapter.createSourceSchema(a12, this._sourceRefreshVersion), processor: await this.layerAdapter.createProcessorSchema(i13, a12, this._displayRefreshVersion) }, n16 = o17.processor.mesh.factory.labels;
      n16 && this.view.labelManager.setLabelSchemaStyles(n16, this.featureContainer);
      const u18 = i(this._lastSchema?.source.mutable, o17.source.mutable) || i(this._lastSchema?.processor, o17.processor);
      if (!u18) return this.featureContainer.requestRender(), this.featureContainer.attributeView.unlockTextureUploads(), e12.updateEnd(r12), void (this.featureEffectView.featureEffect = s12);
      this._lastSchema = o17, this._fields = null;
      const l10 = Math.round(performance.now());
      has("esri-2d-update-debug") && console.debug(`Id[${this.layer.uid}] Version[${l10}] FeatureLayerView2D._doUpdate`, { changes: u18 });
      const h4 = await this.getWorker();
      await h4.pipeline.updateSchema(o17, l10), e12.updateEnd(r12), this.featureEffectView.featureEffect = s12, this.featureEffectView.endTransition(), this.featureContainer.restartAllAnimations(), this.featureContainer.attributeView.unlockTextureUploads(), this.featureContainer.trySwapRenderState(), this.featureContainer.requestRender(), has("esri-2d-update-debug") && console.debug(`Version[${l10}] FeatureLayerView2D.updateEnd`), this.requestUpdate();
    } catch (e12) {
      has("esri-2d-update-debug") && console.error("Encountered an error during update", e12);
    }
  }
  async _doOverride(e12) {
    const t11 = await this.getWorker();
    try {
      for (const r12 of e12.messages) switch (r12.type) {
        case "edit": {
          const e13 = new e10();
          e13.add(await this._resolveEdit(r12.event)), await t11.pipeline.onOverride(e13.toMessage());
          break;
        }
        case "override": {
          const e13 = new e10();
          e13.add(this._resolveOverrides(r12.options)), await t11.pipeline.onOverride(e13.toMessage());
          break;
        }
      }
    } catch (r12) {
      b(r12), 0;
    }
  }
  _getEffectiveAvailableFields(e12) {
    const t11 = ue(this._lastAvailableFields, e12);
    return this._lastAvailableFields = t11, _(this.layer.fieldsIndex, t11);
  }
  async _createViewSchemaConfig() {
    const e12 = this.requiresCurrentUser ? await this.signedInUser : null, t11 = [pe(this.view, this.layerAdapter, this.timeExtent, this._visibilityOverrides, this.filter, this.effectiveDisplayFilterClause), this.featureEffect?.filter?.toJSON() ?? null];
    return { availableFields: this._getEffectiveAvailableFields(this.availableFields), displayFilterEnabled: this.displayFilterEnabled, filters: t11, scale: this.view.scale, timeZone: this.view.timeZone, timeExtent: this.view.timeExtent, currentUser: e12 };
  }
  _processHighlight() {
    this._commandsQueue.push({ type: "highlight" });
  }
  async _updateHighlights() {
    const e12 = this._getHighlights(), t11 = await this.getWorker();
    if (this.destroyed) return;
    const r12 = t11.pipeline.updateHighlight({ highlights: e12 }).catch(((e13) => {
      b(e13) || i2.getLogger(this).error(e13);
    }));
    this._updatingHandles.addPromise(r12);
  }
  _setLayersForFeature(e12) {
    e12.layer = e12.sourceLayer = this.layer, this.layerAdapter.setGraphicOrigin && this.layerAdapter.setGraphicOrigin(e12);
  }
  _createGraphicHit(e12, t11) {
    return this._setLayersForFeature(t11), null != t11.geometry && (t11.geometry.spatialReference = this.view.spatialReference), { type: "graphic", graphic: t11, layer: this.layer, mapPoint: e12 };
  }
};
function pe(e12, t11, r12, s12, i13, a12) {
  i13 && (i13 = i13.clone());
  const o17 = null != i13 ? i13.timeExtent : null, n16 = null != r12 && null != o17 ? r12.intersection(o17) : r12 || o17;
  n16 && (i13 ??= new d3(), i13.timeExtent = n16), i13 = t11.addFilters?.(i13, e12) ?? i13, a12 && (i13 ??= new d3(), i13.where = r3(i13.where, a12));
  let u18 = i13?.toJSON() ?? null;
  return s12.size && (u18 ??= new d3().toJSON(), u18.hiddenIds = Array.from(s12)), u18;
}
r([m()], ce.prototype, "_commandsQueue", void 0), r([m()], ce.prototype, "_sourceRefreshVersion", void 0), r([m()], ce.prototype, "_displayRefreshVersion", void 0), r([m({ readOnly: true })], ce.prototype, "_pipelineUpdating", void 0), r([m()], ce.prototype, "_sourceUpdating", void 0), r([m({ readOnly: true })], ce.prototype, "dataUpdating", null), r([m({ readOnly: true })], ce.prototype, "effectiveDisplayFilterClause", null), r([m({ readOnly: true })], ce.prototype, "hasAllFeatures", null), r([m({ readOnly: true })], ce.prototype, "hasAllFeaturesInView", null), r([m({ readOnly: true })], ce.prototype, "hasFullGeometries", null), r([m()], ce.prototype, "featureEffectView", void 0), r([m()], ce.prototype, "labelingCollisionInfos", null), r([m()], ce.prototype, "layerAdapter", null), r([m({ readOnly: true })], ce.prototype, "timeExtent", null), r([m()], ce.prototype, "updating", void 0), ce = r([a2("esri.views.2d.layers.FeatureLayerView2D")], ce);

export {
  n14 as n,
  ce
};
//# sourceMappingURL=chunk-5ZKDVNA7.js.map
