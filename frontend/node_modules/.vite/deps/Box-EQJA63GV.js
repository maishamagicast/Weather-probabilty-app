import {
  h as h3
} from "./chunk-TJMKM7NV.js";
import {
  j,
  l as l3
} from "./chunk-M6UJ5MEY.js";
import {
  t
} from "./chunk-6EXPVHQL.js";
import {
  e as e2,
  i as i3,
  s as s2
} from "./chunk-2FUN34QP.js";
import {
  i as i2
} from "./chunk-J7OASWN4.js";
import {
  a as a3,
  i,
  m as m5,
  s
} from "./chunk-UKIQRUDT.js";
import {
  R
} from "./chunk-WHBC3CR5.js";
import "./chunk-ZC5D5FLD.js";
import {
  l2
} from "./chunk-IRTIVNQB.js";
import "./chunk-CTLJVZXG.js";
import "./chunk-YKE7YQGP.js";
import "./chunk-YERTKO74.js";
import "./chunk-SN2MX6RH.js";
import "./chunk-JUDSBNS5.js";
import {
  h as h2
} from "./chunk-OG7E7GTZ.js";
import "./chunk-YGPPU7AB.js";
import "./chunk-WHNSSW5C.js";
import "./chunk-ZYWMFOAJ.js";
import "./chunk-4LDLOXAQ.js";
import "./chunk-RHVCSVQD.js";
import "./chunk-CHGKJUJ3.js";
import "./chunk-3YBQQHIP.js";
import "./chunk-OJQCHQYS.js";
import "./chunk-N3W3EVP3.js";
import "./chunk-SIRTOV2N.js";
import "./chunk-Z6FTTTCT.js";
import "./chunk-RPGAK5ZK.js";
import "./chunk-KX3QNWMZ.js";
import "./chunk-HPADPQJ7.js";
import "./chunk-63ZT5BWV.js";
import "./chunk-BZGZCX3L.js";
import "./chunk-CY6GSCRR.js";
import "./chunk-3ISR2POR.js";
import "./chunk-3JKWT76Y.js";
import "./chunk-LOLNWH3R.js";
import "./chunk-SPM2JNCJ.js";
import "./chunk-W3BJJE6D.js";
import "./chunk-UZ3YWBWC.js";
import "./chunk-2EOHKZLO.js";
import "./chunk-S7GLMIAQ.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-RFSLNSEE.js";
import "./chunk-OTT43TRS.js";
import "./chunk-UNPFUYVY.js";
import "./chunk-3ZX4Y274.js";
import "./chunk-746KDGCX.js";
import "./chunk-6BXYK2GC.js";
import "./chunk-YG6ILDTP.js";
import "./chunk-QZBNKN5E.js";
import "./chunk-BNQMKYX6.js";
import "./chunk-B6C2GOG6.js";
import "./chunk-K3VYMAVM.js";
import "./chunk-3SBQ4BRR.js";
import "./chunk-QEBLKRSV.js";
import "./chunk-3BRAWT3U.js";
import "./chunk-FNXTTV6Z.js";
import "./chunk-AACFCXAP.js";
import "./chunk-P5DG4SNT.js";
import "./chunk-ELYKVFFC.js";
import "./chunk-AVLUXD4S.js";
import "./chunk-R25QZWQ7.js";
import "./chunk-BELQIHLO.js";
import "./chunk-BPI4BR4E.js";
import "./chunk-YVMULGDJ.js";
import "./chunk-CJDZN5K5.js";
import "./chunk-N77BULFI.js";
import "./chunk-6TZIEYTZ.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-A6R2FXH6.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-3TSZDV6B.js";
import "./chunk-P4O4YCLI.js";
import "./chunk-FV6ZNHFI.js";
import "./chunk-MSSQA3XK.js";
import {
  d
} from "./chunk-PBKE5BCM.js";
import "./chunk-FOALQHMM.js";
import "./chunk-7HS3ESHX.js";
import "./chunk-2CS746FZ.js";
import "./chunk-NEI5HAVK.js";
import "./chunk-RCOFAQFP.js";
import "./chunk-CO2J5JPW.js";
import {
  m as m4
} from "./chunk-CHAHOTAY.js";
import "./chunk-RZGBA4KS.js";
import "./chunk-FSYN2HHU.js";
import "./chunk-7I4TWCTW.js";
import "./chunk-W5UOLFE2.js";
import "./chunk-AZ2S2PYZ.js";
import "./chunk-SCMB64VM.js";
import "./chunk-FOPBVVXE.js";
import "./chunk-INI6MHIQ.js";
import "./chunk-R7YP6EQJ.js";
import "./chunk-QUZZIDFR.js";
import "./chunk-CBCDVQSA.js";
import "./chunk-74GULGYB.js";
import "./chunk-RKF6WUZT.js";
import {
  P,
  m as m2,
  x,
  y
} from "./chunk-RMRI4NYS.js";
import {
  a as a2,
  e
} from "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import {
  u as u2
} from "./chunk-BLBN3L5Q.js";
import "./chunk-5EWIWLNU.js";
import "./chunk-TOCH3L2K.js";
import "./chunk-CBXZL53X.js";
import {
  f,
  h,
  l,
  w
} from "./chunk-HYAO4PVV.js";
import "./chunk-SRNKPAJX.js";
import "./chunk-MOMLPET6.js";
import {
  o
} from "./chunk-VNQUG2TO.js";
import "./chunk-EULNFFHG.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-LPCUYJ2B.js";
import "./chunk-3QHX4R4B.js";
import {
  _
} from "./chunk-SMO33YG7.js";
import "./chunk-LCBAL6ER.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import "./chunk-67AKDROO.js";
import "./chunk-CM3TIXEV.js";
import "./chunk-2AYGXVZI.js";
import "./chunk-OUZJZB6I.js";
import {
  u as u3
} from "./chunk-WO5FLTVY.js";
import {
  m as m3
} from "./chunk-MGA7XBRB.js";
import "./chunk-XNUSHDFN.js";
import "./chunk-4AKMPOG7.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-APMQAZ5Z.js";
import "./chunk-ZJQPHR3K.js";
import "./chunk-NJZD7WM5.js";
import "./chunk-CL7VLXUR.js";
import "./chunk-FCX4ZA3Z.js";
import {
  m2 as m
} from "./chunk-2ZPU5IZX.js";
import {
  a2 as a
} from "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import "./chunk-JNYZ3I5R.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import {
  u2 as u
} from "./chunk-N626Y23H.js";
import "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/geometry/support/rotate.js
function o2(n, e3, t2, s3) {
  const i4 = [];
  for (const o3 of n) {
    const n2 = o3.slice();
    i4.push(n2);
    const r3 = e3 * (o3[0] - s3.x) - t2 * (o3[1] - s3.y) + s3.x, a4 = t2 * (o3[0] - s3.x) + e3 * (o3[1] - s3.y) + s3.y;
    n2[0] = r3, n2[1] = a4;
  }
  return i4;
}
function r2(r3, a4, c) {
  const { hasM: m6, hasZ: x2, spatialReference: f2 } = r3, p = a4 * Math.PI / 180, l4 = Math.cos(p), h4 = Math.sin(p);
  if ("xmin" in r3 && (c = c ?? r3.center, r3 = new P({ spatialReference: f2, rings: [[[r3.xmin, r3.ymin], [r3.xmin, r3.ymax], [r3.xmax, r3.ymax], [r3.xmax, r3.ymin], [r3.xmin, r3.ymin]]] })), "paths" in r3) {
    c = c ?? r3.extent.center;
    const n = [];
    for (const e3 of r3.paths) n.push(o2(e3, l4, h4, c));
    return new y({ hasM: m6, hasZ: x2, spatialReference: f2, paths: n });
  }
  if ("rings" in r3) {
    c = c ?? r3.extent.center;
    const n = [];
    for (const e3 of r3.rings) {
      const t2 = a2(e3), s3 = o2(e3, l4, h4, c);
      a2(s3) !== t2 && s3.reverse(), n.push(s3);
    }
    return new P({ hasM: m6, hasZ: x2, spatialReference: f2, rings: n });
  }
  if ("x" in r3) {
    c = c ?? r3;
    const n = new _({ x: l4 * (r3.x - c.x) - h4 * (r3.y - c.y) + c.x, y: h4 * (r3.x - c.x) + l4 * (r3.y - c.y) + c.y, spatialReference: f2 });
    return null != r3.z && (n.z = r3.z), null != r3.m && (n.m = r3.m), n;
  }
  return "points" in r3 ? (c = c ?? r3.extent.center, new m2({ hasM: m6, hasZ: x2, points: o2(r3.points, l4, h4, c), spatialReference: f2 })) : null;
}

// node_modules/@arcgis/core/views/draw/support/Box.js
var E = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.dx = i4, this.dy = s3, this.type = "move-start";
  }
};
var z = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.dx = i4, this.dy = s3, this.type = "move";
  }
};
var B = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.dx = i4, this.dy = s3, this.type = "move-stop";
  }
};
var N = class {
  constructor(t2, e3, i4) {
    this.graphics = t2, this.mover = e3, this.angle = i4, this.type = "rotate-start";
  }
};
var U = class {
  constructor(t2, e3, i4) {
    this.graphics = t2, this.mover = e3, this.angle = i4, this.type = "rotate";
  }
};
var Y = class {
  constructor(t2, e3, i4) {
    this.graphics = t2, this.mover = e3, this.angle = i4, this.type = "rotate-stop";
  }
};
var P2 = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.xScale = i4, this.yScale = s3, this.type = "scale-start";
  }
};
var A = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.xScale = i4, this.yScale = s3, this.type = "scale";
  }
};
var X = class {
  constructor(t2, e3, i4, s3) {
    this.graphics = t2, this.mover = e3, this.xScale = i4, this.yScale = s3, this.type = "scale-stop";
  }
};
var D = h3.transformGraphics;
var F = { centerIndicator: new u3({ style: "cross", size: D.center.size, color: D.center.color }), fill: { default: new m4({ color: D.fill.color, outline: { color: D.fill.outlineColor, join: "round", width: 1 } }), active: new m4({ color: D.fill.stagedColor, outline: { color: D.fill.outlineColor, join: "round", style: "dash", width: 1 } }) }, handles: { default: new u3({ style: "square", size: D.vertex.size, color: D.vertex.color, outline: { color: D.vertex.outlineColor, width: 1 } }), hover: new u3({ style: "square", size: D.vertex.hoverSize, color: D.vertex.hoverColor, outline: { color: D.vertex.hoverOutlineColor, width: 1 } }) }, rotator: { default: new u3({ style: "circle", size: D.vertex.size, color: D.vertex.color, outline: { color: D.vertex.outlineColor, width: 1 } }), hover: new u3({ style: "circle", size: D.vertex.hoverSize, color: D.vertex.hoverColor, outline: { color: D.vertex.hoverOutlineColor, width: 1 } }) }, rotatorLine: new m3({ color: D.line.color, width: 1 }) };
var V = class extends o.EventedAccessor {
  constructor(t2) {
    super(t2), this._activeHandleGraphic = null, this._graphicAttributes = { esriSketchTool: "box" }, this._mover = null, this._centerGraphic = null, this._backgroundGraphic = null, this._vertexGraphics = [], this._rotateHandleGraphic = null, this._rotateGraphicOffset = 20, this._angleOfRotation = 0, this._rotateLineGraphic = null, this._startInfo = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this.tooltip = null, this.type = "box", this.callbacks = { onMoveStart() {
    }, onMove() {
    }, onMoveStop() {
    }, onScaleStart() {
    }, onScale() {
    }, onScaleStop() {
    }, onRotateStart() {
    }, onRotate() {
    }, onRotateStop() {
    }, onGraphicClick() {
    } }, this.enableMovement = true, this.enableRotation = true, this.enableScaling = true, this.graphics = [], this.highlightName = null, this.highlightsEnabled = true, this.layer = null, this.preserveAspectRatio = false, this.showCenterGraphic = true, this.symbols = F, this.sketchOptions = new l2(), this.view = null, this._getBounds = (() => {
      const t3 = u2();
      return (e3, i4) => {
        e3[0] = Number.POSITIVE_INFINITY, e3[1] = Number.POSITIVE_INFINITY, e3[2] = Number.NEGATIVE_INFINITY, e3[3] = Number.NEGATIVE_INFINITY;
        for (const s3 of i4) {
          if (!s3) continue;
          let i5, o3, r3, a4;
          if ("point" === s3.type) i5 = r3 = s3.x, o3 = a4 = s3.y;
          else if ("multipoint" === s3.type) {
            const e4 = e(s3);
            [i5, o3, r3, a4] = x(t3, [e4]);
          } else if ("extent" === s3.type) [i5, o3, r3, a4] = [s3.xmin, s3.ymin, s3.xmax, s3.ymax];
          else {
            const e4 = e(s3);
            [i5, o3, r3, a4] = x(t3, e4);
          }
          e3[0] = Math.min(i5, e3[0]), e3[1] = Math.min(o3, e3[1]), e3[2] = Math.max(r3, e3[2]), e3[3] = Math.max(a4, e3[3]);
        }
        return e3;
      };
    })();
  }
  initialize() {
    const t2 = this.view;
    this._highlightHelper = new l3({ view: t2 }), this._setup(), this.addHandles([f((() => t2?.ready), (() => {
      const { layer: t3, view: e3 } = this;
      t(e3, t3);
    }), { once: true, initial: true }), l((() => this.preserveAspectRatio), (() => {
      this._activeHandleGraphic && (this._scaleGraphic(this._activeHandleGraphic), this._updateGraphics(), this._updateTooltip(this._activeHandleGraphic));
    })), l((() => t2?.scale), (() => {
      this._updateRotateGraphic(), this._updateRotateLineGraphic();
    })), l((() => this.graphics), (() => this.refresh())), l((() => this.layer), ((t3, e3) => {
      e3 && this._resetGraphics(e3), this.refresh();
    })), l((() => [this.highlightsEnabled, this.highlightName]), (() => {
      this._highlightHelper?.removeAll(), this._setUpHighlights();
    })), l((() => this.sketchOptions.tooltips.effectiveEnabled), ((e3) => {
      this.tooltip = e3 ? R((() => ({ view: t2, options: this.sketchOptions.tooltips }))) : u(this.tooltip);
    }), w), l((() => this.view.effectiveTheme.accentColor), (() => this._updateSymbolsForTheme()), h), this.on("move-start", ((t3) => this.callbacks?.onMoveStart?.(t3))), this.on("move", ((t3) => this.callbacks?.onMove?.(t3))), this.on("move-stop", ((t3) => this.callbacks?.onMoveStop?.(t3))), this.on("rotate-start", ((t3) => this.callbacks?.onRotateStart?.(t3))), this.on("rotate", ((t3) => this.callbacks?.onRotate?.(t3))), this.on("rotate-stop", ((t3) => this.callbacks?.onRotateStop?.(t3))), this.on("scale-start", ((t3) => this.callbacks?.onScaleStart?.(t3))), this.on("scale", ((t3) => this.callbacks?.onScale?.(t3))), this.on("scale-stop", ((t3) => this.callbacks?.onScaleStop?.(t3)))]);
  }
  destroy() {
    this._reset(), this.tooltip = u(this.tooltip);
  }
  get state() {
    const t2 = this.view?.ready ?? false, e3 = this.graphics.length && this.layer;
    return t2 && e3 ? "active" : t2 ? "ready" : "disabled";
  }
  isUIGraphic(t2) {
    return this._vertexGraphics.includes(t2) || t2 === this._backgroundGraphic || t2 === this._centerGraphic || t2 === this._rotateHandleGraphic || t2 === this._rotateLineGraphic;
  }
  move(t2, e3) {
    if (this._mover && this.graphics.length) {
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o3 = i(s3, t2, e3, this.view);
        i4.geometry = o3;
      }
      this.refresh(), this.emit("move-stop", new B(this.graphics, null, t2, e3));
    }
  }
  scale(t2, e3) {
    if (this._mover && this.graphics.length) {
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o3 = s(s3, t2, e3);
        i4.geometry = o3;
      }
      this.refresh(), this.emit("scale-stop", new X(this.graphics, null, t2, e3));
    }
  }
  rotate(t2, e3) {
    if (this._mover && this.graphics.length) {
      if (!e3) {
        const t3 = this._vertexGraphics[1].geometry.x, i4 = this._vertexGraphics[3].geometry.y;
        e3 = new _(t3, i4, this.view.spatialReference);
      }
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o3 = r2(s3, t2, e3);
        i4.geometry = o3;
      }
      this.refresh(), this.emit("rotate-stop", new Y(this.graphics, null, t2));
    }
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphics = [];
  }
  _setup() {
    "active" === this.state && (this._setUpHighlights(), this._setupGraphics(), this._setupMover(), this._updateGraphics());
  }
  _reset() {
    this._highlightHelper?.removeAll(), this._resetGraphicStateVars(), this._resetGraphics(), this._updateTooltip(), this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetGraphicStateVars() {
    this._startInfo = null, this._activeHandleGraphic = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this._angleOfRotation = 0;
  }
  _resetGraphics(t2) {
    (t2 = t2 || this.layer) && (t2.removeMany(this._vertexGraphics), t2.remove(this._backgroundGraphic), t2.remove(this._centerGraphic), t2.remove(this._rotateHandleGraphic), t2.remove(this._rotateLineGraphic)), this._vertexGraphics.forEach(((t3) => !t3.destroyed && t3.destroy())), !this._backgroundGraphic.destroyed && this._backgroundGraphic.destroy(), !this._centerGraphic.destroyed && this._centerGraphic.destroy(), !this._rotateHandleGraphic.destroyed && this._rotateHandleGraphic.destroy(), !this._rotateLineGraphic.destroyed && this._rotateLineGraphic.destroy(), this._vertexGraphics = [], this._backgroundGraphic = null, this._centerGraphic = null, this._rotateHandleGraphic = null, this._rotateLineGraphic = null;
  }
  _setupMover() {
    let t2 = [];
    this.enableScaling && (t2 = t2.concat(this._vertexGraphics)), this.enableRotation && t2.push(this._rotateHandleGraphic), this.enableMovement && (t2 = t2.concat(this.graphics, this._backgroundGraphic)), this.showCenterGraphic && t2.push(this._centerGraphic), this._mover = new j({ enableMoveAllGraphics: false, highlightsEnabled: false, indicatorsEnabled: false, view: this.view, graphics: t2, callbacks: { onGraphicClick: (t3) => this._onGraphicClickCallback(t3), onGraphicMoveStart: (t3) => this._onGraphicMoveStartCallback(t3), onGraphicMove: (t3) => this._onGraphicMoveCallback(t3), onGraphicMoveStop: (t3) => this._onGraphicMoveStopCallback(t3), onGraphicPointerOver: (t3) => this._onGraphicPointerOverCallback(t3), onGraphicPointerOut: (t3) => this._onGraphicPointerOutCallback(t3) } });
  }
  _getStartInfo(t2) {
    const [e3, i4, s3, o3] = this._getBoxBounds(u2()), r3 = Math.abs(s3 - e3), a4 = Math.abs(o3 - i4), h4 = (s3 + e3) / 2, c = (o3 + i4) / 2, { x: n, y: l4 } = t2.geometry;
    return { width: r3, height: a4, centerX: h4, centerY: c, startX: n, startY: l4, graphicInfos: this._getGraphicInfos(), box: this._backgroundGraphic.geometry, rotate: this._rotateHandleGraphic.geometry };
  }
  _getGraphicInfos() {
    return this.graphics.map(((t2) => this._getGraphicInfo(t2)));
  }
  _getGraphicInfo(t2) {
    const e3 = t2.geometry, [i4, s3, o3, r3] = this._getBounds(u2(), [e3]);
    return { width: Math.abs(o3 - i4), height: Math.abs(r3 - s3), centerX: (o3 + i4) / 2, centerY: (r3 + s3) / 2, geometry: e3 };
  }
  _onGraphicClickCallback(t2) {
    t2.viewEvent.stopPropagation(), this.emit("graphic-click", t2), this.callbacks.onGraphicClick && this.callbacks.onGraphicClick(t2);
  }
  _onGraphicMoveStartCallback(t2) {
    const { _angleOfRotation: e3, _xScale: i4, _yScale: s3, _backgroundGraphic: o3, _vertexGraphics: r3, _rotateHandleGraphic: a4, symbols: h4 } = this, c = t2.graphic;
    this._resetGraphicStateVars(), this._hideGraphicsBeforeUpdate(), o3.symbol = h4.fill.active, this._startInfo = this._getStartInfo(c), this._updateTooltip(c, t2.viewEvent), c === a4 ? (this.view.cursor = "grabbing", this.emit("rotate-start", new N(this.graphics, c, e3))) : r3.includes(c) ? (this._activeHandleGraphic = c, this.emit("scale-start", new P2(this.graphics, c, i4, s3))) : this.emit("move-start", new E(this.graphics, c, t2.dx, t2.dy));
  }
  _onGraphicMoveCallback(t2) {
    const e3 = t2.graphic;
    if (this._startInfo) if (this._vertexGraphics.includes(e3)) this._scaleGraphic(e3), this._updateTooltip(e3, t2.viewEvent), this.emit("scale", new A(this.graphics, e3, this._xScale, this._yScale));
    else if (e3 === this._rotateHandleGraphic) this._rotateGraphic(e3), this._updateTooltip(e3, t2.viewEvent), this.emit("rotate", new U(this.graphics, e3, this._angleOfRotation));
    else {
      const { dx: i4, dy: s3 } = t2;
      this._totalDx += i4, this._totalDy += s3, this._moveGraphic(e3, i4, s3), this._updateTooltip(e3, t2.viewEvent), this.emit("move", new z(this.graphics, e3, i4, s3));
    }
  }
  _onGraphicMoveStopCallback(t2) {
    const e3 = t2.graphic;
    if (!this._startInfo) return void this.refresh();
    const { _angleOfRotation: i4, _totalDx: s3, _totalDy: o3, _xScale: r3, _yScale: a4, _vertexGraphics: h4, _rotateHandleGraphic: c } = this;
    this.refresh(), e3 === c ? (this.view.cursor = "pointer", this.emit("rotate-stop", new Y(this.graphics, e3, i4))) : h4.includes(e3) ? this.emit("scale-stop", new X(this.graphics, e3, r3, a4)) : this.emit("move-stop", new B(this.graphics, e3, s3, o3));
  }
  _onGraphicPointerOverCallback(t2) {
    const { _backgroundGraphic: e3, _vertexGraphics: i4, graphics: s3, _rotateHandleGraphic: o3, symbols: r3, view: a4 } = this, h4 = t2.graphic;
    if (this._hoveredGraphic = h4, h4 === o3) return o3.symbol = r3.rotator.hover, a4.cursor = "pointer", void this._updateTooltip(h4);
    if (s3.includes(h4) || h4 === e3) return void (a4.cursor = "move");
    if (!i4.includes(h4)) return void (a4.cursor = "pointer");
    this._updateTooltip(h4), t2.graphic.symbol = r3.handles.hover;
    const c = a4.rotation;
    let n, l4 = t2.index;
    switch (l4 < 8 && (c >= 0 && c < 45 ? l4 %= 8 : l4 = c >= 45 && c < 90 ? (l4 + 1) % 8 : c >= 90 && c < 135 ? (l4 + 2) % 8 : c >= 135 && c < 180 ? (l4 + 3) % 8 : c >= 180 && c < 225 ? (l4 + 4) % 8 : c >= 225 && c < 270 ? (l4 + 5) % 8 : c >= 270 && c < 315 ? (l4 + 6) % 8 : (l4 + 7) % 8), l4) {
      case 0:
      case 4:
        n = "nwse-resize";
        break;
      case 1:
      case 5:
        n = "ns-resize";
        break;
      case 2:
      case 6:
        n = "nesw-resize";
        break;
      case 3:
      case 7:
        n = "ew-resize";
        break;
      default:
        n = "pointer";
    }
    a4.cursor = n;
  }
  _onGraphicPointerOutCallback(t2) {
    const { _vertexGraphics: e3, _rotateHandleGraphic: i4, symbols: s3, view: o3 } = this;
    this._hoveredGraphic = null, t2.graphic === i4 ? i4.symbol = s3.rotator.default : e3.includes(t2.graphic) && (t2.graphic.symbol = s3.handles.default), o3.cursor = "default", this._updateTooltip();
  }
  _scaleGraphic(t2) {
    const { _startInfo: e3, _vertexGraphics: i4, preserveAspectRatio: s3, view: o3 } = this, { centerX: r3, centerY: a4, graphicInfos: h4, height: c, startX: n, startY: l4, width: _2 } = e3, { resolution: d2, transform: m6 } = o3.state, u4 = i4.indexOf(t2);
    1 !== u4 && 5 !== u4 || this._updateX(t2, r3), 3 !== u4 && 7 !== u4 || this._updateY(t2, a4);
    const { x: g, y: y2 } = t2.geometry, v = m6[0] * g + m6[2] * y2 + m6[4], f2 = m6[1] * g + m6[3] * y2 + m6[5], G = h4?.map(((t3) => t3.geometry)) ?? [], S = G.every(((t3) => "point" === t3.type));
    if ((0 === _2 || 0 === c) && S) {
      const t3 = q((g - n) / d2), i5 = q((l4 - y2) / d2);
      for (let e4 = 0; e4 < G.length; e4++) this.graphics[e4].geometry = i(G[e4], t3, i5, o3, true);
      return this._centerGraphic.geometry = new _(g, y2, o3.spatialReference), void (this._backgroundGraphic.geometry = i(e3.box, t3, i5, o3, true));
    }
    if (s3) {
      const t3 = q(m6[0] * r3 + m6[2] * a4 + m6[4], 2), e4 = q(m6[1] * r3 + m6[3] * a4 + m6[5], 2), i5 = q(m6[0] * n + m6[2] * l4 + m6[4], 2), s4 = q(m6[1] * n + m6[3] * l4 + m6[5], 2);
      let o4 = a3(t3, e4, i5, s4, v, f2);
      0 !== o4 && Math.abs(o4) !== 1 / 0 || (o4 = 1), this._xScale = this._yScale = o4;
      for (const h5 of G) {
        const t4 = G.indexOf(h5);
        this.graphics[t4].geometry = s(h5, this._xScale, this._yScale, [r3, a4]);
      }
      this._updateBackgroundGraphic();
    } else {
      let t3 = g - n, i5 = l4 - y2;
      if (1 === u4 || 5 === u4 ? t3 = 0 : 3 !== u4 && 7 !== u4 || (i5 = 0), 0 === t3 && 0 === i5) return;
      const s4 = r3 + t3 / 2, h5 = a4 + i5 / 2;
      let m7 = (_2 + (n > r3 ? t3 : -1 * t3)) / _2, v2 = (c + (l4 < a4 ? i5 : -1 * i5)) / c;
      1 !== u4 && 5 !== u4 && 0 !== m7 && Math.abs(m7) !== 1 / 0 || (m7 = 1), 3 !== u4 && 7 !== u4 && 0 !== v2 && Math.abs(v2) !== 1 / 0 || (v2 = 1), this._xScale = m7, this._yScale = v2;
      const f3 = (s4 - r3) / d2, x2 = (h5 - a4) / d2, S2 = s(e3.box, this._xScale, this._yScale);
      this._backgroundGraphic.geometry = i(S2, f3, x2, o3, true);
      const { centerX: k, centerY: R2 } = this._getGraphicInfo(this._backgroundGraphic), M = (k - r3) / d2, I = -1 * (R2 - a4) / d2;
      for (const e4 of G) {
        const t4 = G.indexOf(e4), i6 = s(e4, this._xScale, this._yScale, [r3, a4]);
        this.graphics[t4].geometry = i(i6, M, I, o3, true);
      }
      this._centerGraphic.geometry = new _(k, R2, o3.spatialReference);
    }
  }
  _rotateGraphic(t2) {
    const { centerX: e3, centerY: i4, startX: s3, startY: o3, box: r3, rotate: a4 } = this._startInfo, h4 = this.view.spatialReference, c = new _(s3, o3, h4), n = new _(e3, i4, h4), l4 = t2.geometry;
    this._angleOfRotation = m5(c, l4, n);
    const _2 = this._startInfo.graphicInfos?.map(((t3) => t3.geometry)) ?? [];
    for (const p of _2) {
      const t3 = _2.indexOf(p), e4 = r2(p, this._angleOfRotation, n);
      this.graphics[t3].geometry = e4;
    }
    this._backgroundGraphic.geometry = r2(r3, this._angleOfRotation, n), this._rotateHandleGraphic.geometry = r2(a4, this._angleOfRotation, n);
  }
  _moveGraphic(t2, e3, i4) {
    if (this.graphics.includes(t2)) {
      const s3 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = i(s3, e3, i4, this.view);
      for (const o3 of this.graphics) o3 !== t2 && (o3.geometry = i(o3.geometry, e3, i4, this.view));
    } else if (t2 === this._centerGraphic) {
      const t3 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = i(t3, e3, i4, this.view);
    }
    if (t2 === this._backgroundGraphic || t2 === this._centerGraphic) for (const s3 of this.graphics) s3.geometry = i(s3.geometry, e3, i4, this.view);
  }
  _setUpHighlights() {
    this.highlightsEnabled && this.graphics.length && this._highlightHelper?.add(this.graphics, this.highlightName);
  }
  _setupGraphics() {
    const { _graphicAttributes: t2, symbols: i4 } = this;
    this._centerGraphic = new d({ symbol: i4.centerIndicator, attributes: t2 }), this.showCenterGraphic && this.layer.add(this._centerGraphic), this._backgroundGraphic = new d({ symbol: i4.fill.default, attributes: t2 }), this.layer.add(this._backgroundGraphic), this._rotateLineGraphic = new d({ symbol: i4.rotatorLine, attributes: t2 }), this._rotateHandleGraphic = new d({ symbol: i4.rotator.default, attributes: t2 }), this.enableRotation && !this._hasExtentGraphic() && this.layer.addMany([this._rotateLineGraphic, this._rotateHandleGraphic]);
    for (let s3 = 0; s3 < 8; s3++) this._vertexGraphics.push(new d({ symbol: i4.handles.default, attributes: t2 }));
    this.enableScaling && this.layer.addMany(this._vertexGraphics);
  }
  _updateSymbolsForTheme() {
    const t2 = this.view.effectiveTheme.accentColor;
    this.symbols = { ...this.symbols, fill: { active: this.symbols.fill.active?.clone().set("outline.color", t2), default: this.symbols.fill.default?.clone().set("outline.color", t2) }, handles: { ...this.symbols.handles, default: this.symbols.handles.default.clone().set("outline.color", t2) }, rotator: { ...this.symbols.rotator, default: this.symbols.rotator.default.clone().set("outline.color", t2) }, rotatorLine: this.symbols.rotatorLine.clone().set("color", t2) };
    for (const e3 of this._vertexGraphics) e3.symbol = e3 === this._hoveredGraphic ? this.symbols.handles.hover : this.symbols.handles.default;
    this._backgroundGraphic.symbol = this.symbols.fill.default, this._rotateHandleGraphic.symbol = this._rotateHandleGraphic === this._hoveredGraphic ? this.symbols.rotator.hover : this.symbols.rotator.default, this._rotateLineGraphic.symbol = this.symbols.rotatorLine;
  }
  _updateGraphics() {
    this._updateBackgroundGraphic(), this._updateHandleGraphics(), this._updateCenterGraphic(), this._updateRotateGraphic(), this._updateRotateLineGraphic();
  }
  _hideGraphicsBeforeUpdate() {
    this._centerGraphic.visible = false, this._rotateHandleGraphic.visible = false, this._rotateLineGraphic.visible = false, this._vertexGraphics.forEach(((t2) => t2.visible = false));
  }
  _updateHandleGraphics() {
    const t2 = this._getCoordinates(true);
    this._vertexGraphics.forEach(((e3, i4) => {
      const [s3, o3] = t2[i4];
      this._updateXY(e3, s3, o3);
    }));
  }
  _updateBackgroundGraphic() {
    const t2 = this._getCoordinates().map((([t3, e3]) => [t3, e3]));
    this._backgroundGraphic.geometry = new P({ rings: [t2], spatialReference: this.view.spatialReference });
  }
  _updateCenterGraphic() {
    const [t2, e3, i4, s3] = this._getBoxBounds(u2()), o3 = (i4 + t2) / 2, r3 = (s3 + e3) / 2;
    this._centerGraphic.geometry = new _(o3, r3, this.view.spatialReference);
  }
  _updateRotateGraphic() {
    if (!this._vertexGraphics.length) return;
    const { x: t2, y: e3 } = this._vertexGraphics[1].geometry, i4 = e3 + this.view.state.resolution * this._rotateGraphicOffset;
    this._rotateHandleGraphic.geometry = new _(t2, i4, this.view.spatialReference);
  }
  _updateRotateLineGraphic() {
    if (!this._vertexGraphics.length || !this._rotateHandleGraphic?.geometry) return;
    const t2 = this._vertexGraphics[1].geometry, e3 = this._rotateHandleGraphic.geometry;
    this._rotateLineGraphic.geometry = new y({ paths: [[[t2.x, t2.y], [e3.x, e3.y]]], spatialReference: this.view.spatialReference });
  }
  _updateXY(t2, e3, i4) {
    t2.geometry = new _(e3, i4, this.view.spatialReference);
  }
  _updateX(t2, e3) {
    const i4 = t2.geometry.y;
    t2.geometry = new _(e3, i4, this.view.spatialReference);
  }
  _updateY(t2, e3) {
    const i4 = t2.geometry.x;
    t2.geometry = new _(i4, e3, this.view.spatialReference);
  }
  _hasExtentGraphic() {
    return this.graphics.some(((t2) => null != t2?.geometry && "extent" === t2.geometry.type));
  }
  _getBoxBounds(t2) {
    const e3 = this.graphics.map(((t3) => t3.geometry));
    return this._getBounds(t2, e3);
  }
  _getCoordinates(t2) {
    const [e3, i4, s3, o3] = this._getBoxBounds(u2());
    if (t2) {
      const t3 = (e3 + s3) / 2, r3 = (o3 + i4) / 2;
      return [[e3, o3], [t3, o3], [s3, o3], [s3, r3], [s3, i4], [t3, i4], [e3, i4], [e3, r3]];
    }
    return [[e3, o3], [s3, o3], [s3, i4], [e3, i4]];
  }
  _updateTooltip(t2, e3) {
    if (null == this.tooltip) return;
    if (!t2) return void this.tooltip.clear();
    const { _backgroundGraphic: i4, graphics: s3, _vertexGraphics: o3, _rotateHandleGraphic: r3 } = this;
    t2 === r3 ? this._updateRotateTooltip() : o3.includes(t2) ? this._updateScaleTooltip() : (s3.includes(t2) || t2 === i4) && this._updateMoveTooltip(e3);
  }
  _updateRotateTooltip() {
    null != this.tooltip && (this.tooltip.info = new s2({ sketchOptions: this.sketchOptions, angle: -this._angleOfRotation }));
  }
  _updateScaleTooltip() {
    const { tooltip: t2, _xScale: e3, _yScale: i4, sketchOptions: s3, view: o3, automaticLengthMeasurementUtils: r3 } = this;
    if (null == t2) return;
    const a4 = this._getCoordinates(), h4 = e2({ topLeft: a4[0], topRight: a4[1], bottomRight: a4[2], bottomLeft: a4[3], spatialReference: o3.spatialReference, automaticLengthMeasurementUtils: r3 });
    if (null == h4) return;
    const { xSize: c, ySize: n } = h4, l4 = Math.abs(e3), p = Math.abs(i4);
    t2.info = new i3({ sketchOptions: s3, xScale: l4, yScale: p, xSize: c, ySize: n });
  }
  _updateMoveTooltip(t2) {
    const { tooltip: e3, sketchOptions: i4, view: s3, automaticLengthMeasurementUtils: r3 } = this;
    if (null == e3) return;
    const a4 = new i2({ sketchOptions: i4 });
    if (t2) {
      const { x: e4, y: i5 } = t2.origin, h4 = s3.toMap(t2), c = s3.toMap({ x: e4, y: i5 }), n = r3.autoDistanceBetweenPoints2D(c, h4);
      a4.distance = null != n ? n : h2;
    }
    e3.info = a4;
  }
};
function q(t2, e3 = 2) {
  return Number.parseFloat(t2.toFixed(e3));
}
r([m()], V.prototype, "tooltip", void 0), r([m({ readOnly: true })], V.prototype, "type", void 0), r([m()], V.prototype, "callbacks", void 0), r([m()], V.prototype, "enableMovement", void 0), r([m()], V.prototype, "enableRotation", void 0), r([m()], V.prototype, "enableScaling", void 0), r([m()], V.prototype, "graphics", void 0), r([m()], V.prototype, "highlightName", void 0), r([m()], V.prototype, "highlightsEnabled", void 0), r([m()], V.prototype, "layer", void 0), r([m()], V.prototype, "preserveAspectRatio", void 0), r([m()], V.prototype, "showCenterGraphic", void 0), r([m({ readOnly: true })], V.prototype, "state", null), r([m()], V.prototype, "symbols", void 0), r([m({ type: l2 })], V.prototype, "sketchOptions", void 0), r([m({ constructOnly: true })], V.prototype, "view", void 0), r([m({ constructOnly: true })], V.prototype, "automaticLengthMeasurementUtils", void 0), V = r([a("esri.views.draw.support.Box")], V);
var J = V;
export {
  J as default
};
//# sourceMappingURL=Box-EQJA63GV.js.map
