import {
  A,
  C,
  D,
  E,
  Ie,
  P,
  _ as _3,
  a as a2,
  b as b3,
  g,
  h2 as h,
  i as i2,
  i2 as i3,
  m2,
  o as o2,
  o2 as o3,
  u as u3,
  v
} from "./chunk-ZJG4IQZH.js";
import {
  I,
  S as S2,
  _ as _2,
  o,
  t as t3
} from "./chunk-YGH5IYUW.js";
import "./chunk-YGPPU7AB.js";
import "./chunk-VFKFSI5B.js";
import "./chunk-SZ4I37ZN.js";
import {
  ue
} from "./chunk-7RVS6KUX.js";
import "./chunk-QYQAGD6G.js";
import "./chunk-Y6UIOJ4V.js";
import "./chunk-XFDQFUMH.js";
import "./chunk-QHWOGFQV.js";
import "./chunk-PUDEDAPY.js";
import "./chunk-JXBJIDCW.js";
import "./chunk-RWIBDRMM.js";
import "./chunk-MWIJEAM3.js";
import "./chunk-BGSPX4Z3.js";
import "./chunk-WBA6DQSU.js";
import "./chunk-BB6EK2RQ.js";
import "./chunk-R3HU2OBM.js";
import "./chunk-3ESJRJZD.js";
import "./chunk-L6GG77AZ.js";
import "./chunk-XOKYRVJ5.js";
import "./chunk-D2DRG2DH.js";
import "./chunk-2DCDAX3U.js";
import "./chunk-EZ5REY53.js";
import "./chunk-3HYSKSYM.js";
import "./chunk-EWP4DLQF.js";
import {
  p
} from "./chunk-CHGKJUJ3.js";
import "./chunk-3YBQQHIP.js";
import "./chunk-OJQCHQYS.js";
import {
  t as t2
} from "./chunk-N3W3EVP3.js";
import {
  b2,
  y as y2
} from "./chunk-ZJXLBTN2.js";
import "./chunk-SIRTOV2N.js";
import "./chunk-V7CFMRVF.js";
import "./chunk-LINWZZJL.js";
import "./chunk-QZISYUPA.js";
import "./chunk-HQRWZZNA.js";
import "./chunk-CKFS2QIU.js";
import "./chunk-PI2R2EZ2.js";
import "./chunk-JLGVQWP5.js";
import "./chunk-LCT65JMM.js";
import "./chunk-IR6JOM7Y.js";
import "./chunk-MK7DDFJN.js";
import {
  S
} from "./chunk-OFINLTIW.js";
import "./chunk-TIU3P5HE.js";
import "./chunk-EU5HNJUP.js";
import "./chunk-CJSURDZH.js";
import "./chunk-FFY3IMAS.js";
import "./chunk-YT2ORY5Z.js";
import "./chunk-2UINVE7X.js";
import "./chunk-KXZAYF3U.js";
import "./chunk-PHSQVJNW.js";
import "./chunk-KFNWBWN4.js";
import "./chunk-K55CXVYD.js";
import "./chunk-Q37ABIVM.js";
import "./chunk-VFMQPCCZ.js";
import "./chunk-63ZT5BWV.js";
import "./chunk-OPQ3FCJ4.js";
import "./chunk-W3BJJE6D.js";
import "./chunk-UZ3YWBWC.js";
import "./chunk-2EOHKZLO.js";
import "./chunk-CYQZCOHI.js";
import "./chunk-S7GLMIAQ.js";
import "./chunk-E3X3R7JS.js";
import "./chunk-5J3DOLRD.js";
import "./chunk-ITDL4YVK.js";
import "./chunk-LDDUMPNU.js";
import "./chunk-CCQBS25D.js";
import "./chunk-PXNA3G6N.js";
import "./chunk-OUR2XGMQ.js";
import "./chunk-TSHXWKM2.js";
import "./chunk-KZ2G7XW2.js";
import "./chunk-YIVJSMJO.js";
import "./chunk-QMUTCCDX.js";
import {
  ut
} from "./chunk-24S6C5S6.js";
import "./chunk-7Y4U2JD3.js";
import "./chunk-GCTSCKPO.js";
import "./chunk-6U4EGJOK.js";
import "./chunk-W7U4L72B.js";
import "./chunk-OXO3GGCE.js";
import "./chunk-BOPGQCAL.js";
import "./chunk-C4HV45QS.js";
import "./chunk-FB53UFVR.js";
import "./chunk-UICDKBDP.js";
import "./chunk-HRIEIPLV.js";
import "./chunk-RWNJO2QP.js";
import "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-DDDZPNGZ.js";
import "./chunk-XVEUTBL6.js";
import "./chunk-LQQCPLIT.js";
import "./chunk-4O46EK5T.js";
import "./chunk-4R7TSTKL.js";
import "./chunk-UO2UKPG5.js";
import "./chunk-EMULKSUV.js";
import "./chunk-AY3JR4QM.js";
import "./chunk-YG6ILDTP.js";
import "./chunk-DKFJHHQ4.js";
import "./chunk-Z34SUCTX.js";
import "./chunk-A2AZM62Y.js";
import "./chunk-LQYJLB4P.js";
import "./chunk-D6GGPM6D.js";
import "./chunk-FQY65CBA.js";
import "./chunk-HH4Q2NN5.js";
import "./chunk-S5G7D7MX.js";
import "./chunk-6BZTNQVP.js";
import "./chunk-IR4HVW2K.js";
import "./chunk-OT2P27SF.js";
import "./chunk-XJOLJK3F.js";
import "./chunk-3CFYBBSV.js";
import "./chunk-ZVNJ2S2Z.js";
import "./chunk-KPGNM4LZ.js";
import "./chunk-AACFCXAP.js";
import "./chunk-P5DG4SNT.js";
import "./chunk-ZT7UIVVR.js";
import {
  h as h2
} from "./chunk-R25QZWQ7.js";
import "./chunk-BELQIHLO.js";
import "./chunk-BPI4BR4E.js";
import "./chunk-YVMULGDJ.js";
import "./chunk-CJDZN5K5.js";
import "./chunk-N77BULFI.js";
import "./chunk-6TZIEYTZ.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-7WPGDYQW.js";
import "./chunk-QDOFETFN.js";
import "./chunk-A6R2FXH6.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-3TSZDV6B.js";
import "./chunk-P4O4YCLI.js";
import "./chunk-FV6ZNHFI.js";
import "./chunk-MSSQA3XK.js";
import "./chunk-PBKE5BCM.js";
import "./chunk-FOALQHMM.js";
import "./chunk-7HS3ESHX.js";
import "./chunk-2CS746FZ.js";
import "./chunk-NEI5HAVK.js";
import "./chunk-RCOFAQFP.js";
import "./chunk-CO2J5JPW.js";
import "./chunk-CHAHOTAY.js";
import "./chunk-RZGBA4KS.js";
import "./chunk-FSYN2HHU.js";
import "./chunk-7I4TWCTW.js";
import "./chunk-W5UOLFE2.js";
import "./chunk-AZ2S2PYZ.js";
import "./chunk-SCMB64VM.js";
import "./chunk-FOPBVVXE.js";
import "./chunk-INI6MHIQ.js";
import "./chunk-R7YP6EQJ.js";
import "./chunk-QUZZIDFR.js";
import "./chunk-CBCDVQSA.js";
import {
  V
} from "./chunk-74GULGYB.js";
import "./chunk-RKF6WUZT.js";
import {
  y
} from "./chunk-RMRI4NYS.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-BLBN3L5Q.js";
import "./chunk-5EWIWLNU.js";
import "./chunk-TOCH3L2K.js";
import {
  z
} from "./chunk-CBXZL53X.js";
import {
  U,
  l
} from "./chunk-HYAO4PVV.js";
import "./chunk-SRNKPAJX.js";
import "./chunk-MOMLPET6.js";
import "./chunk-VNQUG2TO.js";
import "./chunk-EULNFFHG.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-LPCUYJ2B.js";
import "./chunk-3QHX4R4B.js";
import {
  _
} from "./chunk-SMO33YG7.js";
import "./chunk-LCBAL6ER.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import "./chunk-67AKDROO.js";
import "./chunk-CM3TIXEV.js";
import "./chunk-2AYGXVZI.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-WO5FLTVY.js";
import "./chunk-MGA7XBRB.js";
import "./chunk-XNUSHDFN.js";
import "./chunk-4AKMPOG7.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-APMQAZ5Z.js";
import "./chunk-ZJQPHR3K.js";
import "./chunk-NJZD7WM5.js";
import "./chunk-CL7VLXUR.js";
import "./chunk-FCX4ZA3Z.js";
import {
  e,
  m2 as m,
  t2 as t
} from "./chunk-2ZPU5IZX.js";
import {
  a2 as a
} from "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import {
  u
} from "./chunk-JNYZ3I5R.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import {
  b,
  s as s2,
  u3 as u2
} from "./chunk-N626Y23H.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/knowledgeGraph/IdealEdgeLengthTypeOptions.js
var e2;
!(function(e3) {
  e3.MULTIPLIER = "multiplier", e3.ABSOLUTE = "absolute-value";
})(e2 || (e2 = {}));

// node_modules/@arcgis/core/layers/LinkChartLayer.js
var q = class extends b2(p(t2(S(h2)))) {
  constructor(e3) {
    if (super(e3), this.url = null, this.dataPreloadedInLocalCache = false, this.initializationLinkChartConfig = null, this.membershipModified = true, this._currentLinkChartConfig = { layoutMode: "organic-standard" }, this._graphTypeLookup = /* @__PURE__ */ new Map(), this.dataManager = null, this.knowledgeGraph = null, this.layers = new (V.ofType(Ie))(), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.linkChartExtent = new z({ xmin: -1e-7, ymin: -1e-7, xmax: 1e-7, ymax: 1e-7 }), this.memberEntityTypes = null, this.memberRelationshipTypes = null, this.operationalLayerType = "LinkChartLayer", this.sublayerIdsCache = /* @__PURE__ */ new Map(), this.tables = new (V.ofType(Ie))(), this.type = "link-chart", this.chronologicalAuxiliaryGraphics = null, this._originalInclusionList = e3?.initializationInclusionModeDefinition, e3?.dataPreloadedInLocalCache && !e3?.initializationInclusionModeDefinition) throw new s("knowledge-graph:linkchart-layer-constructor", "If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it");
    this.addHandles(l((() => this.layers.concat(this.tables)), ((e4, t4) => this._handleSublayersChange(e4, t4)), U));
  }
  normalizeCtorArgs(e3) {
    if (!e3) return {};
    const { url: t4, title: a3, dataPreloadedInLocalCache: i4, initializationLinkChartConfig: n } = e3;
    return { url: t4, title: a3, dataPreloadedInLocalCache: i4, initializationLinkChartConfig: n };
  }
  _initializeLayerProperties(e3) {
    if (!this.title && this.url) {
      const e4 = this.url.split("/");
      this.title = e4[e4.length - 2];
    }
    const t4 = /* @__PURE__ */ new Set();
    let a3 = [], o4 = [];
    if (e3.inclusionModeDefinition && (!e3.inclusionModeDefinition.namedTypeDefinitions || e3.inclusionModeDefinition.namedTypeDefinitions.size < 1)) throw new s("knowledge-graph:composite-layer-constructor", "If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");
    e3.inclusionModeDefinition?.generateAllSublayers ? (a3 = e3.knowledgeGraph.dataModel.entityTypes ?? [], o4 = e3.knowledgeGraph.dataModel.relationshipTypes ?? []) : e3.inclusionModeDefinition?.namedTypeDefinitions && e3.inclusionModeDefinition?.namedTypeDefinitions.size > 0 ? e3.inclusionModeDefinition?.namedTypeDefinitions.forEach(((i4, s4) => {
      const r2 = this._graphTypeLookup.get(s4);
      if (!r2) return i.getLogger(this).warn(`A named type, ${s4}, was in the inclusion list that wasn't in the data model and will be removed`), void e3.inclusionModeDefinition?.namedTypeDefinitions.delete(s4);
      "relationship" === r2.type ? t4.has(s4) || (t4.add(s4), o4.push(r2)) : "entity" === r2.type ? t4.has(s4) || (t4.add(s4), a3.push(r2)) : (i.getLogger(this).warn(`A named type, ${s4}, was in the inclusion list that wasn't properly modeled and will be removed`), e3.inclusionModeDefinition?.namedTypeDefinitions.delete(s4));
    })) : (a3 = e3.knowledgeGraph.dataModel.entityTypes ?? [], o4 = e3.knowledgeGraph.dataModel.relationshipTypes ?? []);
    const s3 = new E({ knowledgeGraph: e3.knowledgeGraph, inclusionModeDefinition: e3.inclusionModeDefinition });
    this.knowledgeGraph = e3.knowledgeGraph, this.memberEntityTypes = a3, this.memberRelationshipTypes = o4, this.dataManager = s3;
  }
  load(e3) {
    const a3 = async () => {
      const e4 = [], t4 = [];
      this.loadLayerAssumingLocalCache(), this._layersLoadedFromAuthoritativeItem() || await i3(this), this.dataManager.inclusionModeDefinition && (this.dataManager.inclusionModeDefinition.generateAllSublayers = false), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach(((e5) => {
        e5.useAllData = false;
      })), await this._initializeDiagram(), this.layers.forEach(((a4) => {
        t4.push(a4.refreshCachedQueryEngine()), e4.push(new Promise(((e5) => {
          a4.on("layerview-create", (() => {
            e5(null);
          }));
        })));
      })), this.tables.forEach(((e5) => {
        t4.push(e5.refreshCachedQueryEngine());
      })), await Promise.all(t4);
    };
    return this.addResolvingPromise(new Promise(((i4) => {
      ue(this.url).then((async (n) => {
        n.dataModel.entityTypes?.forEach(((e4) => {
          e4.name && this._graphTypeLookup.set(e4.name, e4);
        })), n.dataModel.relationshipTypes?.forEach(((e4) => {
          e4.name && this._graphTypeLookup.set(e4.name, e4);
        }));
        const s3 = this.linkChart?.linkChartProperties;
        if (s3?.originIdOf("entitiesUrl") === e.LINK_CHART && (this.membershipModified = false, this._originalInclusionList = await D.fetchAndConvertSerializedLinkChart({ entitiesUrl: s3?.entitiesUrl, relationshipsUrl: s3?.relationshipsUrl }), this._alignLayersDataModelAndInclusionDefinition(n.dataModel), this.initializationLinkChartConfig = { layoutSettings: s3?.layoutSettings ?? void 0, layoutMode: C(s3.layoutType) }), this._initializeLayerProperties({ knowledgeGraph: n, inclusionModeDefinition: this._originalInclusionList }), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.size || (this.dataManager.inclusionModeDefinition = { generateAllSublayers: false, namedTypeDefinitions: /* @__PURE__ */ new Map() }, this.dataManager.knowledgeGraph.dataModel.entityTypes?.forEach(((e4) => {
          e4.name && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e4.name, { useAllData: true });
        })), this.dataManager.knowledgeGraph.dataModel.relationshipTypes?.forEach(((e4) => {
          e4.name && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e4.name, { useAllData: true });
        }))), this.dataPreloadedInLocalCache) {
          const e4 = o2.getInstance();
          for (const [t4, a4] of this.dataManager.inclusionModeDefinition?.namedTypeDefinitions ?? []) for (const i5 of a4.members?.values() ?? []) {
            const a5 = e4.readFromStoreById(`${t4}__${i5.id}`);
            if (a5) {
              u(this.dataManager.sublayerCaches, t4, (() => /* @__PURE__ */ new Map())).set(i5.id, a5);
            }
          }
          await a3();
        } else {
          const t4 = "geographic-organic-standard" === this.initializationLinkChartConfig?.layoutMode;
          this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0, false, t4, true).then((async () => {
            s2(e3), await a3();
          })));
        }
        i4(null);
      }));
    }))), Promise.resolve(this);
  }
  set initializationInclusionModeDefinition(e3) {
    "loaded" !== this.loadStatus && "failed" !== this.loadStatus ? this._set("initializationInclusionModeDefinition", e3) : i.getLogger(this).error("#initializationInclusionModeDefinition", "initializationInclusionModeDefinition cannot be changed after the layer is loaded.");
  }
  get linkChart() {
    return this.parent;
  }
  async addRecords(e3, t4) {
    let a3 = [];
    t4?.cascadeAddRelationshipEndNodes && this.dataManager.knowledgeGraph.dataModel && (a3 = await g(e3, this.dataManager.knowledgeGraph));
    const i4 = e3.concat(a3).filter(((e4) => !this.sublayerIdsCache.get(e4.typeName)?.has(e4.id)));
    i4.length > 0 && (this.membershipModified = true), await this._handleNewRecords(i4, t4);
  }
  async createSublayerForNamedType(e3) {
    await this.load();
    const t4 = this._graphTypeLookup.get(e3);
    if (!t4) throw new s("knowledge-graph:missing-type", "The specified type does not exist in the knowledge graph.");
    if (this.dataManager.sublayerCaches.has(e3)) throw new s("knowledge-graph:duplicate-type", "The specified type already exists as a sublayer.");
    this.dataManager.sublayerCaches.set(e3, /* @__PURE__ */ new Map()), u(this.sublayerIdsCache, e3, (() => /* @__PURE__ */ new Set()));
    const a3 = this._createSublayer(t4);
    return "entity" === t4.type ? this.dataManager.entityTypeNames.add(e3) : this.dataManager.relationshipTypeNames.add(e3), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.set(e3, { useAllData: false, members: /* @__PURE__ */ new Map() }), a3.geometryType ? this.layers.push(a3) : this.tables.push(a3), await i3(this, [e3]), this._refreshNamedTypes(), a3;
  }
  async removeRecords(e3, { cascadeRemoveRelationships: t4 = true, recalculateLayout: a3 = false, overrideMembershipCheck: i4 = false } = { cascadeRemoveRelationships: true, recalculateLayout: false, overrideMembershipCheck: false }) {
    let n = [];
    for (const r2 of e3) (i4 || false === this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(r2.typeName)?.useAllData && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(r2.typeName)?.members?.has(r2.id)) && n.push(r2);
    if (t4) {
      const e4 = /* @__PURE__ */ new Set(), t5 = [];
      for (const a4 of n) if (this.dataManager.nodeConnectionsLookup.has(a4.id)) for (const t6 of this.dataManager.nodeConnectionsLookup.get(a4.id)) e4.add(t6);
      for (const a4 of e4) if (this.dataManager.memberIdTypeLookup.has(a4)) for (const e5 of this.dataManager.memberIdTypeLookup.get(a4)) this.dataManager.relationshipTypeNames.has(e5) && t5.push({ id: a4, typeName: e5 });
      n = n.concat(t5);
    }
    this.dataManager.removeFromLayer(n);
    for (const r2 of n) this.sublayerIdsCache.get(r2.typeName)?.delete(r2.id), this.dataManager.relationshipTypeNames.has(r2.typeName) ? this.relationshipLinkChartDiagramLookup.delete(r2.id) : this.entityLinkChartDiagramLookup.delete(r2.id);
    const o4 = a3 ? void 0 : this.getCurrentNodeLocations();
    await this._calculateLayoutWithSublayerTimeInfo(this._currentLinkChartConfig.layoutMode, { layoutSettings: this._currentLinkChartConfig.layoutSettings, lockedNodeLocations: o4 }), n.length > 0 && (this.membershipModified = true);
    const s3 = [];
    return this.layers.forEach(((e4) => {
      s3.push(e4.refreshCachedQueryEngine());
    })), await Promise.all(s3), this._refreshNamedTypes(), n;
  }
  async expand(e3, t4) {
    let a3 = [];
    try {
      const i4 = await this.dataManager.getConnectedRecordIds(e3, t4?.relationshipTypeNames, t4);
      a3 = i4.filter(((e4) => !this.sublayerIdsCache.get(e4.typeName)?.has(e4.id))), await this._handleNewRecords(a3, t4), i4.length > 0 && (this.membershipModified = true), s2(t4?.signal);
    } catch (i4) {
      throw b(i4) && a3.length > 0 && await this.removeRecords(a3, { overrideMembershipCheck: true }), i4;
    }
    return { records: a3 };
  }
  loadLayerAssumingLocalCache() {
    const e3 = [...this.memberRelationshipTypes, ...this.memberEntityTypes];
    this.layers.length || this.originIdOf("tables") === e.DEFAULTS ? this.originIdOf("layers") === e.DEFAULTS ? this._createSublayers(e3, this.layers, ((e4) => !!e4.geometryType)) : this._updateSublayers(e3, this.layers) : this.layers = new V(), this.tables.length || this.originIdOf("layers") === e.DEFAULTS ? this.originIdOf("tables") === e.DEFAULTS ? this._createSublayers(e3, this.tables, ((e4) => !e4.geometryType)) : this._updateSublayers(e3, this.tables) : this.tables = new V(), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach(((e4, t4) => {
      const a3 = u(this.sublayerIdsCache, t4, (() => /* @__PURE__ */ new Set()));
      e4.members?.forEach((({ id: e5, linkChartLocation: i4 }) => {
        if (a3.add(e5), i4) {
          const a4 = "coords" in i4 && "lengths" in i4 ? i4 : ut(i4);
          this.dataManager.relationshipTypeNames.has(t4) ? this.relationshipLinkChartDiagramLookup.set(e5, a4) : this.entityLinkChartDiagramLookup.set(e5, a4);
        }
      }));
    }));
  }
  async calculateLinkChartLayout(e3 = "organic-standard", t4) {
    const a3 = [], s3 = [], l2 = [];
    this.dataManager.sublayerCaches.forEach(((e4, t5) => {
      this.dataManager.entityTypeNames.has(t5) ? e4.forEach(((e5) => {
        a3.push({ typeName: t5, feature: e5 });
      })) : this.dataManager.relationshipTypeNames.has(t5) && e4.forEach(((e5) => {
        s3.push({ typeName: t5, feature: e5 });
      }));
    })), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map();
    const d = /* @__PURE__ */ new Map(), p2 = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), u4 = /* @__PURE__ */ new Map(), y3 = new Uint8Array(a3.length), g2 = new Float64Array(a3.length), w = new Float64Array(a3.length), D2 = new Float64Array(a3.length), v2 = new Float64Array(a3.length), x = new Uint32Array(s3.length), I2 = new Uint32Array(s3.length), E2 = new Float64Array(s3.length), S3 = new Float64Array(s3.length), _4 = [], A2 = "organic-standard";
    let R = false;
    const j = new z({ xmin: -1e-7, ymin: -1e-7, xmax: 1e-7, ymax: 1e-7 });
    let G, V2 = "organic-standard", q2 = 0, J2 = 0;
    const X = m2.apply;
    switch (V2 = "geographic-organic-standard" === e3 ? A2 : e3, V2) {
      case "organic-standard":
        G = v.apply;
        break;
      case "organic-community":
        G = A.apply;
        break;
      case "hierarchical-bottom-to-top":
        G = P.apply;
        break;
      case "radial-root-centric":
        G = _3.apply;
        break;
      case "tree-left-to-right":
        G = h.apply;
        break;
      default:
        G = b3.apply;
    }
    let Y = false;
    a3.forEach((({ typeName: a4, feature: i4 }) => {
      if ("chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3 && t4?.lockedNodeLocations?.has(i4.attributes[_2])) {
        "geographic-organic-standard" === e3 && this.dataManager.geographicLookup.has(a4) ? y3[q2] = i2.IsGeographic : y3[q2] = i2.None;
        const n = t4.lockedNodeLocations.get(i4.attributes[_2]);
        g2[q2] = n.x, w[q2] = n.y;
      } else if ("geographic-organic-standard" === e3 && this.dataManager.geographicLookup.has(a4)) {
        y3[q2] = i2.IsGeographic;
        let e4 = null;
        const t5 = i4.attributes[this.dataManager.geographicLookup.get(a4).name], n = this.dataManager.geographicLookup.get(a4)?.geometryType;
        switch (n) {
          case "esriGeometryPoint":
            g2[q2] = t5?.x, w[q2] = t5?.y;
            break;
          case "esriGeometryPolygon":
            e4 = t5?.centroid, null != e4?.x && null != e4?.y ? (g2[q2] = e4.x, w[q2] = e4.y) : y3[q2] = i2.IsMovable;
            break;
          case "esriGeometryPolyline":
          case "esriGeometryMultipoint":
            e4 = t5?.extent?.center, null != e4?.x && null != e4?.y ? (g2[q2] = e4.x, w[q2] = e4.y) : y3[q2] = i2.IsMovable;
            break;
          default:
            y3[q2] = i2.IsMovable;
        }
        (null == g2[q2] || null == w[q2] || Number.isNaN(g2[q2]) || Number.isNaN(w[q2])) && (y3[q2] = i2.IsMovable, g2[q2] = 0, w[q2] = 0);
      } else if ("chronological-mono-timeline" === e3 || "chronological-multi-timeline" === e3) {
        !Y && t4?.lockedNodeLocations?.has(i4.attributes[_2]) && (Y = true);
        const e4 = t4?.timeInfoByTypeName?.get(a4), n = e4?.startField, o4 = n && e4?.startField ? i4.attributes[n] : null;
        D2[q2] = o4 ? new Date(o4).getTime() : NaN;
        const s4 = e4?.endField, r2 = s4 && e4?.endField ? i4.attributes[s4] : null;
        v2[q2] = r2 ? new Date(r2).getTime() : NaN, g2[q2] = 0, w[q2] = 0, y3[q2] = i2.IsMovable;
      } else y3[q2] = i2.IsMovable, g2[q2] = 0, w[q2] = 0;
      u4.set(i4.attributes[_2], q2), _4[q2] = { feature: i4, typeName: a4 }, q2++;
    })), Y && i.getLogger(this).warn("Locked node locations are not supported for chronological layout at this time.  Requested node locations were ignored");
    let Z = false;
    const ee = /* @__PURE__ */ new Map();
    s3.forEach(((a4) => {
      const i4 = a4.feature.attributes[I], n = a4.feature.attributes[t3], o4 = u4.get(i4), s4 = u4.get(n), r2 = t4?.timeInfoByTypeName?.get(a4.typeName), h3 = t4?.timeInfoByTypeName ? r2?.startField : null, d2 = h3 ? a4.feature.attributes[h3] : null, p3 = r2?.endField, c2 = p3 ? a4.feature.attributes[p3] : null;
      if (void 0 !== o4 && void 0 !== s4) {
        let t5 = i4 + "-" + n;
        "chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3 || (t5 = t5 + "-" + d2 + "-" + c2);
        const r3 = ee.get(t5), h4 = r3?.has(a4.typeName);
        h4 || (x[J2] = o4, I2[J2] = s4, "chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3 || (E2[J2] = d2 ? new Date(d2).getTime() : NaN, S3[J2] = c2 ? new Date(c2).getTime() : NaN), void 0 === r3 ? ee.set(t5, /* @__PURE__ */ new Map([[a4.typeName, J2]])) : r3.set(a4.typeName, J2), J2++), l2.push(a4);
      } else Z = true, this.relationshipLinkChartDiagramLookup.set(i4, null);
    })), Z && i.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null");
    const te = this._validateOrganicLayoutSettings(e3, t4?.layoutSettings?.organicLayoutSettings), ae = this._convertValidatedOrganicSettingsToCalculationSettings(te);
    await a2();
    let ie = o3.Error, ne = null;
    if ("chronological-mono-timeline" === e3 || "chronological-multi-timeline" === e3) {
      let a4;
      ({ status: ie, links: ne, graphics: a4 } = X((() => t4?.signal?.aborted ?? false), y3, g2, w, D2, v2, x.subarray(0, J2), I2.subarray(0, J2), E2.subarray(0, J2), S3.subarray(0, J2), "chronological-multi-timeline" === e3, t4?.layoutSettings?.chronologicalLayoutSettings)), ie === o3.Success && (this.chronologicalAuxiliaryGraphics = a4);
    } else ({ status: ie, links: ne } = G((() => t4?.signal?.aborted ?? false), y3, g2, w, x.subarray(0, J2), I2.subarray(0, J2), ae.computationBudgetTime, ae.idealEdgeLengthMultiplier, ae.repulsionRadiusMultiplier));
    if (s2(t4?.signal), ie === o3.Error) throw new s("knowledge-graph:layout-failed", "Attempting to arrange the records in the specified layout failed");
    if (ie === o3.Canceled) throw u2();
    for (let i4 = 0; i4 < _4.length; i4++) {
      if (w[i4] > 84.9999 ? w[i4] = 84.9999 : w[i4] < -84.9999 && (w[i4] = -84.9999), g2[i4] > 179.9999 ? g2[i4] = 179.9999 : g2[i4] < -179.9999 && (g2[i4] = -179.9999), _4[i4].feature.attributes[S2] = new _(g2[i4], w[i4]), d.has(_4[i4].typeName)) {
        const e5 = d.get(_4[i4].typeName);
        e5?.set(_4[i4].feature.attributes[_2], _4[i4].feature);
      } else {
        const e5 = /* @__PURE__ */ new Map();
        e5.set(_4[i4].feature.attributes[_2], _4[i4].feature), d.set(_4[i4].typeName, e5);
      }
      c.set(_4[i4].feature.attributes[_2], _4[i4].feature);
      const e4 = ut(_4[i4].feature.attributes[S2]);
      this.entityLinkChartDiagramLookup.set(_4[i4].feature.attributes[_2], _4[i4].feature.attributes[S2] ? e4 : null);
      const t5 = u(this.dataManager.inclusionModeDefinition.namedTypeDefinitions, _4[i4].typeName, (() => ({ useAllData: false, members: /* @__PURE__ */ new Map() })));
      u(t5.members, _4[i4].feature.attributes[_2], (() => ({ id: _4[i4].feature.attributes[_2], linkChartLocation: void 0 }))).linkChartLocation = _4[i4].feature.attributes[S2];
      const { x: a4, y: n } = _4[i4].feature.attributes[S2];
      if (R) j.xmin = Math.min(j.xmin, a4), j.xmax = Math.max(j.xmax, a4), j.ymin = Math.min(j.ymin, n), j.ymax = Math.max(j.ymax, n);
      else {
        const e5 = 1e-7;
        j.xmin = a4 - e5, j.xmax = a4 + e5, j.ymin = n - e5, j.ymax = n + e5, R = true;
      }
    }
    if (this.linkChartExtent.xmin = j.xmin, this.linkChartExtent.xmax = j.xmax, this.linkChartExtent.ymin = j.ymin, this.linkChartExtent.ymax = j.ymax, !ne) throw new s("knowledge-graph:layout-failed", "Attempting to retrieve link geometry from diagram engine failed");
    const oe = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Map(), re = /* @__PURE__ */ new Map(), le = /* @__PURE__ */ new Set();
    for (let i4 = 0; i4 < l2.length; i4++) {
      const a4 = [], s4 = l2[i4], r2 = s4.feature.attributes[I], h3 = s4.feature.attributes[t3];
      let d2 = r2 + "-" + h3;
      if ("chronological-mono-timeline" === e3 || "chronological-multi-timeline" === e3) {
        const e4 = t4?.timeInfoByTypeName?.get(s4.typeName), a5 = t4?.timeInfoByTypeName ? e4?.startField : null, i5 = a5 ? s4.feature.attributes[a5] : null, n = e4?.endField;
        d2 += "-" + i5 + "-" + (n ? s4.feature.attributes[n] : null);
      }
      const y4 = ee.get(d2).get(s4.typeName), g3 = 0 === y4 ? 0 : ne?.vertexEndIndex[y4 - 1];
      if (!le.has(y4)) {
        if (le.add(y4), ne.types[y4] === u3.Recursive) {
          const e4 = [ne.vertices[2 * g3], ne.vertices[2 * g3 + 1]], t5 = [ne.vertices[2 * (g3 + 1)], ne.vertices[2 * (g3 + 1) + 1]], i5 = [0.5 * (e4[0] + t5[0]), 0.5 * (e4[1] + t5[1])], n = [i5[0] - e4[0], i5[1] - e4[1]], o4 = [i5[0] + n[1], i5[1] - n[0]], s5 = [i5[0] - n[1], i5[1] + n[0]];
          a4.push(e4), a4.push(o4), a4.push(t5), a4.push(s5), a4.push(e4);
        } else {
          if (ne.types[y4] !== u3.Regular) {
            i.getLogger(this).warn("A relationship generated an unsupported link geometry type.  It will not be rendered");
            continue;
          }
          for (let e4 = g3; e4 < ne.vertexEndIndex[y4]; e4++) a4.push([ne.vertices[2 * e4], ne.vertices[2 * e4 + 1]]);
        }
        if ("chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3) {
          const e4 = _4[u4.get(r2)]?.feature.attributes[S2], t5 = _4[u4.get(h3)]?.feature.attributes[S2];
          a4[0][0] === e4.x && a4[0][1] === e4.y || (a4[0] = [e4.x, e4.y]), a4[a4.length - 1][0] === t5.x && a4[a4.length - 1][1] === t5.y || (a4[a4.length - 1] = [t5.x, t5.y]);
        }
        for (let e4 = 1; e4 < a4.length - 1; e4++) a4[e4][1] > 85.5 ? a4[e4][1] = 85.5 : a4[e4][1] < -85.5 && (a4[e4][1] = -85.5), a4[e4][0] > 179.9999 ? a4[e4][0] = 179.9999 : a4[e4][0] < -179.9999 && (a4[e4][0] = -179.9999);
        oe.has(d2) ? oe.get(d2).push(a4) : oe.set(d2, [a4]);
      }
      const m3 = oe.get(d2);
      se.has(d2) || (se.set(d2, /* @__PURE__ */ new Map()), re.set(d2, /* @__PURE__ */ new Map()));
      const f = se.get(d2), w2 = re.get(d2);
      f.has(s4.typeName) || (f.set(s4.typeName, m3.shift()), w2.set(s4.typeName, 0));
      const N = f.get(s4.typeName);
      w2.set(s4.typeName, w2.get(s4.typeName) + 1);
      const D3 = new y({ paths: [N] });
      if (s4.feature.attributes[S2] = D3, p2.has(s4.typeName)) {
        const e4 = p2.get(s4.typeName);
        e4?.set(s4.feature.attributes[_2], s4.feature);
      } else {
        const e4 = /* @__PURE__ */ new Map();
        e4.set(s4.feature.attributes[_2], s4.feature), p2.set(s4.typeName, e4);
      }
      c.set(s4.feature.attributes[_2], s4.feature);
      const v3 = ut(s4.feature.attributes[S2]);
      this.relationshipLinkChartDiagramLookup.set(s4.feature.attributes[_2], s4.feature.attributes[S2] ? v3 : null);
      const x2 = u(this.dataManager.inclusionModeDefinition.namedTypeDefinitions, s4.typeName, (() => ({ useAllData: false, members: /* @__PURE__ */ new Map() })));
      u(x2.members, s4.feature.attributes[_2], (() => ({ id: s4.feature.attributes[_2], linkChartLocation: void 0 }))).linkChartLocation = v3;
    }
    for (const i4 of l2) i4.feature.attributes[o] = re.get(i4.feature.attributes[I] + "-" + i4.feature.attributes[t3])?.get(i4.typeName) ?? null;
    return this._currentLinkChartConfig = { layoutMode: e3, layoutSettings: t4?.layoutSettings?.clone() }, { nodes: d, links: p2, idMap: c };
  }
  async applyNewLinkChartLayout(e3 = "organic-standard", t4) {
    const a3 = [];
    await this._calculateLayoutWithSublayerTimeInfo(e3, t4), this.layers.forEach(((e4) => {
      a3.push(e4.refreshCachedQueryEngine());
    })), this.membershipModified = true, await Promise.all(a3), this._refreshNamedTypes();
  }
  getCurrentNodeLocations() {
    const e3 = /* @__PURE__ */ new Map();
    for (const [t4, a3] of this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.entries() ?? []) this.dataManager.relationshipTypeNames.has(t4) || a3?.members?.forEach(((t5) => {
      const a4 = t5.linkChartLocation;
      let i4;
      const n = t5.id;
      a4 && (i4 = "x" in a4 ? { x: a4.x, y: a4.y } : { x: a4.coords[0], y: a4.coords[1] }, e3.set(n, new _({ x: i4.x, y: i4.y })));
    }));
    return e3;
  }
  async refreshLinkChartCache(e3) {
    await this.dataManager.refreshCacheContent(e3);
    const t4 = [];
    this.layers.forEach(((e4) => {
      t4.push(e4.refreshCachedQueryEngine());
    })), await Promise.all(t4), this._refreshNamedTypes();
  }
  async connectBetweenEntities(e3, t4) {
    if (!e3.length) return { records: [] };
    let a3 = [];
    try {
      let i4 = [];
      for (const e4 of this.dataManager.relationshipTypeNames) {
        const t5 = this.sublayerIdsCache.get(e4);
        t5 && (i4 = i4.concat(Array.from(t5.keys())));
      }
      a3 = await this.dataManager.getRelationshipsBetweenNodes(e3, i4, t4), await this._handleNewRecords(a3, t4), s2(t4);
    } catch (i4) {
      throw b(i4) && this.removeRecords(a3), i4;
    }
    return { records: a3 };
  }
  async connectFromEntities(e3, t4) {
    if (!e3.length) return { records: [] };
    let a3 = [];
    try {
      let i4 = [];
      for (const e4 of this.dataManager.relationshipTypeNames) {
        const t5 = this.sublayerIdsCache.get(e4);
        t5 && (i4 = i4.concat(Array.from(t5.keys())));
      }
      let n = [];
      for (const e4 of this.dataManager.entityTypeNames) {
        const t5 = this.sublayerIdsCache.get(e4);
        t5 && (n = n.concat(Array.from(t5)));
      }
      a3 = await this.dataManager.getRelationshipsFromNodes(e3, n, i4, t4), await this._handleNewRecords(a3, t4), a3.length > 0 && (this.membershipModified = true), s2(t4);
    } catch (i4) {
      throw b(i4) && this.removeRecords(a3), i4;
    }
    return { records: a3 };
  }
  getCurrentLayout() {
    return this._currentLinkChartConfig.layoutMode;
  }
  async _calculateLayoutWithSublayerTimeInfo(e3 = "organic-standard", t4) {
    const a3 = /* @__PURE__ */ new Map();
    this.layers.forEach(((e4) => {
      a3.set(e4.objectType.name, e4.timeInfo);
    })), await this.calculateLinkChartLayout(e3, { timeInfoByTypeName: a3, ...t4 }), this.linkChart?.handleChronologicalOverlay();
  }
  async _handleNewRecords(e3, t4) {
    const a3 = /* @__PURE__ */ new Set(), i4 = [], n = this.layers.concat(this.tables);
    for (const r2 of e3) {
      if (!this._graphTypeLookup.has(r2.typeName)) continue;
      false === n.some(((e4) => e4.objectType.name === r2.typeName)) && (this.dataManager.sublayerCaches.set(r2.typeName, /* @__PURE__ */ new Map()), a3.add(r2.typeName));
      u(this.sublayerIdsCache, r2.typeName, (() => /* @__PURE__ */ new Set())).add(r2.id), i4.push(r2);
    }
    this.dataManager.addToLayer(i4);
    for (const o4 of a3) {
      const e4 = this._graphTypeLookup.get(o4);
      if (e4) {
        const t5 = this._createSublayer(e4);
        "entity" === e4.type ? this.dataManager.entityTypeNames.add(o4) : this.dataManager.relationshipTypeNames.add(o4), t5.geometryType ? this.layers.push(t5) : this.tables.push(t5);
      }
    }
    await i3(this, Array.from(a3), t4), await this.dataManager.refreshCacheContent(e3.map(((e4) => e4.id)), void 0, void 0, void 0, t4);
    const s3 = { layoutSettings: this._currentLinkChartConfig.layoutSettings, lockedNodeLocations: /* @__PURE__ */ new Map() };
    for (const [o4, r2] of this.entityLinkChartDiagramLookup.entries()) r2 && s3.lockedNodeLocations.set(o4, new _(r2.coords[0], r2.coords[1]));
    await this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode, s3);
  }
  _createSublayers(e3, t4, a3) {
    e3.forEach(((e4) => {
      const i4 = this._createSublayer(e4);
      a3(i4) && t4.push(i4), this._updateSublayerCaches(e4);
    }));
  }
  _updateSublayers(e3, t4) {
    t4.forEach(((t5) => {
      t5.parentCompositeLayer = this;
      const a3 = e3.find(((e4) => e4.type === t5.graphType && e4.name === t5.graphTypeName));
      a3 && (t5.objectType = a3, t5.read({ title: a3.name }, { origin: "service" }), this._updateSublayerCaches(a3));
    }));
  }
  _updateSublayerCaches({ name: e3 }) {
    if (!e3) return;
    const t4 = this.dataManager.sublayerCaches;
    t4.has(e3) || t4.set(e3, /* @__PURE__ */ new Map());
  }
  _layersLoadedFromAuthoritativeItem() {
    const e3 = this.originIdOf("layers");
    return e3 >= e.PORTAL_ITEM && e3 < e.USER;
  }
  async _initializeDiagram() {
    this.initializationLinkChartConfig ? this.initializationLinkChartConfig.doNotRecalculateLayout ? (this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach(((e3, t4) => {
      e3?.members?.forEach(((e4) => {
        const a3 = e4.linkChartLocation;
        let i4;
        const n = e4.id;
        if (!a3) return;
        i4 = "x" in a3 ? { x: a3.x, y: a3.y } : { x: a3.coords[0], y: a3.coords[1] };
        const o4 = ut(i4);
        this.dataManager.relationshipTypeNames.has(t4) ? this.relationshipLinkChartDiagramLookup.set(n, o4) : this.entityLinkChartDiagramLookup.set(n, o4), this.linkChartExtent.xmin > i4.x && (this.linkChartExtent.xmin = i4.x), this.linkChartExtent.xmax < i4.x && (this.linkChartExtent.xmax = i4.x), this.linkChartExtent.ymin > i4.y && (this.linkChartExtent.ymin = i4.y), this.linkChartExtent.ymax < i4.y && (this.linkChartExtent.ymax = i4.y);
      }));
    })), this.memberRelationshipTypes.forEach(((e3) => {
      e3.name && this.dataManager.sublayerCaches.get(e3.name)?.forEach(((e4) => {
        const t4 = this.relationshipLinkChartDiagramLookup.get(e4.attributes[I]), a3 = this.relationshipLinkChartDiagramLookup.get(e4.attributes[t3]);
        if (t4 && a3) {
          const i4 = ut(new y({ paths: [[[t4.coords[0], t4.coords[1]], [a3.coords[0], a3.coords[1]]]] }));
          this.relationshipLinkChartDiagramLookup.set(e4.attributes[_2], i4);
        } else this.relationshipLinkChartDiagramLookup.set(e4.attributes[_2], null);
      }));
    }))) : await this._calculateLayoutWithSublayerTimeInfo(this.initializationLinkChartConfig.layoutMode, { lockedNodeLocations: this.getCurrentNodeLocations(), ...this.initializationLinkChartConfig || {} }) : await this._calculateLayoutWithSublayerTimeInfo("organic-standard", { lockedNodeLocations: this.getCurrentNodeLocations() });
  }
  _refreshNamedTypes() {
    for (const e3 of this.layers) e3.emit("refresh", { dataChanged: true });
    for (const e3 of this.tables) e3.emit("refresh", { dataChanged: true });
  }
  _validateOrganicLayoutSettings(e3, t4) {
    const a3 = (e4) => "number" == typeof e4 && !isNaN(e4), i4 = (e4) => a3(e4) && e4 >= 1, o4 = (e4) => a3(e4) && e4 >= 1, s3 = (e4) => Object.values(e2).includes(e4), r2 = (e4) => a3(e4) && e4 >= 0, l2 = {};
    if (!(/* @__PURE__ */ new Set(["organic-standard", "organic-community", "geographic-organic-standard", "chronological-multi-timeline", "chronological-mono-timeline"])).has(e3) || !t4) return l2;
    const { computationBudgetTime: h3, autoRepulsionRadius: d, repulsionRadiusMultiplier: p2, absoluteIdealEdgeLength: c, multiplicativeIdealEdgeLength: u4, idealEdgeLengthType: y3 } = t4;
    return o4(h3) ? l2.computationBudgetTime = h3 : h3 && i.getLogger(this).warn("Invalid layout computationBudgetTime setting, will revert to default setting"), l2.autoRepulsionRadius = d, !d && i4(p2) ? l2.repulsionRadiusMultiplier = p2 : d || (l2.autoRepulsionRadius = true, i.getLogger(this).warn("Invalid layout repulsionRadiusMultiplier setting, will revert to default setting")), "geographic-organic-standard" === e3 && (s3(y3) ? l2.idealEdgeLengthType = y3 : void 0 !== y3 && i.getLogger(this).warn('Invalid layout idealEdgeLengthType setting, will revert to "multiplier" setting'), "absolute-value" === y3 && r2(c) ? l2.absoluteIdealEdgeLength = c : "absolute-value" === y3 && void 0 !== c ? i.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting") : "multiplier" === y3 && r2(u4) ? l2.multiplicativeIdealEdgeLength = u4 : "multiplier" === y3 && void 0 !== u4 && i.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting")), l2;
  }
  _convertValidatedOrganicSettingsToCalculationSettings(e3) {
    let t4 = e3.idealEdgeLengthType === e2.ABSOLUTE ? e3.absoluteIdealEdgeLength : e3.multiplicativeIdealEdgeLength;
    return e3.idealEdgeLengthType === e2.ABSOLUTE && (void 0 === t4 ? t4 = -1 : t4 *= -1), { computationBudgetTime: e3.computationBudgetTime ?? void 0, repulsionRadiusMultiplier: e3.repulsionRadiusMultiplier && !e3.autoRepulsionRadius ? e3.repulsionRadiusMultiplier : void 0, idealEdgeLengthMultiplier: t4 };
  }
  _createSublayer(e3) {
    return new Ie({ objectType: e3, parentCompositeLayer: this, graphType: e3.type });
  }
  _handleSublayersChange(e3, t4) {
    t4 && (t4.forEach(((e4) => {
      e4.parent = null;
    })), this.removeHandles("sublayers-owner")), e3 && (e3.forEach(((e4) => {
      e4.parent = this;
    })), this.addHandles([e3.on("after-add", (({ item: e4 }) => {
      e4.parent = this;
    })), e3.on("after-remove", (({ item: e4 }) => {
      e4.parent = null;
    }))], "sublayers-owner"));
  }
  _alignLayersDataModelAndInclusionDefinition(e3) {
    const t4 = new Set((e3.entityTypes ?? []).map(((e4) => e4.name)).concat((e3.relationshipTypes ?? []).map(((e4) => e4.name)))), i4 = new Set((e3.entityTypes ?? []).map(((e4) => e4.name))), o4 = new Set((e3.relationshipTypes ?? []).map(((e4) => e4.name)));
    if (this.layers) {
      for (const a3 of this.layers) !a3.graphType && t4.has(a3.graphTypeName) && (a3.graphType = i4.has(a3.graphTypeName) ? "entity" : "relationship");
      const e4 = this.layers.filter(((e5) => t4.has(e5.graphTypeName) && ("entity" === e5.graphType ? i4.has(e5.graphTypeName) : o4.has(e5.graphTypeName))));
      this.setAtOrigin("layers", e4, t(this.originIdOf("layers")));
    } else this.layers = new V();
    if (this.layers && this._originalInclusionList) {
      const e4 = new Set(this._originalInclusionList.namedTypeDefinitions.keys()), t5 = this.tables?.map(((e5) => e5.graphTypeName)) ?? [], a3 = this.layers.map(((e5) => e5.graphTypeName)).concat(t5);
      for (const n of a3) e4.has(n) || this._originalInclusionList.namedTypeDefinitions.set(n, { useAllData: false, members: /* @__PURE__ */ new Map() });
      const i5 = [];
      for (const o5 of this._originalInclusionList.namedTypeDefinitions.keys()) a3.includes(o5) || (i.getLogger(this).warn(`A named type, ${o5}, was in the serialized feature collection but did not have a sublayer config in the item, so will be removed`), i5.push(o5));
      for (const n of i5) this._originalInclusionList.namedTypeDefinitions.delete(n);
    }
  }
};
r([m(y2)], q.prototype, "url", void 0), r([m()], q.prototype, "dataPreloadedInLocalCache", void 0), r([m()], q.prototype, "initializationLinkChartConfig", void 0), r([m()], q.prototype, "membershipModified", void 0), r([m()], q.prototype, "dataManager", void 0), r([m()], q.prototype, "initializationInclusionModeDefinition", null), r([m()], q.prototype, "knowledgeGraph", void 0), r([m({ type: V.ofType(Ie), json: { write: { ignoreOrigin: true } } })], q.prototype, "layers", void 0), r([m({ readOnly: true })], q.prototype, "linkChart", null), r([m()], q.prototype, "entityLinkChartDiagramLookup", void 0), r([m()], q.prototype, "relationshipLinkChartDiagramLookup", void 0), r([m()], q.prototype, "linkChartExtent", void 0), r([m()], q.prototype, "memberEntityTypes", void 0), r([m()], q.prototype, "memberRelationshipTypes", void 0), r([m({ type: ["LinkChartLayer"] })], q.prototype, "operationalLayerType", void 0), r([m()], q.prototype, "sublayerIdsCache", void 0), r([m({ type: V.ofType(Ie), json: { write: { ignoreOrigin: true } } })], q.prototype, "tables", void 0), r([m({ json: { read: false } })], q.prototype, "type", void 0), r([m({ json: { read: false } })], q.prototype, "chronologicalAuxiliaryGraphics", void 0), q = r([a("esri.layers.LinkChartLayer")], q);
var J = q;
export {
  J as default
};
//# sourceMappingURL=LinkChartLayer-JLFGLJOU.js.map
