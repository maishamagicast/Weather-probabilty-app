{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/LineMarker.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.33/esri/copyright.txt for details.\n*/\nimport{markerTextureSize as e,markerSymbolSize as r,markerTipThicknessFactor as i}from\"../views/3d/support/engineContent/marker.js\";import{SliceDraw as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{RibbonVertexPosition as t}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";import{OutputHighlight as a}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{MarkerSizing as n}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js\";import{terrainDepthTest as s}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js\";import{ColorConversion as l}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{RgbaFloatEncoding as c}from\"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";import{addProjViewLocalOrigin as p,addViewNormal as d,addPixelRatio as v}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float2BindUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";import{Float4BindUniform as h}from\"../views/3d/webgl-engine/core/shaderModules/Float4BindUniform.js\";import{Float4PassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatBindUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";import{glsl as u,If as w}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{Matrix4BindUniform as S}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4BindUniform.js\";import{Texture2DPassUniform as b}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{VertexAttribute as y}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{LineMarkerSpace as x,LineMarkerAnchor as P}from\"../views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js\";import{outputColorHighlightOID as z}from\"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js\";import{ShaderBuilder as j}from\"../views/webgl/ShaderBuilder.js\";function L(L){const k=new j,{space:M,anchor:D,hasTip:C}=L,$=M===x.World;k.include(t,L),k.include(n,L),k.include(s,L);const{vertex:O,fragment:T,varyings:W}=k;T.include(c),p(O,L),k.attributes.add(y.POSITION,\"vec3\"),k.attributes.add(y.PREVIOUSDELTA,\"vec4\"),k.attributes.add(y.UV0,\"vec2\"),W.add(\"vColor\",\"vec4\"),W.add(\"vpos\",\"vec3\",{invariant:!0}),W.add(\"vUV\",\"vec2\"),W.add(\"vSize\",\"float\"),C&&W.add(\"vLineWidth\",\"float\"),O.uniforms.add(new m(\"nearFar\",(({camera:e})=>e.nearFar)),new h(\"viewport\",(({camera:e})=>e.fullViewport))).code.add(u`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`),O.code.add(u`void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nfloat interpolation = (-vnp - pos.z) / (prev.z - pos.z);\nprev = mix(pos, prev, interpolation);\n}\n}`),$?(k.attributes.add(y.NORMAL,\"vec3\"),d(O),O.constants.add(\"tiltThreshold\",\"float\",.7),O.code.add(u`vec3 perpendicular(vec3 v) {\nvec3 n = (viewNormal * vec4(normal.xyz, 1.0)).xyz;\nvec3 n2 = cross(v, n);\nvec3 forward = vec3(0.0, 0.0, 1.0);\nfloat tiltDot = dot(forward, n);\nreturn abs(tiltDot) < tiltThreshold ? n : n2;\n}`)):O.code.add(u`vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}`);const U=$?\"vec3\":\"vec2\";return O.code.add(u`\n      ${U} normalizedSegment(${U} pos, ${U} prev) {\n        ${U} segment = pos - prev;\n        float segmentLen = length(segment);\n\n        // normalize or zero if too short\n        return (segmentLen > 0.001) ? segment / segmentLen : ${$?\"vec3(0.0, 0.0, 0.0)\":\"vec2(0.0, 0.0)\"};\n      }\n\n      ${U} displace(${U} pos, ${U} prev, float displacementLen) {\n        ${U} segment = normalizedSegment(pos, prev);\n\n        ${U} displacementDirU = perpendicular(segment);\n        ${U} displacementDirV = segment;\n\n        ${D===P.Tip?\"pos -= 0.5 * displacementLen * displacementDirV;\":\"\"}\n\n        return pos + displacementLen * (uv0.x * displacementDirU + uv0.y * displacementDirV);\n      }\n    `),M===x.Screen&&(O.uniforms.add(new S(\"inverseProjectionMatrix\",(({camera:e})=>e.inverseProjectionMatrix))),O.code.add(u`vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}`),O.code.add(u`bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}`),O.uniforms.add(new g(\"perScreenPixelRatio\",(({camera:e})=>e.perScreenPixelRatio))),O.code.add(u`\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ${w(L.hasCap,\"if(prev.z > posLeft.z) {\\n                vec2 diff = posLeft.xy - posRight.xy;\\n                planeOrigin.xy += perpendicular(diff) / 2.0;\\n             }\")};\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  `)),v(O),O.main.add(u`\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      float lineWidth = getLineWidth();\n      float screenMarkerSize = getScreenMarkerSize();\n\n      vec4 pos  = view * vec4(position, 1.0);\n      vec4 prev = view * vec4(position + previousDelta.xyz * previousDelta.w, 1.0);\n      clip(pos, prev);\n\n      ${$?u`${w(L.hideOnShortSegments,u`\n                if (areWorldMarkersHidden(pos, prev)) {\n                  // Project out of clip space\n                  gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n                  return;\n                }`)}\n            pos.xyz = displace(pos.xyz, prev.xyz, getWorldMarkerSize(pos));\n            vec4 displacedPosScreen = projectAndScale(pos);`:u`\n            vec4 posScreen = projectAndScale(pos);\n            vec4 prevScreen = projectAndScale(prev);\n            vec4 displacedPosScreen = posScreen;\n\n            displacedPosScreen.xy = displace(posScreen.xy, prevScreen.xy, screenMarkerSize);\n            ${w(M===x.Screen,u`\n                vec2 displacementDirU = perpendicular(normalizedSegment(posScreen.xy, prevScreen.xy));\n\n                // We need three points of the ribbon line in camera space to calculate the plane it lies in\n                // Note that we approximate the third point, since we have no information about the join around prev\n                vec3 lineRight = inverseProject(posScreen + lineWidth * vec4(displacementDirU.xy, 0.0, 0.0));\n                vec3 lineLeft = pos.xyz + (pos.xyz - lineRight);\n\n                pos = toFront(displacedPosScreen, lineLeft, lineRight, prev.xyz, lineWidth);\n                displacedPosScreen = projectAndScale(pos);`)}`}\n      forwardViewPosDepth(pos.xyz);\n      // Convert back into NDC\n      displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n      // Convert texture coordinate into [0,1]\n      vUV = (uv0 + 1.0) / 2.0;\n      ${w(!$,\"vUV *= displacedPosScreen.w;\")}\n      ${w(C,\"vLineWidth = lineWidth;\")}\n\n      vSize = screenMarkerSize;\n      vColor = getColor();\n\n      // Use camera space for slicing\n      vpos = pos.xyz;\n\n      gl_Position = displacedPosScreen;\n    }`),T.include(o,L),k.include(z,L),T.include(l),T.uniforms.add(new f(\"intrinsicColor\",(({color:e})=>e)),new b(\"tex\",(({markerTexture:e})=>e))).constants.add(\"texelSize\",\"float\",1/e).code.add(u`float markerAlpha(vec2 samplePos) {\nsamplePos += vec2(0.5, -0.5) * texelSize;\nfloat sdf = rgbaTofloat(texture(tex, samplePos)) - 0.5;\nfloat distance = sdf * vSize;\ndistance -= 0.5;\nreturn clamp(0.5 - distance, 0.0, 1.0);\n}`),C&&T.constants.add(\"relativeMarkerSize\",\"float\",r/e).constants.add(\"relativeTipLineWidth\",\"float\",i).code.add(u`\n    float tipAlpha(vec2 samplePos) {\n      // Convert coordinates s.t. they are in pixels and relative to the tip of an arrow marker\n      samplePos -= vec2(0.5, 0.5 + 0.5 * relativeMarkerSize);\n      samplePos *= vSize;\n\n      float halfMarkerSize = 0.5 * relativeMarkerSize * vSize;\n      float halfTipLineWidth = 0.5 * max(1.0, relativeTipLineWidth * vLineWidth);\n\n      ${w($,\"halfTipLineWidth *= fwidth(samplePos.y);\")}\n\n      float distance = max(abs(samplePos.x) - halfMarkerSize, abs(samplePos.y) - halfTipLineWidth);\n      return clamp(0.5 - distance, 0.0, 1.0);\n    }\n  `),k.include(a,L),T.main.add(u`\n    discardBySlice(vpos);\n    discardByTerrainDepth();\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    // Cancel out perspective correct interpolation if in screen space or draped\n    vec2 samplePos = vUV ${w(!$,\"* gl_FragCoord.w\")};\n    finalColor.a *= ${C?\"max(markerAlpha(samplePos), tipAlpha(samplePos))\":\"markerAlpha(samplePos)\"};\n    outputColorHighlightOID(finalColor, vpos, finalColor.rgb);`),k}const k=Object.freeze(Object.defineProperty({__proto__:null,build:L},Symbol.toStringTag,{value:\"Module\"}));export{k as L,L as b};\n"],
  "mappings": "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",
  "names": ["L", "k", "s", "n", "i", "t", "e", "o", "p", "w"]
}
