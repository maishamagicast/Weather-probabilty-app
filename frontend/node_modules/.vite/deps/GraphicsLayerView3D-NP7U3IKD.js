import {
  F,
  P as P4,
  a2 as a9,
  a3 as a10,
  d as d9,
  e as e13,
  e3 as e14,
  l as l11,
  l2 as l12,
  m as m4,
  m3 as m5,
  n as n9,
  p as p6,
  p2 as p7,
  r as r11,
  r2 as r12,
  r3 as r13,
  t3 as t7,
  y as y2
} from "./chunk-UWID4WCR.js";
import {
  g as g8
} from "./chunk-SJPEOG5I.js";
import {
  C as C3,
  R as R5,
  a3 as a8,
  b as b6,
  c as c6,
  d as d7,
  d2 as d8,
  e as e12,
  l2 as l9,
  l3 as l10,
  m as m3,
  o as o10,
  s as s9
} from "./chunk-VZSCGKW6.js";
import {
  b as b7
} from "./chunk-JAJODCSX.js";
import "./chunk-4S4P25QU.js";
import "./chunk-7ABIZ3WR.js";
import {
  u as u10
} from "./chunk-M6JFBQWH.js";
import "./chunk-3LXV24ZZ.js";
import {
  u as u9
} from "./chunk-E3AA3YUP.js";
import {
  s as s8
} from "./chunk-WHNSSW5C.js";
import "./chunk-AGKZYL6G.js";
import {
  S,
  b as b5
} from "./chunk-DZM7IW3X.js";
import "./chunk-BPUCUSGP.js";
import {
  c as c4
} from "./chunk-JA2IYIBN.js";
import "./chunk-2ZGO74NI.js";
import {
  i as i3
} from "./chunk-RQJUGLAI.js";
import "./chunk-VXNXYHUY.js";
import {
  A as A4,
  R as R4,
  S as S2,
  h3 as h6,
  n as n7,
  p as p3
} from "./chunk-SDFT4MBH.js";
import "./chunk-TNWEXAUF.js";
import "./chunk-C5VWCDCZ.js";
import "./chunk-G4DUIZFI.js";
import "./chunk-KJ4LM5AS.js";
import "./chunk-37PYS3NU.js";
import "./chunk-OGVC4Q4F.js";
import "./chunk-GK2Y5C64.js";
import "./chunk-D2A6ED5C.js";
import "./chunk-XQ4BSXYL.js";
import "./chunk-RSDZ4QIV.js";
import "./chunk-YDAB4XFH.js";
import "./chunk-EQVXVNLM.js";
import "./chunk-V4AT44QY.js";
import {
  g as g6,
  t as t6
} from "./chunk-ZTCB7WLN.js";
import "./chunk-ZFMHX2V5.js";
import "./chunk-ZJHEVDGY.js";
import "./chunk-HGEYMHZP.js";
import "./chunk-D2LYUBTC.js";
import "./chunk-AXWNDKIT.js";
import {
  e as e10
} from "./chunk-JGZTRPP2.js";
import "./chunk-M7R2YZDZ.js";
import {
  B as B2,
  g as g5,
  p as p4,
  r as r10
} from "./chunk-SMJO7RZ5.js";
import "./chunk-ECP6YJSR.js";
import "./chunk-M66BFVET.js";
import "./chunk-VXI7FII2.js";
import "./chunk-NKEPBYMO.js";
import {
  a as a6,
  d2 as d6,
  n2 as n8
} from "./chunk-N5Z36XUT.js";
import "./chunk-OMRLA7WF.js";
import {
  o2 as o8
} from "./chunk-YFVN6T7B.js";
import "./chunk-YYCWQ7IY.js";
import "./chunk-UUAYISM3.js";
import "./chunk-G34CT35U.js";
import {
  i as i4
} from "./chunk-TATNVB2X.js";
import "./chunk-XOKC7WTG.js";
import "./chunk-5EFSJB5C.js";
import "./chunk-LLYIDZOJ.js";
import "./chunk-YYBQNFDT.js";
import "./chunk-BDOQJGKW.js";
import "./chunk-3ZVP6ZGY.js";
import "./chunk-KD3DP7JS.js";
import "./chunk-7HQYTH7X.js";
import "./chunk-YH2S3WIW.js";
import "./chunk-5QMSA3XT.js";
import "./chunk-U5UYYSWH.js";
import "./chunk-ATNV3FTT.js";
import "./chunk-GCX7FLSY.js";
import "./chunk-345ZKZWI.js";
import "./chunk-7WUMTJ26.js";
import "./chunk-BVAE5L3O.js";
import "./chunk-OBI6XSOO.js";
import {
  j as j2
} from "./chunk-67YWPP6I.js";
import {
  h as h5,
  v as v2
} from "./chunk-TM5UR4RA.js";
import "./chunk-QYDHMHNZ.js";
import {
  o as o7,
  r as r9,
  t as t5
} from "./chunk-ZYWMFOAJ.js";
import {
  n as n6
} from "./chunk-IS6QSGYZ.js";
import {
  e as e9
} from "./chunk-RHVCSVQD.js";
import "./chunk-JITSIG7E.js";
import "./chunk-Q75IV5IU.js";
import "./chunk-HXOI7XVG.js";
import "./chunk-KRZHFMU4.js";
import "./chunk-OHGGPE27.js";
import {
  u as u8
} from "./chunk-CGESJDPA.js";
import "./chunk-RZPBZYCG.js";
import "./chunk-O3DVK2IK.js";
import "./chunk-FL3AEKKI.js";
import "./chunk-BWEEMT5B.js";
import "./chunk-TNLCQYJ3.js";
import "./chunk-OJQPIMLV.js";
import "./chunk-FXWNGVAA.js";
import "./chunk-6HU6D6AI.js";
import {
  k as k2
} from "./chunk-HUR2TTV7.js";
import "./chunk-7WMSTTK2.js";
import "./chunk-RYUENKYI.js";
import {
  t as t4
} from "./chunk-LSUSWZD7.js";
import {
  t as t3
} from "./chunk-C5RMBVA5.js";
import {
  L as L4,
  M as M3,
  O as O2,
  P as P3,
  V as V3,
  h as h4
} from "./chunk-DPEZN2CZ.js";
import "./chunk-6T6LJGGM.js";
import "./chunk-CPLLBL2J.js";
import "./chunk-HPADPQJ7.js";
import {
  R as R3,
  b as b4,
  v,
  z as z2
} from "./chunk-OB3B6P2I.js";
import "./chunk-WC2H7YQR.js";
import {
  e as e6
} from "./chunk-ITDL4YVK.js";
import {
  ut
} from "./chunk-24S6C5S6.js";
import {
  O
} from "./chunk-G2CGFQQR.js";
import {
  E as E2,
  e as e7
} from "./chunk-ULRXIASY.js";
import "./chunk-X7XYZI46.js";
import "./chunk-IQIGYB5K.js";
import {
  c as c3
} from "./chunk-QYV34ZYV.js";
import "./chunk-4QM2FHGA.js";
import {
  m as m2
} from "./chunk-NN5O537H.js";
import "./chunk-WE43YRN7.js";
import "./chunk-Q4LJGDN3.js";
import {
  e as e8
} from "./chunk-3JKWT76Y.js";
import "./chunk-LOLNWH3R.js";
import {
  s as s6
} from "./chunk-OXO3GGCE.js";
import "./chunk-T4WPBSSK.js";
import "./chunk-7Q65H3HK.js";
import "./chunk-RWNJO2QP.js";
import {
  a as a7,
  g as g7,
  p as p5
} from "./chunk-JM2IVLES.js";
import {
  o as o9
} from "./chunk-3ZX4Y274.js";
import {
  c as c5
} from "./chunk-746KDGCX.js";
import "./chunk-IFDA5FOT.js";
import {
  r as r8
} from "./chunk-QIPPWPN2.js";
import "./chunk-Y2AI7GA5.js";
import {
  l as l8
} from "./chunk-BDYPDR3Y.js";
import "./chunk-UXVQ5YGS.js";
import {
  h as h3
} from "./chunk-FPALEK52.js";
import {
  C,
  D,
  g,
  o as o4,
  r as r7
} from "./chunk-S5G7D7MX.js";
import "./chunk-6BZTNQVP.js";
import "./chunk-2RL34CVC.js";
import "./chunk-KPGNM4LZ.js";
import {
  l as l5
} from "./chunk-BNQMKYX6.js";
import {
  n as n4
} from "./chunk-B6C2GOG6.js";
import {
  A as A2,
  E,
  K,
  P as P2,
  c as c2,
  g as g2,
  o as o5,
  p as p2,
  s as s7,
  u as u5
} from "./chunk-K3VYMAVM.js";
import {
  r as r5
} from "./chunk-P5DG4SNT.js";
import {
  c
} from "./chunk-7WPGDYQW.js";
import {
  $
} from "./chunk-OUFI3E5Y.js";
import "./chunk-QOICX6SF.js";
import "./chunk-LUNNU672.js";
import {
  d as d3,
  y
} from "./chunk-FFY3IMAS.js";
import "./chunk-DJ5QZHL6.js";
import "./chunk-IR6JOM7Y.js";
import "./chunk-FI3Y4ZNX.js";
import {
  d as d4,
  g as g4,
  u as u6
} from "./chunk-M6LH7ANK.js";
import "./chunk-FTX3VFJX.js";
import "./chunk-COXNSOYZ.js";
import "./chunk-S7GLMIAQ.js";
import "./chunk-7Y4U2JD3.js";
import {
  s as s5
} from "./chunk-GCTSCKPO.js";
import {
  e as e5
} from "./chunk-6U4EGJOK.js";
import {
  R as R2
} from "./chunk-ZBTRSUIE.js";
import "./chunk-D6GGPM6D.js";
import "./chunk-U2JVYDTA.js";
import "./chunk-HH4Q2NN5.js";
import "./chunk-3CFYBBSV.js";
import {
  d as d5
} from "./chunk-VCKINPGN.js";
import "./chunk-SDCRJECE.js";
import {
  f2 as f5,
  l2 as l7,
  o as o6,
  u2 as u7
} from "./chunk-4G42CJX6.js";
import "./chunk-NEI5HAVK.js";
import "./chunk-D7G7U7XX.js";
import "./chunk-2CS746FZ.js";
import {
  g as g3
} from "./chunk-UET4BL4J.js";
import "./chunk-YMT7TAQQ.js";
import "./chunk-RZGBA4KS.js";
import "./chunk-FSYN2HHU.js";
import {
  B,
  H,
  M as M2,
  Q,
  T,
  b as b3,
  k,
  l as l4,
  q,
  u as u4,
  w as w3
} from "./chunk-7I4TWCTW.js";
import "./chunk-SCMB64VM.js";
import "./chunk-MBJ7YPSH.js";
import "./chunk-D34PNYRG.js";
import "./chunk-APMQAZ5Z.js";
import "./chunk-QDOFETFN.js";
import "./chunk-MSSQA3XK.js";
import "./chunk-R7YP6EQJ.js";
import {
  A as A3,
  C as C2
} from "./chunk-CAQUPYHC.js";
import {
  n as n5
} from "./chunk-UZ3YWBWC.js";
import "./chunk-2EOHKZLO.js";
import {
  e as e4
} from "./chunk-W7U4L72B.js";
import {
  a as a5,
  n as n3,
  r as r6
} from "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import {
  t
} from "./chunk-4O46EK5T.js";
import {
  h as h7
} from "./chunk-A7I2KMJU.js";
import "./chunk-BPI4BR4E.js";
import {
  L as L3,
  nn,
  t as t2
} from "./chunk-3L5JZOMH.js";
import "./chunk-N77BULFI.js";
import {
  o as o3
} from "./chunk-NEIJCC5O.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-A6R2FXH6.js";
import {
  h as h2
} from "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import {
  e2 as e11
} from "./chunk-4KZLIAP7.js";
import "./chunk-62NATJWT.js";
import {
  i as i2
} from "./chunk-FOPBVVXE.js";
import "./chunk-INI6MHIQ.js";
import "./chunk-QUZZIDFR.js";
import "./chunk-CBCDVQSA.js";
import {
  n as n2
} from "./chunk-RKF6WUZT.js";
import {
  P
} from "./chunk-RMRI4NYS.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import {
  I,
  M,
  a as a4,
  d as d2,
  f as f4,
  l as l3,
  p,
  u as u2
} from "./chunk-BLBN3L5Q.js";
import {
  l as l6
} from "./chunk-XNUSHDFN.js";
import {
  u as u3
} from "./chunk-4AKMPOG7.js";
import "./chunk-2CJBZZN7.js";
import {
  o as o2
} from "./chunk-ZJQPHR3K.js";
import "./chunk-R4XAU2TW.js";
import {
  _,
  a as a3
} from "./chunk-YVMULGDJ.js";
import {
  V
} from "./chunk-74GULGYB.js";
import {
  U,
  a as a2,
  f as f2,
  h,
  j,
  l as l2,
  w as w2
} from "./chunk-HYAO4PVV.js";
import "./chunk-SRNKPAJX.js";
import {
  o
} from "./chunk-VNQUG2TO.js";
import "./chunk-MOMLPET6.js";
import "./chunk-3QHX4R4B.js";
import "./chunk-ORMKIVR7.js";
import "./chunk-TOCH3L2K.js";
import "./chunk-EULNFFHG.js";
import "./chunk-SDIBXPSJ.js";
import {
  z
} from "./chunk-CBXZL53X.js";
import "./chunk-LPCUYJ2B.js";
import {
  _ as _2
} from "./chunk-SMO33YG7.js";
import {
  f as f3
} from "./chunk-LCBAL6ER.js";
import {
  V as V2,
  s as s3,
  s2 as s4
} from "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import "./chunk-67AKDROO.js";
import "./chunk-CM3TIXEV.js";
import "./chunk-POWGZO3T.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-NJZD7WM5.js";
import "./chunk-CL7VLXUR.js";
import "./chunk-FCX4ZA3Z.js";
import {
  b as b2,
  m2 as m
} from "./chunk-2ZPU5IZX.js";
import {
  a2 as a,
  e as e3
} from "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import {
  A
} from "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import {
  r as r4
} from "./chunk-5REYU5G2.js";
import {
  r as r2
} from "./chunk-JNYZ3I5R.js";
import {
  L as L2,
  b,
  d,
  e,
  e2,
  l2 as l,
  r2 as r3,
  s as s2,
  u2 as u,
  w
} from "./chunk-N626Y23H.js";
import {
  f,
  i3 as i,
  s2 as s
} from "./chunk-TJPLHZCD.js";
import {
  G,
  L,
  R,
  has,
  n
} from "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/3d/layers/LayerView3D.js
var l13 = (l18) => {
  let n11 = class extends l18 {
    constructor() {
      super(...arguments), this.slicePlaneEnabled = false, this.supportsHeightUnitConversion = false;
    }
    postscript() {
      super.postscript(), g7(this.layer) && this.addResolvingPromise(this._validateHeightModelInfo());
    }
    async _validateHeightModelInfo() {
      const o14 = new AbortController(), r18 = o14.signal;
      this.addHandles(e((() => o14.abort()))), await j((() => this.view.defaultsFromMap?.heightModelInfoReady), r18), s2(r18);
      const i12 = a7(this.layer, this.view.heightModelInfo, this.supportsHeightUnitConversion);
      if (i12) throw i12;
    }
  };
  return r([m()], n11.prototype, "view", void 0), r([m()], n11.prototype, "slicePlaneEnabled", void 0), n11 = r([a("esri.views.3d.layers.LayerView3D")], n11), n11;
};

// node_modules/@arcgis/core/views/3d/layers/graphics/elevationAlignPointsInFeatures.js
async function l14(l18, m9, d15, j4, u19) {
  const { elevationProvider: v7, renderCoordsHelper: g11 } = l18, { elevationInfo: I3 } = m9, { pointsInFeatures: x5, spatialReference: y5 } = j4, h13 = f3.fromJSON(y5), w5 = d8(I3, true), R6 = await a8(w5, h13, u19);
  s2(u19);
  const S5 = [], b11 = /* @__PURE__ */ new Set(), z3 = /* @__PURE__ */ new Set(), E4 = new o10(), P7 = e9(0, 0, 0, f3.WGS84), U4 = new R5(), C5 = n2();
  P7.spatialReference = h13;
  const F3 = l18.elevationProvider.spatialReference ?? l18.spatialReference;
  for (const { objectId: e22, points: o14 } of x5) {
    const t14 = d15(e22);
    if (null == t14) {
      for (const e23 of o14) S5.push(e23.z ?? 0);
      b11.add(e22);
      continue;
    }
    t14.isDraped && z3.add(e22);
    const i12 = t14.graphic.geometry;
    E4.setFromElevationInfo(s8(i12, I3)), E4.updateFeatureExpressionInfoContext(R6, t14.graphic, m9);
    for (const { x: e23, y: n11, z: a15 } of o14) P7.x = e23, P7.y = n11, P7.z = a15 ?? 0, await c3(P7, C5, F3, 0, { signal: u19 }), c6(C5, v7, E4, g11, U4), S5.push(U4.z);
  }
  return { elevations: S5, drapedObjectIds: z3, failedObjectIds: b11 };
}

// node_modules/@arcgis/core/renderers/support/rendererConversion.js
function s10(r18) {
  return null == r18 || "simple" === r18.type || "unique-value" === r18.type || "class-breaks" === r18.type || "dictionary" === r18.type || "heatmap" === r18.type;
}
function t8(r18, n11) {
  if (null == r18) return null;
  if (!s10(r18)) return new s("renderer-conversion-3d:unsupported-renderer", `Unsupported renderer of type '${r18.type || r18.declaredClass}'`, { renderer: r18 });
  switch (r18.type) {
    case "simple":
      return a11(r18, n11);
    case "unique-value":
      return u11(r18, n11);
    case "class-breaks":
      return i5(r18, n11);
    case "dictionary":
    case "heatmap":
      return null;
  }
  return null;
}
function l15(r18, n11) {
  if (!n11) return null;
  if (Array.isArray(n11) || (n11 = [n11]), n11.length > 0) {
    const o14 = n11.map(((r19) => r19.details.symbol.type || r19.details.symbol.declaredClass)).filter(((r19) => !!r19));
    o14.sort();
    const s17 = new Array();
    return o14.forEach(((r19, e22) => {
      0 !== e22 && r19 === o14[e22 - 1] || s17.push(r19);
    })), new s("renderer-conversion-3d:unsupported-symbols", `Renderer contains symbols (${s17.join(", ")}) which are not supported in 3D`, { renderer: r18, symbolErrors: n11 });
  }
  return null;
}
function a11(r18, e22) {
  const s17 = { ...g4, ...e22, cimFallbackEnabled: true };
  return l15(r18, u6(r18.symbol, s17).error);
}
function u11(e22, s17) {
  const t14 = { ...g4, ...s17, cimFallbackEnabled: true }, a15 = e22.uniqueValueInfos?.map(((r18) => u6(r18.symbol, t14).error)).filter(L), u19 = u6(e22.defaultSymbol, t14);
  return u19.error && a15?.unshift(u19.error), l15(e22, a15);
}
function i5(e22, s17) {
  const t14 = { ...g4, ...s17, cimFallbackEnabled: true }, a15 = e22.classBreakInfos.map(((r18) => u6(r18.symbol, t14).error)).filter(L), u19 = u6(e22.defaultSymbol, t14);
  return u19.error && a15.unshift(u19.error), l15(e22, a15);
}

// node_modules/@arcgis/core/views/3d/layers/graphics/DisplayFeatureLimit.js
var e15 = class {
  constructor(e22, m9, t14) {
    this.maximumTotalNumberOfVertices = e22, this.maximumNumberOfFeatures = m9, this.averageSymbolComplexity = t14;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationQuery.js
var l16 = class {
  constructor(e22, t14) {
    this.spatialReference = e22, this._view = t14;
  }
  getElevation(e22, t14, r18) {
    return this._view.elevationProvider.getElevation(e22, t14, 0, this.spatialReference, r18);
  }
  async queryElevation(e22, t14, r18, s17, i12) {
    return this._view.elevationProvider.queryElevation(e22, t14, 0, this.spatialReference, i12, r18, s17);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/enums.js
var L5;
var A5;
!(function(L8) {
  L8[L8.USER = 1] = "USER", L8[L8.SCALE_RANGE = 2] = "SCALE_RANGE", L8[L8.FILTER = 4] = "FILTER", L8[L8.DECONFLICTION = 8] = "DECONFLICTION", L8[L8.ALL_GRAPHIC = 15] = "ALL_GRAPHIC", L8[L8.ALL_LABEL = 255] = "ALL_LABEL";
})(L5 || (L5 = {})), (function(L8) {
  L8[L8.GRAPHIC = 1] = "GRAPHIC", L8[L8.LABEL = 16] = "LABEL";
})(A5 || (A5 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DFeatureStore.js
var d10 = u4();
var l17 = class extends b2 {
  constructor(t14) {
    super(t14), this.events = new o(), this.hasZ = null, this.hasM = null, this.objectIdField = null, this.featureAdapter = { getAttribute: (t15, e22) => "graphic" in t15 ? t15.graphic.attributes[e22] : e6.getAttribute(t15, e22), getAttributes: (t15) => "graphic" in t15 ? t15.graphic.attributes : e6.getAttributes(t15), getObjectId: (t15) => "graphic" in t15 ? R3(t15.graphic, this.objectIdField) ?? void 0 : e6.getObjectId(t15), getGeometry: (t15) => "graphic" in t15 ? t15.getAsOptimizedGeometry(this.hasZ, this.hasM) : e6.getGeometry(t15), getCentroid: (t15, e22) => {
      if ("graphic" in t15) {
        let r18 = null;
        null != t15.centroid ? r18 = t15.centroid : "point" === t15.graphic.geometry.type && nn(t15.graphic.geometry, u13, this.viewSpatialReference) && (r18 = u13);
        const o14 = new Array(2 + (e22.hasZ ? 1 : 0) + (e22.hasM ? 1 : 0));
        return null == r18 ? (o14[0] = 0, o14[1] = 0, o14[2] = 0, o14[3] = 0) : (o14[0] = r18.x, o14[1] = r18.y, e22.hasZ && (o14[2] = r18.hasZ ? r18.z : 0), e22.hasM && (o14[e22.hasZ ? 3 : 2] = r18.hasM ? r18.m : 0)), new e5([], o14);
      }
      return e6.getCentroid(t15, e22);
    }, cloneWithGeometry: (t15, e22) => "graphic" in t15 ? new s5(e22, this.featureAdapter.getAttributes(t15), null, this.featureAdapter.getObjectId(t15)) : e6.cloneWithGeometry(t15, e22) };
  }
  forEachInBounds(t14, e22) {
    this.getSpatialIndex().forEachInBounds(t14, e22);
  }
  forEachBounds(t14, e22) {
    const r18 = this.getSpatialIndex();
    for (const o14 of t14) {
      const t15 = this.featureAdapter.getObjectId(o14);
      null != r18.getBounds(t15, d10) && e22(d10);
    }
  }
};
r([m({ constructOnly: true })], l17.prototype, "getSpatialIndex", void 0), r([m({ constructOnly: true })], l17.prototype, "forEach", void 0), r([m({ constructOnly: true })], l17.prototype, "hasZ", void 0), r([m({ constructOnly: true })], l17.prototype, "hasM", void 0), r([m({ constructOnly: true })], l17.prototype, "objectIdField", void 0), r([m({ constructOnly: true })], l17.prototype, "viewSpatialReference", void 0), r([m({ constructOnly: true })], l17.prototype, "featureSpatialReference", void 0), l17 = r([a("esri.views.3d.layers.graphics.Graphics3DFeatureStore")], l17);
var u13 = { type: "point", x: 0, y: 0, hasZ: false, hasM: false, spatialReference: null };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DGraphicCreationContext.js
var r14 = class {
  constructor(r18, s17, t14) {
    this.graphic = r18, this.renderingInfo = s17, this.layer = t14;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolCreationContext.js
var s11 = class {
  constructor(e22, s17, i12, r18) {
    this.scheduler = e22, this.schedule = s17, this.layerViewUid = i12, this.compressionTracker = r18, this.sharedResources = null, this.streamDataRequester = null, this.elevationProvider = null, this.renderer = null, this.stage = null, this.clippingExtent = null, this.renderCoordsHelper = null, this.overlaySR = null, this.layer = null, this.drapeSourceRenderer = null, this.graphicsCoreOwner = null, this.localOriginFactory = null, this.featureExpressionInfoContext = null, this.screenSizePerspectiveEnabled = true, this.slicePlaneEnabled = false, this.physicalBasedRenderingEnabled = false, this.skipHighSymbolLods = false, this.isAsync = false;
  }
  get spherical() {
    return this.stage.view.state.viewingMode === l8.Global;
  }
};
var i6 = class {
  constructor() {
    this.renderPriority = 0, this.renderPriorityStep = 1, this.ignoreDrivers = false;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineCalloutTechnique.js
var p8 = class extends g6 {
  constructor(r18, o14) {
    super(r18, o14, new t6(b7, (() => import("./LineCallout.glsl-3CEX6KLQ.js"))));
  }
  initializePipeline(e22) {
    const { hudDepth: r18, terrainDepthTest: t14 } = e22, p12 = { func: t14 ? C2.ALWAYS : C2.LESS };
    return B2(r18 ? { depthTest: p12, depthWrite: p4 } : { blending: r10(A3.ONE, A3.SRC_ALPHA, A3.ONE_MINUS_SRC_ALPHA, A3.ONE_MINUS_SRC_ALPHA), depthTest: p12, colorWrite: g5 });
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineCalloutTechniqueConfiguration.js
var i7 = class extends a6 {
  constructor(e22) {
    super(), this.spherical = e22, this.screenCenterOffsetUnitsEnabled = false, this.occlusionTestEnabled = true, this.hasVerticalOffset = false, this.hasScreenSizePerspective = false, this.hudDepth = false, this.hudDepthAlignStart = false, this.terrainDepthTest = false, this.draped = false;
  }
};
r([i4()], i7.prototype, "screenCenterOffsetUnitsEnabled", void 0), r([i4()], i7.prototype, "occlusionTestEnabled", void 0), r([i4()], i7.prototype, "hasVerticalOffset", void 0), r([i4()], i7.prototype, "hasScreenSizePerspective", void 0), r([i4()], i7.prototype, "hudDepth", void 0), r([i4()], i7.prototype, "hudDepthAlignStart", void 0), r([i4()], i7.prototype, "terrainDepthTest", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/LineCalloutMaterial.js
var d11 = class extends n8 {
  constructor(e22, t14) {
    super(e22, T2), this.intersectDraped = void 0, this.produces = /* @__PURE__ */ new Map([[A4.LINE_CALLOUTS, (e23) => u8(e23)], [A4.LINE_CALLOUTS_HUD_DEPTH, (e23) => u8(e23)]]), this._configuration = new i7(t14), this._uniqueMaterialIdentifier = O3(this.parameters);
  }
  passParameters() {
    return this.parameters;
  }
  getConfiguration(e22, t14) {
    return super.getConfiguration(e22, t14, this._configuration), this._configuration.occlusionTestEnabled = this.parameters.occlusionTest, this._configuration.hasVerticalOffset = null != this.parameters.verticalOffset, this._configuration.hasScreenSizePerspective = null != this.parameters.screenSizePerspective, this._configuration.hudDepth = t14.slot === A4.LINE_CALLOUTS_HUD_DEPTH, this._configuration.hudDepthAlignStart = !!this.parameters.hudDepthAlignStart, this._configuration.screenCenterOffsetUnitsEnabled = "screen" === this.parameters.centerOffsetUnits, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.terrainDepthTest = t14.terrainDepthTest, this._configuration;
  }
  get visible() {
    return this.parameters.color[3] >= o8 || (this.parameters.borderColor?.[3] ?? 0) >= o8;
  }
  intersect() {
  }
  createGLMaterial(e22) {
    return new S3(e22);
  }
  createBufferWriter() {
    return new D2();
  }
  validateParameters(e22) {
    this._uniqueMaterialIdentifier = O3(e22);
  }
  get uniqueMaterialIdentifier() {
    return this._uniqueMaterialIdentifier;
  }
};
function O3({ renderOccluded: t14, isDecoration: r18, horizontalScreenOffset: i12, color: s17, size: n11, occlusionTest: o14, shaderPolygonOffset: a15, hudDepthAlignStart: c10, centerOffsetUnits: l18, hasSlicePlane: f7, screenSizePerspective: u19, verticalOffset: h13, borderColor: p12 }) {
  return f`${t14}:${r18}:${i12}:[${s17}]:${n11}:${o14}:${a15}:${c10}:${l18}:${f7}:${null != u19}:{${h13.screenLength}:${h13.minWorldLength}:${h13.maxWorldLength}}:[${p12}]`;
}
var S3 = class extends e10 {
  beginSlot(e22) {
    return this.getTechnique(p8, e22);
  }
};
var T2 = class extends d6 {
  constructor() {
    super(...arguments), this.horizontalScreenOffset = 0, this.color = r6(0, 0, 0, 1), this.size = 1, this.occlusionTest = false, this.shaderPolygonOffset = 1e-5, this.hudDepthAlignStart = false, this.centerOffsetUnits = "world", this.hasSlicePlane = false;
  }
};
var L6 = O().vec3f(e7.POSITION).vec3f(e7.NORMAL).vec2f16(e7.UV0).vec4f(e7.CENTEROFFSETANDDISTANCE);
var _3 = [r8(0, 0), r8(1, 0), r8(0, 1), r8(1, 0), r8(1, 1), r8(0, 1)];
var D2 = class {
  constructor() {
    this.vertexBufferLayout = L6;
  }
  elementCount(e22) {
    return 6 * e22.get(e7.POSITION).indices.length;
  }
  write(e22, t14, r18, i12, s17, n11) {
    R4(r18.get(e7.POSITION), e22, s17.position, n11, 6), S2(r18.get(e7.NORMAL), t14, s17.normal, n11, 6), h6(r18.get(e7.CENTEROFFSETANDDISTANCE), s17.centerOffsetAndDistance, n11, 6);
    for (let o14 = 0; o14 < _3.length; ++o14) s17.uv0.setVec(n11 + o14, _3[o14]);
    return null;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DLineCalloutSymbolLayer.js
var _w = class _w extends y2 {
  constructor(e22, t14) {
    super(e22, null, t14, A6), this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: false }, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    this._materials[0] = new d11(this._materialParameters, this._context.spherical);
  }
  _perInstanceMaterialParameters(e22) {
    const t14 = this._materialParameters;
    return t14.horizontalScreenOffset = e22.horizontalScreenOffset ?? 0, t14.centerOffsetUnits = e22.centerOffsetUnits || "world", t14;
  }
  get _materialParameters() {
    const r18 = new T2(), i12 = this.symbol, s17 = i12.callout;
    if (s17.color) {
      const t14 = l6.toUnitRGBA(s17.color);
      t14[3] *= this._getLayerOpacity(), r18.color = t14;
    } else r18.color = a5;
    if (r18.size = u3(s17.size || 0), i12.verticalOffset) {
      const { screenLength: e22, minWorldLength: n11, maxWorldLength: s18 } = i12.verticalOffset;
      r18.verticalOffset = { screenLength: u3(e22), minWorldLength: n11 || 0, maxWorldLength: null != s18 ? s18 : 1 / 0 };
    }
    r18.borderColor = null != s17.border?.color ? l6.toUnitRGBA(s17.border.color) : null;
    const o14 = "object" === i12.symbolLayers.at(0).type, a15 = "label-3d" === i12.type;
    return r18.occlusionTest = !o14 && !has("enable-feature:non-occluded-hud"), o14 && (r18.shaderPolygonOffset = 0), r18.hudDepthAlignStart = a15, r18.hasSlicePlane = this._context.slicePlaneEnabled, r18.screenSizePerspective = this._context.screenSizePerspectiveEnabled ? this._context.sharedResources.screenSizePerspectiveSettings : null, r18;
  }
  _defaultElevationInfoNoZ() {
    return U2;
  }
  createGraphics3DGraphic(e22, t14) {
    const r18 = e22.renderingInfo, n11 = e22.graphic, i12 = this.setGraphicElevationContext(n11, new o10(), r18.elevationOffset || 0), s17 = r18.symbol, a15 = "on-the-ground" === this._elevationContext.mode && ("cim" === s17.type || !s17.symbolLayers.some(((e23) => "object" === e23.type || "text" === e23.type)));
    if ("label-3d" !== s17.type && a15) return null;
    if ("point-3d" === s17.type && s17.symbolLayers.every(((e23) => "text" === e23.type && !l7(e23)))) return null;
    const l18 = b5(n11.geometry);
    return null == l18 ? null : this._createAs3DShape(l18, i12, r18, n11.uid, t14);
  }
  layerOpacityChanged() {
    this._materials[0]?.setParameters(this._materialParameters);
  }
  layerElevationInfoChanged(e22, t14, r18) {
    const n11 = this._elevationContext.mode, i12 = m3(_w.elevationModeChangeTypes, r18, n11);
    return i12 !== b6.UPDATE || e22?.forEach(((e23) => {
      const r19 = t14(e23);
      null != r19 && this.updateGraphicElevationContext(e23.graphic, r19);
    })), i12;
  }
  slicePlaneEnabledChanged() {
    return this._materials[0]?.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  setGraphicElevationContext(e22, t14, r18 = 0) {
    return super.setGraphicElevationContext(e22, t14), t14.addOffsetRenderUnits(r18), t14;
  }
  updateGraphicElevationContext(e22, t14) {
    const { elevationContext: r18, metadata: n11 } = t14;
    this.setGraphicElevationContext(e22, r18, n11?.elevationOffset ?? 0), t14.needsElevationUpdates = d7(r18.mode);
  }
  computeComplexity() {
    return new e13({ verticesPerFeature: 6 });
  }
  _getOrCreateMaterial(e22, t14) {
    const r18 = this._perInstanceMaterialParameters(e22), n11 = O3(r18);
    if (n11 === this._materials[0]?.uniqueMaterialIdentifier) return this._materials[0];
    if (t14) {
      let e23 = t14.get(n11);
      return null == e23 && (e23 = new d11(r18, this._context.spherical), t14.set(n11, e23)), e23;
    }
    return new d11(r18, this._context.spherical);
  }
  _createAs3DShape(e22, t14, r18, n11, i12) {
    const s17 = this._context.layerViewUid, o14 = this._context.stage.renderView.getObjectAndLayerIdColor({ graphicUid: n11, layerViewUid: s17 }), l18 = this._getOrCreateMaterial(r18, i12), c10 = new p3(l18, G2(r18), null, n7.Point, o14), h13 = a10(this._context, e22, c10, t14, n11);
    if (null == h13) return null;
    const p12 = new p7(this, h13.object, null, p6, t14);
    return p12.metadata = new t7(r18.elevationOffset), p12.alignedSampledElevation = h13.sampledElevation, p12.needsElevationUpdates = d7(t14.mode), m5(p12, e22, this._context.elevationProvider), p12;
  }
};
_w.elevationModeChangeTypes = { definedChanged: b6.UPDATE, staysOnTheGround: b6.UPDATE, onTheGroundChanged: b6.RECREATE };
var w4 = _w;
function G2(e22) {
  const { translation: t14, centerOffset: r18 } = e22, n11 = new t4(t14 ? [t14[0], t14[1], t14[2]] : [0, 0, 0], S4, 3, true), i12 = new t4(r18 ? [r18[0], r18[1], r18[2], r18[3]] : [0, 0, 0, 1], S4, 4, true);
  return [[e7.POSITION, n11], [e7.NORMAL, new t4([0, 0, 1], S4, 3, true)], [e7.CENTEROFFSETANDDISTANCE, i12]];
}
var S4 = [0];
var U2 = { mode: "relative-to-ground", offset: 0 };
var A6 = { ignoreDrivers: true, renderPriority: 0, renderPriorityStep: 1 };
var D3 = class extends l11 {
  constructor(e22, t14, n11 = n2(), s17 = n3(), o14 = 0, a15 = "world", l18 = 0) {
    super(e22, t14), this.translation = n11, this.centerOffset = s17, this.horizontalScreenOffset = o14, this.centerOffsetUnits = a15, this.elevationOffset = l18;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DCalloutSymbolLayerFactory.js
var t9 = () => i.getLogger("esri.views.3d.layers.graphics.Graphics3DCalloutSymbolLayerFactory");
function e16(o14, l18) {
  if (!o6(o14)) return t9().error("Graphics3DCalloutSymbolLayerFactory#make", `symbol of type '${o14.type}' does not support callouts`), null;
  if (!o14.callout) return null;
  const e22 = a12[o14.callout.type];
  return e22 ? new e22(o14, l18) : (t9().error("Graphics3DCalloutSymbolLayerFactory#make", `unknown or unsupported callout type ${o14.callout.type}`), null);
}
var a12 = { line: w4 };

// node_modules/@arcgis/core/geometry/projection/projectBoundingRect.js
function i8(r18, i12, s17, f7) {
  return null != r18 && (s3(i12, f7) ? (a4(s17, r18), true) : (p9[0] = r18[0], p9[1] = r18[1], p9[2] = 0, !!o3(p9, i12, 0, p9, f7, 0) && (s17[0] = p9[0], s17[1] = p9[1], p9[0] = r18[2], p9[1] = r18[3], p9[2] = 0, !!o3(p9, i12, 0, p9, f7, 0) && (s17[2] = p9[0], s17[3] = p9[1], true))));
}
var p9 = n2();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DGraphic.js
var x = new e3(Array, ((e22) => k(e22, Q)), null, 10, 5);
var v3 = u2();
var A7 = class {
  get labelLayers() {
    return this._labelLayers || R;
  }
  get extent() {
    return this._extent;
  }
  get isElevationSource() {
    return this.layers.some(((e22) => e22?.isElevationSource));
  }
  constructor(e22, t14, i12, r18, s17) {
    this.graphic = e22, this.graphics3DSymbol = t14, this.layers = i12, this._visibleFlags = L5.ALL_LABEL, ++t14.referenced, this._featureExpressionFeature = s17 ? s9(s17, e22, r18) : null;
  }
  initialize(e22) {
    this._layer = e22, this._forEachSymbolLayerGraphic(((t14) => {
      t14.initialize(e22), t14.setVisibility(this.isVisible());
    }));
  }
  destroy() {
    this._forEachSymbolLayerGraphic(((e22) => e22.destroy())), this._calloutLayer = null, --this.graphics3DSymbol.referenced, this.graphics3DSymbol = null;
  }
  get destroyed() {
    return null == this.layers;
  }
  clearLabelGraphics() {
    this._forEachLabelGraphic(((e22) => e22.destroy())), this._labelLayers = null;
  }
  addLabelGraphic(e22, t14) {
    this._labelLayers || (this._labelLayers = new Array()), this._labelLayers.push(e22), e22.initialize(t14), e22.setVisibility(this.isVisible(A5.LABEL));
  }
  setCalloutGraphic(e22) {
    this._calloutLayer = e22, this._layer && (e22.initialize(this._layer), e22.setVisibility(this.isVisible()));
  }
  get calloutLayer() {
    return this._calloutLayer;
  }
  get isDraped() {
    let e22 = false;
    return this._forEachSymbolLayerGraphic(((t14) => {
      "draped" === t14.type && (e22 = true);
    })), e22;
  }
  isVisible(e22 = A5.GRAPHIC, t14) {
    const i12 = t14 ? this._visibleFlags | t14 | A5.LABEL * t14 : this._visibleFlags;
    return e22 === A5.GRAPHIC ? (i12 & L5.ALL_GRAPHIC) === L5.ALL_GRAPHIC : (i12 & L5.ALL_LABEL) === L5.ALL_LABEL;
  }
  setVisibilityFlag(e22, t14, i12) {
    const r18 = this.isVisible(e22);
    i12 ? this._visibleFlags |= e22 * t14 : this._visibleFlags &= ~(e22 * t14);
    const s17 = this.isVisible(e22);
    if (r18 === s17) return false;
    if (e22 === A5.LABEL) this._forEachLabelGraphic(((e23) => e23.setVisibility(s17)));
    else {
      this._forEachSymbolLayerGraphic(((e24) => e24.setVisibility(s17)));
      const e23 = this.isVisible(A5.LABEL);
      this._forEachLabelGraphic(((t15) => t15.setVisibility(e23)));
    }
    return true;
  }
  getVisibilityFlag(e22, t14) {
    return 0 !== (this._visibleFlags & e22 * t14);
  }
  computeExtent(e22) {
    if (!this._extent) {
      const t14 = this.graphic.geometry;
      if (null == t14) return false;
      this._extent = u2(), z2(t14, this._extent);
      const i12 = t14.spatialReference;
      if (!s3(i12, e22) && !i8(this._extent, i12, this._extent, e22)) return this._extent = null, false;
    }
    return true;
  }
  getAsOptimizedGeometry(e22, t14) {
    return this._optimizedGeometry || (this._optimizedGeometry = this._convertGraphicToOptimizedGeometry(this.graphic, e22, t14)), this._optimizedGeometry;
  }
  _convertGraphicToOptimizedGeometry(e22, t14, i12) {
    let r18 = e22.geometry;
    return "mesh" !== r18.type && "extent" !== r18.type || (r18 = P.fromExtent("mesh" === r18.type ? r18.extent : r18)), ut(r18, t14, i12);
  }
  get usedMemory() {
    let e22 = e4(this.graphic.attributes);
    return this._forEachSymbolLayerGraphic(((t14) => e22 += t14.usedMemory)), e22;
  }
  computeAttachmentOrigin() {
    const e22 = { render: { origin: n2(), num: 0 }, draped: { origin: n4(), num: 0 } };
    for (const t14 of this.layers) null != t14 && t14.computeAttachmentOrigin(e22);
    return e22.render.num > 1 && g2(e22.render.origin, e22.render.origin, 1 / e22.render.num), e22.draped.num > 1 && l5(e22.draped.origin, e22.draped.origin, 1 / e22.draped.num), e22;
  }
  async getProjectedBoundingBox(e22, i12, r18, s17, a15) {
    return a15 || (a15 = { boundingBox: null, requiresDrapedElevation: false, screenSpaceObjects: [] }), a15.boundingBox ? q(a15.boundingBox) : a15.boundingBox = q(), a15.requiresDrapedElevation = false, await a3(this.layers, (async (t14) => {
      if (null == t14) return;
      const o14 = "draped" === t14.type ? i12 : e22, l18 = x.acquire(), n11 = await t14.getProjectedBoundingBox(o14, r18, a15.screenSpaceObjects, s17, l18);
      isFinite(n11[2]) && isFinite(n11[5]) || (a15.requiresDrapedElevation = true), n11 && M2(a15.boundingBox, l18), x.release(l18);
    })), T(a15.boundingBox) || M(w3(a15.boundingBox, v3)) ? a15 : null;
  }
  needsElevationUpdates() {
    for (const e22 of this.layers) if (null != e22 && ("object3d" === e22.type || "lod-instance" === e22.type) && e22.needsElevationUpdates) return true;
    return this._labelLayers?.some(((e22) => e22?.needsElevationUpdates ?? false)) ?? false;
  }
  alignWithElevation(e22, t14, i12) {
    this._forEachRenderedGraphic(((r18) => {
      "object3d" !== r18.type && "lod-instance" !== r18.type || r18.alignWithElevation(e22, t14, this._featureExpressionFeature, i12);
    }));
  }
  alignWithAbsoluteElevation(e22, t14, i12) {
    this._forEachRenderedGraphic(((r18) => {
      "object3d" === r18.type && r18.alignWithAbsoluteElevation(e22, t14, i12);
    }));
  }
  addObjectStateSet(e22) {
    this._forEachSymbolLayerGraphic(((t14) => t14.addObjectState(e22)));
  }
  removeObjectState(e22) {
    this._forEachSymbolLayerGraphic(((t14) => t14.removeObjectState(e22)));
  }
  updateHighlights(e22) {
    this._forEachSymbolLayerGraphic(((t14) => t14.updateHighlights(e22)));
  }
  _forEachGraphicList(e22, t14) {
    e22?.forEach(((e23) => e23 && t14(e23)));
  }
  _forEachSymbolLayerGraphic(e22) {
    this._forEachGraphicList(this.layers, e22), this._calloutLayer && e22(this._calloutLayer);
  }
  _forEachLabelGraphic(e22) {
    this._forEachGraphicList(this.labelLayers, e22);
  }
  _forEachRenderedGraphic(e22) {
    this._forEachSymbolLayerGraphic(e22), this._forEachLabelGraphic(e22);
  }
  get test() {
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/symbolMemory.js
var e17 = 2216;
var o11 = 4096;
function r15(r18) {
  return e17 + o11 * r18.symbolLayers.length + r18.complexity.memory.resourceBytes;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbol.js
var p10 = class extends r13 {
  set symbol(e22) {
    this._symbol = e22, e22.symbolLayers.forEach(((t14, r18) => {
      const s17 = this.symbolLayers[r18];
      null != s17 && (s17.symbol = e22, s17.symbolLayer = t14);
    }));
  }
  get symbol() {
    return this._symbol;
  }
  constructor(e22, t14, r18) {
    super(t14.schedule), this._symbol = e22, this._context = t14, this._backgroundLayers = r18, this._destroyed = false, this.symbolLayers = new Array(), this.referenced = 0, this._extentPadding = 0;
  }
  async doLoad(e22) {
    let o14 = this._symbol.symbolLayers;
    this._extentPadding = 0, this._backgroundLayers && (o14 = this._backgroundLayers.concat(o14));
    const a15 = o14.length;
    for (; this.symbolLayers.length < o14.length; ) this.symbolLayers.push(null);
    this.symbolLayers.length = o14.length;
    const i12 = [];
    if (!u14) {
      const { make: e23 } = await import("./Graphics3DSymbolLayerFactory-TC46O3UD.js");
      u14 = e23;
    }
    for (let t14 = 0; t14 < a15; t14++) {
      const s17 = o14.at(t14);
      if (false === s17.enabled) continue;
      d12.renderPriority = 1 - (1 + t14) / a15, d12.renderPriorityStep = 1 / a15, d12.ignoreDrivers = s17.ignoreDrivers;
      const n11 = u14(this.symbol, s17, this._context, d12), l18 = w(e22, (() => {
        this.symbolLayers[t14] = null, n11.destroy();
      }));
      l18 && i12.push(l18), this.symbolLayers[t14] = n11;
    }
    if (await a3(this.symbolLayers, (async (e23, t14) => {
      if (null != e23) try {
        await e23.load(), this._extentPadding += Math.max(this._extentPadding, e23.extentPadding);
      } catch {
        this.symbolLayers[t14] = null;
      }
    })), i12.forEach(((e23) => e23.remove())), s2(e22), this.symbolLayers.length && !this.symbolLayers.some(((e23) => !!e23))) throw new Error();
  }
  getSymbolLayerSize(e22) {
    const t14 = this.symbolLayers[e22];
    return null != t14 ? t14.getCachedSize() : null;
  }
  get extentPadding() {
    return this._extentPadding;
  }
  get symbologySnappingSupported() {
    return this.symbolLayers.some(((e22) => e22?.queryForSnapping));
  }
  updateFocus(e22, t14) {
    this.symbolLayers.forEach(((r18) => r18?.updateFocus(e22, t14)));
  }
  createGraphics3DGraphic(e22, t14) {
    const r18 = e22.graphic, s17 = this.symbolLayers.map(((t15) => t15?.createGraphics3DGraphic(e22) ?? null)), o14 = this._context.arcade || this._context.featureExpressionInfoContext?.arcade?.modules || null;
    return new A7(r18, t14 || this, s17, e22.layer, o14);
  }
  get complexity() {
    return F(this.symbolLayers.map(((e22) => null != e22 ? e22.complexity : null)));
  }
  globalPropertyChanged(e22, t14) {
    const r18 = this.symbolLayers.length;
    for (let s17 = 0; s17 < r18; s17++) {
      const r19 = this.symbolLayers[s17], o14 = (e23) => {
        const t15 = e23.layers[s17];
        return t15 instanceof p7 ? t15 : null;
      };
      if (null != r19 && !r19.globalPropertyChanged(e22, t14, o14)) return false;
    }
    return true;
  }
  applyRendererDiff(e22, t14) {
    return this.loadStatus !== l12.LOADED ? e14.RecreateSymbol : this.symbolLayers.reduce(((r18, s17) => r18 !== e14.RecreateSymbol && null != s17 ? Math.min(r18, s17.applyRendererDiff(e22, t14)) : r18), e14.FastUpdate);
  }
  prepareSymbolPatch(e22) {
    if (this.loadStatus === l12.FAILED) return;
    if ("partial" !== e22.diff.type) return;
    const t14 = e22.diff.diff;
    if (!t14.symbolLayers || "partial" !== t14.symbolLayers.type) return;
    const r18 = t14.symbolLayers.diff;
    this.symbolLayers.forEach(((t15, s17) => {
      if (null == t15) return;
      const o14 = r18[s17];
      if (o14) {
        const r19 = { diff: o14, graphics3DGraphicPatches: [], symbolLayerStatePatches: [] };
        t15.prepareSymbolLayerPatch(r19), e22.symbolStatePatches.push(...r19.symbolLayerStatePatches), r19.graphics3DGraphicPatches.length && e22.graphics3DGraphicPatches.push(((e23, t16) => {
          const o15 = e23.layers[s17];
          null != o15 && r19.graphics3DGraphicPatches.forEach(((e24) => e24(o15, t16)));
        }));
      }
    }));
  }
  updateGeometry(e22, t14) {
    return this._updateGeometryOrTransform(e22, ((e23, r18) => e23.updateGeometry(r18, t14)));
  }
  updateTransform(e22, t14, r18, s17) {
    return this._updateGeometryOrTransform(e22, ((e23, o14) => e23.updateTransform(o14, t14, r18, s17)));
  }
  _updateGeometryOrTransform(e22, t14) {
    for (let r18 = 0; r18 < this.symbolLayers.length; r18++) {
      const s17 = this.symbolLayers[r18];
      if (null == s17) continue;
      const o14 = e22.layers[r18];
      if (!o14 || !t14(s17, o14)) return false;
    }
    return true;
  }
  onRemoveGraphic(e22) {
    for (let t14 = 0; t14 < this.symbolLayers.length; t14++) {
      const r18 = this.symbolLayers[t14];
      if (null == r18) continue;
      const s17 = e22.layers[t14];
      null != s17 && r18.onRemoveGraphic(s17);
    }
  }
  getFastUpdateStatus() {
    let e22 = false, t14 = false;
    for (const r18 of this.symbolLayers) if (null != r18) {
      if (r18.loadStatus === l12.LOADING) return a9.Loading;
      r18.isFastUpdatesEnabled() ? t14 = true : e22 = true;
    }
    return t14 ? e22 ? a9.Mixed : a9.Fast : e22 ? a9.Slow : a9.Undefined;
  }
  async queryForSnapping(t14, r18, o14, a15) {
    const i12 = this.symbolLayers.filter(L).filter(((e22) => null != e22.queryForSnapping)).map(((e22) => e22.queryForSnapping(t14, r18, o14, a15))), n11 = await Promise.all(i12);
    return s2(a15), n11.flat();
  }
  destroy() {
    if (!this.destroyed) {
      super.destroy();
      for (const e22 of this.symbolLayers) null != e22 && e22.destroy();
      this.symbolLayers.length = 0, this._destroyed = true;
    }
  }
  get destroyed() {
    return this._destroyed;
  }
  get cachedMemory() {
    return r15(this);
  }
};
var u14 = null;
var d12 = new i6();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DPointSymbol.js
var s12 = class extends p10 {
  constructor(r18, o14, t14) {
    super(r18, o14, t14), this._calloutSymbolLayer = null, this.symbol.hasVisibleCallout() && (this._calloutSymbolLayer = e16(this.symbol, o14));
  }
  async doLoad(o14) {
    const a15 = this._calloutSymbolLayer ? _(this._calloutSymbolLayer.load()) : null;
    try {
      await super.doLoad(o14), s2(o14);
    } catch (l18) {
      throw this._calloutSymbolLayer?.abortLoad(), l18;
    }
    a15 && await a15;
  }
  destroy() {
    super.destroy(), this._calloutSymbolLayer = u(this._calloutSymbolLayer);
  }
  createGraphics3DGraphic(r18, o14) {
    const t14 = super.createGraphics3DGraphic(r18, o14);
    if (null != this._calloutSymbolLayer && null != t14) {
      const o15 = this._createCalloutGraphic(r18);
      o15 && t14.setCalloutGraphic(o15);
    }
    return t14;
  }
  globalPropertyChanged(r18, o14) {
    return !!super.globalPropertyChanged(r18, o14) && (!this._calloutSymbolLayer || this._calloutSymbolLayer.globalPropertyChanged(r18, o14, ((r19) => r19.calloutLayer)));
  }
  updateGeometry(r18, o14) {
    const t14 = super.updateGeometry(r18, o14);
    if (t14 && this._calloutSymbolLayer) {
      const t15 = r18.calloutLayer;
      if (t15) return this._calloutSymbolLayer.updateGeometry(t15, o14);
    }
    return t14;
  }
  _createCalloutGraphic(r18) {
    const o14 = r18.renderingInfo;
    return r18.renderingInfo = new D3(o14.renderer, o14.symbol), this._calloutSymbolLayer.createGraphics3DGraphic(r18);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolFactory.js
function t10(t14, i12, n11) {
  return "point-3d" === t14.type ? new s12(t14, i12, n11) : new p10(t14, i12, n11);
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DWebStyleSymbol.js
var o12 = class extends r13 {
  constructor(t14, r18, s17) {
    super(r18), this.symbol = t14, this._convert = s17, this.symbologySnappingSupported = false, this.graphics3DSymbol = null, this.referenced = 0;
  }
  getSymbolLayerSize(t14) {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.getSymbolLayerSize(t14) : null;
  }
  get symbolLayers() {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.symbolLayers : [];
  }
  get extentPadding() {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.extentPadding : 0;
  }
  async doLoad(t14) {
    const r18 = await this.symbol.fetchSymbol({ signal: t14 });
    r18.id = this.symbol.id, this.graphics3DSymbol = this._convert(r18), null != this.graphics3DSymbol && await this.graphics3DSymbol.load();
  }
  createGraphics3DGraphic(t14) {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.createGraphics3DGraphic(t14, this) : null;
  }
  get complexity() {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.complexity : P4;
  }
  globalPropertyChanged(t14, r18) {
    return null != this.graphics3DSymbol && this.graphics3DSymbol.globalPropertyChanged(t14, r18);
  }
  applyRendererDiff(t14, s17) {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.applyRendererDiff(t14, s17) : e14.RecreateSymbol;
  }
  prepareSymbolPatch(t14) {
    null != this.graphics3DSymbol && this.graphics3DSymbol.prepareSymbolPatch(t14);
  }
  updateGeometry(t14, r18) {
    return null != this.graphics3DSymbol && this.graphics3DSymbol.updateGeometry(t14, r18);
  }
  updateTransform(t14, r18, s17, e22) {
    return this.graphics3DSymbol?.updateTransform(t14, r18, s17, e22) ?? false;
  }
  onRemoveGraphic() {
  }
  updateFocus() {
  }
  getFastUpdateStatus() {
    return this.graphics3DSymbol?.getFastUpdateStatus() ?? a9.Loading;
  }
  destroy() {
    null != this.graphics3DSymbol && this.graphics3DSymbol.destroy(), this.graphics3DSymbol = void 0, super.destroy();
  }
  get destroyed() {
    return void 0 === this.graphics3DSymbol;
  }
  get cachedMemory() {
    return r15(this);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/GraphicsCorePerformanceInfo.js
var s13 = class {
  constructor(s17, i12, t14, h13) {
    this.total = s17, this.visible = i12, this.missing = t14, this.pending = h13;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/GraphicStateTracking.js
var s14 = class {
  constructor(t14) {
    this._graphicsCore = t14, this._idToState = /* @__PURE__ */ new Map(), this._states = /* @__PURE__ */ new Set();
    const i12 = t14.owner.layer?.objectIdField;
    i12 ? (this._getGraphicId = (t15) => R3(t15, i12), this._getGraphics3DGraphicById = (t15) => this._graphicsCore.getGraphics3DGraphicByObjectId(t15)) : (this._getGraphicId = (t15) => t15.uid, this._getGraphics3DGraphicById = (t15) => this._graphicsCore.getGraphics3DGraphicById(t15));
  }
  destroy() {
    this._idToState.clear(), this._states.forEach(((t14, i12) => this.remove(i12)));
  }
  add(t14) {
    const e22 = e((() => this.remove(t14)));
    if (this._states.has(t14)) return e22;
    const s17 = this._getGraphicId(t14.graphic), a15 = this._getGraphics3DGraphicById(s17);
    this._states.has(t14) || this._states.add(t14);
    return this._ensureStateList(s17).push(t14), t14.displaying = null != a15 && a15.isVisible(), t14.isDraped = null != a15 && a15.isDraped, t14.tracking = true, null != a15 && t14.emit("changed"), e22;
  }
  remove(i12) {
    if (this._states.has(i12)) {
      if (this._idToState.size) {
        const e22 = this._getGraphicId(i12.graphic), s17 = this._idToState.get(e22);
        s17 && (G(s17, i12), 0 === s17.length && this._idToState.delete(e22));
      }
      this._states.delete(i12), i12.tracking = false, i12.displaying = false;
    }
  }
  addGraphic(t14) {
    this._forEachState(t14.graphic, ((i12) => {
      i12.displaying = t14.isVisible(), i12.isDraped = t14.isDraped, i12.emit("changed");
    }));
  }
  removeGraphic(t14) {
    this._forEachState(t14.graphic, ((t15) => {
      t15.displaying = false, t15.isDraped = false;
    }));
  }
  updateGraphicGeometry(t14) {
    this._forEachState(t14.graphic, ((t15) => t15.emit("changed")));
  }
  updateGraphicVisibility(t14) {
    this._forEachState(t14.graphic, ((i12) => i12.displaying = t14.isVisible()));
  }
  updateGraphicError(t14, i12) {
    this._forEachState(t14, ((t15) => t15.error = i12));
  }
  allGraphicsDeleted() {
    this._states.forEach(((t14) => t14.displaying = false));
  }
  _ensureStateList(t14) {
    const i12 = this._idToState.get(t14);
    if (i12) return i12;
    const e22 = new Array();
    return this._idToState.set(t14, e22), e22;
  }
  _forEachState(t14, i12) {
    if (0 === this._states.size || 0 === this._idToState.size) return;
    const e22 = this._getGraphicId(t14), s17 = this._idToState.get(e22);
    null != s17 && s17.forEach(i12);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/SpatialIndex2D.js
var d13 = class extends b2 {
  constructor(t14) {
    super(t14), this._index = new s6(9, has("esri-csp-restrictions") ? (t15) => ({ minX: t15.extent[0], minY: t15.extent[1], maxX: t15.extent[2], maxY: t15.extent[3] }) : [".extent[0]", ".extent[1]", ".extent[2]", ".extent[3]"]), this._missing = /* @__PURE__ */ new Set(), this._boundsByFeature = /* @__PURE__ */ new Map(), this.spatialReference = null, this.hasZ = null, this.hasM = null, this.objectIdField = null, this.updating = false;
  }
  setup(t14) {
    this._addMany(t14);
  }
  destroy() {
    this._missing.clear(), this._index = u(this._index), this._boundsByFeature.clear(), this._boundsByFeature = null;
  }
  update() {
    this._missing.size > 0 && (this._addMany(Array.from(this._missing.values())), this.updating = false, this._missing.clear());
  }
  get updatingRemaining() {
    return this._missing.size;
  }
  queryGraphicUIDsInExtent(t14, e22, s17) {
    null != e22 && e22.equals(this.spatialReference) && (u15.minX = t14[0], u15.minY = t14[1], u15.maxX = t14[2], u15.maxY = t14[3], this.update(), this._index.search(u15, ((t15) => s17(t15.graphic.uid))));
  }
  add(t14) {
    this._missing.add(t14), this.updating = true;
  }
  remove(t14) {
    if (this._missing.delete(t14)) return void (this.updating = this._missing.size > 0);
    if (!t14.extent) return;
    this._index.remove(t14);
    const e22 = R3(t14.graphic, this._get("objectIdField"));
    null != e22 && this._boundsByFeature.delete(e22);
  }
  _addMany(t14) {
    if (0 === t14.length) return;
    const e22 = this._get("objectIdField");
    for (const s17 of t14) {
      s17.computeExtent(this.spatialReference);
      const t15 = R3(s17.graphic, e22);
      null != t15 && this._boundsByFeature.set(t15, s17.extent);
    }
    this._index.load(t14);
  }
  clear() {
    this._index.clear(), this._missing.clear(), this._boundsByFeature.clear(), this.updating = false;
  }
  forEachInBounds(t14, e22) {
    u15.minX = t14[0], u15.minY = t14[1], u15.maxX = t14[2], u15.maxY = t14[3], this.update(), this._index.search(u15, ((t15) => {
      e22(t15);
    }));
  }
  getBounds(t14, e22) {
    this.update();
    const s17 = this._boundsByFeature.get(t14);
    return s17 ? B(e22, s17) : null;
  }
};
r([m({ constructOnly: true })], d13.prototype, "spatialReference", void 0), r([m({ constructOnly: true })], d13.prototype, "hasZ", void 0), r([m({ constructOnly: true })], d13.prototype, "hasM", void 0), r([m({ constructOnly: true })], d13.prototype, "objectIdField", void 0), r([m()], d13.prototype, "updating", void 0), r([m({ readOnly: true })], d13.prototype, "updatingRemaining", null), d13 = r([a("esri.views.3d.layers.graphics.SpatialIndex2D")], d13);
var u15 = { minX: 0, minY: 0, maxX: 0, maxY: 0 };

// node_modules/@arcgis/core/views/3d/support/ElevationUpdateEvent.js
var e18 = class {
  constructor(e22 = "scene") {
    this.context = e22, this.extent = I();
  }
};

// node_modules/@arcgis/core/views/3d/layers/support/StageLayerElevationProvider.js
var _4 = 1;
var v4 = Symbol("layerHandles");
var y3 = class extends o.EventedMixin(b2) {
  get spatialReference() {
    return this.view?.spatialReference;
  }
  constructor(e22) {
    super(e22), this._elevationOffset = 0;
  }
  initialize() {
    this._renderCoordsHelper = this.view.renderCoordsHelper, this._intersectLayers = [this.stageLayer], this._intersector = new g8(this.view.state.viewingMode), this._intersector.options.store = i3.MIN;
    const e22 = this._computeLayerExtent(this.spatialReference, this.stageLayer);
    this._zmin = e22[2], this._zmax = e22[5];
    const t14 = this.stageLayer.events;
    this.addHandles([t14.on(["layerObjectAdded", "layerObjectRemoved", "transformationChanged", "shaderTransformationChanged"], ((e23) => this._objectChanged(e23))), t14.on(["geometryAdded", "geometryRemoved"], (({ object: e23 }) => this._objectChanged(e23))), t14.on("attributesChanged", (({ attribute: e23, object: t15 }) => E2(e23) && this._objectChanged(t15)))], v4);
  }
  dispose() {
    this.removeHandles(v4);
  }
  elevationInfoChanged() {
    const e22 = null != this.layer ? this.layer.elevationInfo : null;
    if (null != e22 && "on-the-ground" !== e22.mode) {
      const t14 = V2(this.layer.spatialReference), r18 = n5(e22.unit ?? "meters");
      this._elevationOffset = (e22.offset ?? 0) * r18 / t14;
    } else this._elevationOffset = 0;
  }
  getElevation(e22, t14, r18, s17) {
    if (x2[0] = e22, x2[1] = t14, x2[2] = r18, !this._renderCoordsHelper.toRenderCoords(x2, s17, x2)) return i.getLogger(this).error("could not project point for elevation alignment"), null;
    const i12 = this._elevationOffset, n11 = this._zmin + i12, a15 = this._zmax + i12;
    this._renderCoordsHelper.setAltitude(C4, a15, x2), this._renderCoordsHelper.setAltitude(E3, n11, x2);
    const l18 = (e23) => !!e23.lastValidElevationBB;
    return this._intersector.reset(C4, E3, null), this._intersector.intersect(this._intersectLayers, null, _4, null, l18), this._intersector.results.min.getIntersectionPoint(x2) ? this._renderCoordsHelper.getAltitude(x2) : null;
  }
  _objectChanged(e22) {
    const t14 = this.spatialReference;
    if (!e22.lastValidElevationBB || !t14) return;
    q(j3);
    const r18 = e22.lastValidElevationBB;
    r18.isEmpty() || this._expandExtent(t14, r18.min, r18.max, j3);
    const { min: o14, max: s17 } = e22.boundingVolumeWorldSpace;
    this._expandExtent(t14, o14, s17, j3), w3(j3, b8.extent), this._zmin = Math.min(this._zmin, j3[2]), this._zmax = Math.max(this._zmax, j3[5]), b8.spatialReference = t14, this.emit("elevation-change", b8), s7(r18.min, o14), s7(r18.max, s17);
  }
  _computeLayerExtent(e22, t14) {
    return q(j3), null != e22 && t14.objects.forEach(((t15) => this._expandExtent(e22, t15.boundingVolumeWorldSpace.min, t15.boundingVolumeWorldSpace.max, j3))), j3;
  }
  _expandExtent(e22, t14, r18, o14) {
    for (let s17 = 0; s17 < 8; ++s17) x2[0] = 1 & s17 ? t14[0] : r18[0], x2[1] = 2 & s17 ? t14[1] : r18[1], x2[2] = 4 & s17 ? t14[2] : r18[2], this._renderCoordsHelper.fromRenderCoords(x2, x2, e22), l4(o14, x2);
    return o14;
  }
};
r([m({ constructOnly: true })], y3.prototype, "layer", void 0), r([m({ constructOnly: true })], y3.prototype, "stageLayer", void 0), r([m({ constructOnly: true })], y3.prototype, "view", void 0), r([m()], y3.prototype, "spatialReference", null), y3 = r([a("esri.views.3d.layers.support.StageLayerElevationProvider")], y3);
var j3 = q();
var b8 = new e18();
var x2 = n2();
var C4 = n2();
var E3 = n2();

// node_modules/@arcgis/core/views/3d/support/extentUtils.js
function u16(l18, m9, u19) {
  if (null == l18 || null == u19) return false;
  let i12 = true;
  return e19[0] = null != l18.xmin ? l18.xmin : 0, e19[1] = null != l18.ymin ? l18.ymin : 0, e19[2] = null != l18.zmin ? l18.zmin : 0, i12 = i12 && o3(e19, l18.spatialReference, 0, e19, u19, 0), m9[0] = e19[0], m9[1] = e19[1], e19[0] = null != l18.xmax ? l18.xmax : 0, e19[1] = null != l18.ymax ? l18.ymax : 0, e19[2] = null != l18.zmax ? l18.zmax : 0, i12 = i12 && o3(e19, l18.spatialReference, 0, e19, u19, 0), m9[2] = e19[0], m9[3] = e19[1], null == l18.xmin && (m9[0] = -1 / 0), null == l18.ymin && (m9[1] = -1 / 0), null == l18.xmax && (m9[2] = 1 / 0), null == l18.ymax && (m9[3] = 1 / 0), i12;
}
var e19 = n2();

// node_modules/@arcgis/core/views/support/TextureCompressionTracker.js
var e20 = class {
  constructor() {
    this._pendingCompressionTasks = r5(0);
  }
  get compressing() {
    return !!this._pendingCompressionTasks.value;
  }
  increment() {
    this._pendingCompressionTasks.value++;
  }
  decrement() {
    this._pendingCompressionTasks.value--;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DCore.js
var ke;
var ze = n2();
var We = u4();
var _a;
var He = (_a = class extends b2 {
  get _viewSpatialReference() {
    return this.owner.view.spatialReference;
  }
  get spatialIndex() {
    return this._spatialIndex || (this._spatialIndex = new d13({ objectIdField: this.owner.layer?.objectIdField, spatialReference: this._viewSpatialReference, hasZ: !!this.hasZ, hasM: !!this.hasM }), this._spatialIndex.setup(Array.from(this.graphics3DGraphics.values()))), this._spatialIndex.update(), this._spatialIndex;
  }
  get deconflictor() {
    return this._deconflictor;
  }
  get labeler() {
    return this._labeler;
  }
  get numberOfGraphics() {
    return this._numberOfGraphics;
  }
  get effectiveUpdatePolicy() {
    return null != this.currentRenderer && "dictionary" === this.currentRenderer.type ? C3.ASYNC : this._forcedUpdatePolicy ?? this.preferredUpdatePolicy;
  }
  get featureStore() {
    return this._featureStore;
  }
  get initializePromise() {
    return this._initializePromise;
  }
  get scaleVisibility() {
    return this._scaleVisibility;
  }
  get elevationAlignment() {
    return this._elevationAlignment;
  }
  get objectStates() {
    return this._objectStates;
  }
  get filterVisibility() {
    return this._filterVisibility;
  }
  get updating() {
    return !!(this.dataUpdating || this._elevationAlignment?.updating || this._scaleVisibility?.updating || this._filterVisibility?.updating || this._rendererChangeAbortController || this._elevationInfoChangeAbortController || this._frameTaskHandle.updating || this._updateQueue.updating || this.running);
  }
  get dataUpdating() {
    return !!(this._graphicsWaitingForSymbol.size > 0 || this._pendingUpdates.size > 0 || this._spatialIndex?.updating || this._updatingPendingLoadedGraphicsChange || this._dataUpdateQueue.updating || this._loadingSymbols > 0 || this.compressionTracker.compressing);
  }
  get running() {
    return this._pendingUpdates.size > 0 || !!this._spatialIndex?.updating || this._dataUpdateQueue.running || this._updateQueue.running;
  }
  get suspendedOrOutsideOfView() {
    return this.owner.suspended || !!this.owner.suspendInfo?.outsideOfView;
  }
  get updatingRemaining() {
    return this.updating ? this._pendingUpdates.size + 0.1 * (this._spatialIndex?.updatingRemaining || 0) + 0.1 * (this._elevationAlignment?.updatingRemaining || 0) : 0;
  }
  get displayFeatureLimit() {
    const e22 = this.owner && this.owner.view && this.owner.view.qualitySettings, t14 = e22?.graphics3D.minTotalNumberOfFeatures ?? 0, i12 = e22?.graphics3D.maxTotalNumberOfFeatures ?? 0, r18 = e22?.graphics3D.maxNumberOfDrawCalls ?? 0, s17 = e22?.graphics3D.maxTotalNumberOfVertices ?? 0, a15 = this.averageSymbolComplexity, n11 = Math.max(1, a15?.verticesPerFeature ?? 1), o14 = a15 && a15.drawCallsPerFeature > 0 && r18 > 0 ? r18 / a15.drawCallsPerFeature : i12, l18 = Math.ceil(s17 / n11), h13 = Math.max(t14, Math.min(i12, l18, o14)), d15 = this._get("displayFeatureLimit");
    return d15 && d15.maximumTotalNumberOfVertices === s17 && d15.averageSymbolComplexity === a15 && d15.maximumNumberOfFeatures === h13 ? d15 : new e15(s17, h13, a15);
  }
  get averageSymbolComplexity() {
    const e22 = d9(this._symbolComplexities), t14 = this._get("averageSymbolComplexity");
    return 0 === e22.numComplexities || null != t14 && (e22.estimated && (t14.verticesPerFeature >= e22.verticesPerFeature || t14.verticesPerCoordinate >= e22.verticesPerCoordinate || t14.drawCallsPerFeature >= e22.drawCallsPerFeature) || t14.verticesPerFeature === e22.verticesPerFeature && t14.verticesPerCoordinate === e22.verticesPerCoordinate && t14.drawCallsPerFeature === e22.drawCallsPerFeature) ? t14 : e22;
  }
  get usedMemory() {
    const e22 = this.labelsEnabled ? (this.averageSymbolComplexity?.memory.bytesPerFeatureLabel ?? 0) * this._numberOfGraphics : 0, t14 = this._getSymbolComplexitiesUsed().reduce(((e23, t15) => e23 + t15.memory.resourceBytes), 0);
    if (null == this._symbolMaterials) {
      this._symbolMaterials = [];
      for (const e23 of this._symbols.values()) if (null != e23) {
        for (const t15 of e23.symbolLayers) if (t15) for (const e24 of t15.materials) e24 && this._symbolMaterials.push(e24);
      }
    }
    const i12 = this.owner.view.stage.renderer, r18 = this.owner.view.basemapTerrain.overlayManager.renderer, s17 = this._symbolMaterials.reduce(((e23, t15) => e23 + ((i12.getMaterialRenderer(t15) || r18.getMaterialRenderer(t15))?.usedMemory ?? 0)), 0);
    return this._usedMemory + e22 + t14 + s17;
  }
  get usedMemoryPerGraphic() {
    if (this._usedMemory && this._numberOfGraphics) {
      const e22 = this._numberOfGraphics / (this._numberOfGraphics + Math.max(this._pendingAdds, this._pendingRemoves));
      return this._usedMemory / this._numberOfGraphics * e22;
    }
    if (null != this.averageSymbolComplexity) {
      const e22 = this.labelsEnabled ? this.averageSymbolComplexity.memory.bytesPerFeatureLabel : 0;
      return this.averageSymbolComplexity.memory.bytesPerFeature + e22;
    }
    return 0;
  }
  get unprocessedMemoryEstimate() {
    return (this._pendingAdds - this._pendingRemoves) * this.usedMemoryPerGraphic;
  }
  get _symbolComplexities() {
    return this.currentRenderer ? this._getSymbolComplexitiesUsedOrRenderer(this.currentRenderer) : this._getSymbolComplexitiesUsed();
  }
  get visible() {
    return this._visible;
  }
  _getConvertedSymbol(e22) {
    const t14 = e22;
    if ("web-style" === t14.type) return t14.clone();
    const i12 = this._symbolConversionCache.get(t14.id);
    if (null != i12) return i12;
    const r18 = u6(t14, { geometryType: this.layer?.geometryType ?? void 0, retainId: true, hasLabelingContext: this._hasLabelingContext(t14), cimFallbackEnabled: true }), s17 = r18.symbol || null;
    return null == s17 && r18.error && i.getLogger(this).error(r18.error.message), this._symbolConversionCache.set(t14.id, s17), s17;
  }
  _getSymbolComplexitiesUsedOrRenderer(e22) {
    if (null == e22) return [];
    const t14 = e22.symbols, i12 = "backgroundFillSymbol" in e22 ? e22.backgroundFillSymbol : null;
    if (!i12 && !t14.length) return [];
    const r18 = [], s17 = this._getSymbolComplexityUsedOrRenderer(i12);
    null != s17 && r18.push(s17);
    for (const a15 of t14) {
      const e23 = this._getSymbolComplexityUsedOrRenderer(a15);
      null != e23 && r18.push(e23);
    }
    return r18;
  }
  _getSymbolComplexityUsedOrRenderer(e22) {
    if (null == e22) return null;
    const t14 = this._symbols.get(e22.id);
    if (null != t14) return t14.complexity;
    const i12 = this._getConvertedSymbol(e22);
    return null != i12 ? m4(i12) : null;
  }
  _getSymbolComplexitiesUsed() {
    const e22 = [];
    return this._symbols.forEach(((t14) => {
      null != t14 && e22.push(t14.complexity);
    })), e22;
  }
  get _objectIdField() {
    return this.layer.objectIdField;
  }
  constructor(e22) {
    super(e22), this._propertiesPool = new o9({ computedExtent: z }, this), this.computedExtent = null, this.currentRenderer = null, this.rendererHasGeometryOperations = false, this._graphicStateTracking = null, this.graphics3DGraphics = /* @__PURE__ */ new Map(), this.stageLayer = null, this.stage = null, this._graphicsDrapedUids = /* @__PURE__ */ new Set(), this._graphicsBySymbol = /* @__PURE__ */ new Map(), this._symbolConversionCache = /* @__PURE__ */ new Map(), this._symbols = /* @__PURE__ */ new Map(), this._graphicsWithoutSymbol = /* @__PURE__ */ new Map(), this._graphicsWaitingForSymbol = /* @__PURE__ */ new Map(), this._graphicsUpdateId = 0, this._frameTaskHandle = D, this._dataUpdateQueue = new r7(), this._updateQueue = new r7(), this._suspendSymbolCleanup = false, this._arcadeOnDemand = null, this._rendererChangeAbortController = null, this._elevationInfoChangeAbortController = null, this._initializeAbortController = null, this._elevationAlignment = null, this._scaleVisibility = null, this._filterVisibility = null, this._spatialIndex = null, this.extentPadding = 0, this._updatingPendingLoadedGraphicsChange = null, this._featureStore = null, this._deconflictor = null, this._labeler = null, this._objectStates = null, this._viewElevationProvider = null, this._stageLayerElevationProvider = null, this._sharedSymbolResourcesOwnerHandle = null, this._whenGraphics3DGraphicRequests = {}, this._pendingUpdates = /* @__PURE__ */ new Map(), this._numberOfGraphics = 0, this._numberOfGraphicsProvidingElevation = 0, this._pendingAdds = 0, this._pendingRemoves = 0, this._applyPendingRemovesFirst = false, this._loadingSymbols = 0, this._pendingUpdatesPool = new r4({ allocator: (e23) => e23 || new Be(), deallocator: (e23) => (e23.clear(), e23) }), this.compressionTracker = new e20(), this._symbolWarningLogged = false, this._geometryWarningLogged = false, this._objectIdInvisibleSet = /* @__PURE__ */ new Set(), this._whenSymbolRemoved = new r4(), this.preferredUpdatePolicy = C3.SYNC, this._forcedUpdatePolicy = null, this.elevationFeatureExpressionEnabled = true, this.owner = null, this.layer = null, this.graphicSymbolSupported = true, this.getRenderingInfoWithoutRenderer = false, this.setUidToIdOnAdd = true, this.hasZ = null, this.hasM = null, this._usedMemory = 0, this._visible = false, this._startCreateGraphics = false, this._unusedSymbolsCache = e22.owner.view.resourceController.memoryController.newCache("graphics-3d-unused-symbols", ((e23) => e23.destroy())), this.symbolCreationContext = new s11(e22.owner.view.resourceController.scheduler, ((e23, t14) => this._updateQueue.push(e23, t14)), e22.owner.layerViewUid, this.compressionTracker);
  }
  initialize() {
    this._featureStore = new l17({ objectIdField: this.owner.layer?.objectIdField, hasZ: !!this.hasZ, hasM: !!this.hasM, viewSpatialReference: this._viewSpatialReference, featureSpatialReference: this.owner.featureSpatialReference, getSpatialIndex: () => this.spatialIndex, forEach: (e23) => this.graphics3DGraphics.forEach(e23) });
    const e22 = (e23, t15, i12) => this.spatialIndex.queryGraphicUIDsInExtent(e23, t15, i12), { componentFactories: t14 } = this;
    this._elevationAlignment = t14.elevationAlignment?.(this, e22), this._scaleVisibility = t14.scaleVisibility?.(this, e22), this._filterVisibility = t14.filterVisibility?.({ featureStore: this._featureStore, getFeatureCount: () => this.graphics3DGraphics.size, updateFeatureVisibilities: (e23) => this.modifyGraphics3DGraphicVisibilities(((t15) => t15.setVisibilityFlag(A5.GRAPHIC, L5.FILTER, e23(R3(t15.graphic, this._objectIdField))))), setAllFeaturesVisibility: (e23) => this.modifyGraphics3DGraphicVisibilities(((t15) => t15.setVisibilityFlag(A5.GRAPHIC, L5.FILTER, e23))), clearFeaturesVisibility: () => this.modifyGraphics3DGraphicVisibilities(((e23) => e23.setVisibilityFlag(A5.GRAPHIC, L5.FILTER, true))) }), this._deconflictor = t14.deconflictor?.(this), this._labeler = t14.labeler?.(this, this._scaleVisibility), this._objectStates = t14.objectStates?.(this), this._initializeAbortController = new AbortController(), this.addHandles(f2((() => this.owner.view.state.highlights), (() => {
      const { highlightOrderMap: e23 } = this.owner.view.state;
      this.graphics3DGraphics.forEach(((t15) => t15.updateHighlights(e23)));
    }))), this._initializePromise = this._initializeAsync();
  }
  async _initializeAsync() {
    const e22 = this._initializeAbortController?.signal, t14 = this.owner.view;
    this._viewElevationProvider = new l16(this._viewSpatialReference, t14), this._initializeStage(t14, this.owner.layerViewUid);
    const i12 = t14.sharedSymbolResources;
    this.symbolCreationContext.sharedResources = i12, this._sharedSymbolResourcesOwnerHandle = i12.addGraphicsOwner(this.owner), null != this.currentRenderer && (this.symbolCreationContext.renderer = this.currentRenderer), this.symbolCreationContext.stage = this.stage, this.symbolCreationContext.streamDataRequester = i12.streamDataRequester, this.symbolCreationContext.renderCoordsHelper = t14.renderCoordsHelper, this.symbolCreationContext.layer = this.layer, this.symbolCreationContext.graphicsCoreOwner = this.owner, this.symbolCreationContext.localOriginFactory = new l10(t14.renderSpatialReference), this.symbolCreationContext.elevationProvider = t14.elevationProvider, this.symbolCreationContext.notifyGraphicGeometryChanged = (e23) => this.notifyGraphicGeometryChanged(e23), this.symbolCreationContext.notifyGraphicVisibilityChanged = (e23) => this.notifyGraphicVisibilityChanged(e23);
    const r18 = d8(this.layer.elevationInfo, this.elevationFeatureExpressionEnabled);
    if (this.symbolCreationContext.featureExpressionInfoContext = await a8(r18, this._viewSpatialReference, e22, i.getLogger(this)), s2(e22), this.symbolCreationContext.screenSizePerspectiveEnabled = t14.screenSizePerspectiveEnabled && !!this.layer.screenSizePerspectiveEnabled, this.symbolCreationContext.slicePlaneEnabled = !!this.owner.slicePlaneEnabled, this.symbolCreationContext.physicalBasedRenderingEnabled = !!this.owner.view.qualitySettings?.physicallyBasedRenderingEnabled, this.symbolCreationContext.skipHighSymbolLods = !!this.owner.view.qualitySettings?.graphics3D?.skipHighSymbolLods, "drapeSourceType" in this.owner) {
      const { owner: e23 } = this;
      this.symbolCreationContext.drapeSourceRenderer = t14.basemapTerrain.overlayManager.registerGeometryDrapeSource(e23), this.addHandles(e((() => t14.basemapTerrain.overlayManager.unregisterDrapeSource(e23))));
    }
    this.addHandles([l2((() => this.suspendedOrOutsideOfView), (() => this._updateQueue.unshift((() => this._updateLayerVisibility()), null).catch(d))), l2((() => [this.layer?.screenSizePerspectiveEnabled, this.owner.view?.screenSizePerspectiveEnabled]), (() => {
      const e23 = t14.screenSizePerspectiveEnabled && !!this.layer.screenSizePerspectiveEnabled;
      e23 !== this.symbolCreationContext.screenSizePerspectiveEnabled && (this.symbolCreationContext.screenSizePerspectiveEnabled = e23, this._labeler?.reset(), this.recreateAllGraphicsAndSymbols());
    })), l2((() => this.owner.slicePlaneEnabled), ((e23) => this._slicePlaneEnabledChange(!!e23))), l2((() => this.owner.view.state?.rasterPixelRatio), (() => this._pixelRatioChange())), l2((() => !!this.owner.view.qualitySettings?.physicallyBasedRenderingEnabled), ((e23) => this._physicalBasedRenderingChange(e23))), l2((() => !!this.owner.view.qualitySettings?.graphics3D?.skipHighSymbolLods), ((e23) => this._skipHighSymbolLoDsChange(e23))), l2((() => this.owner.view.focusAreasView?.polygons), (() => this._updateFocusedLabels())), l2((() => this.owner.view.map?.focusAreas.style), (() => this.recreateAllGraphicsAndSymbols())), f2((() => t14.basemapTerrain?.tilingScheme), ((e23) => {
      if (e23.spatialReference.equals(this.symbolCreationContext.overlaySR) || null == t14.basemapTerrain.spatialReference || (this.symbolCreationContext.overlaySR = t14.basemapTerrain.spatialReference), this.hasHandles("loaded-graphics")) this.recreateAllGraphics();
      else {
        const e24 = () => this.owner?.loadedGraphics;
        this.addHandles([a2(e24, "change", ((e25) => {
          this._graphicsCollectionChanged(e25), this._signalUpdatingDuringAsyncLoadedGraphicsChange();
        }), { onListenerAdd: () => {
          this.recreateAllGraphics(), this._signalUpdatingDuringAsyncLoadedGraphicsChange();
        } })], "loaded-graphics");
      }
    }), { initial: true }), l2((() => this.effectiveUpdatePolicy), ((e23) => {
      null != this.stageLayer && (this.stageLayer.updatePolicy = e23), this.symbolCreationContext.isAsync = this.effectiveUpdatePolicy === C3.ASYNC, e23 === C3.SYNC && this.runTask(C);
    }), w2)]), this._frameTaskHandle = t14.resourceController.scheduler.registerTask(g.GRAPHICS_CORE, this), this.layer && "featureReduction" in this.layer && this.addHandles(l2((() => this.layer.featureReduction), (() => this._deconflictor?.featureReductionChange()))), this.notifyChange("averageSymbolComplexity"), this.rendererChange(this.owner.renderer).catch((() => {
    })), this._initializeAbortController = null;
  }
  _abortInitialize() {
    this._initializeAbortController = e2(this._initializeAbortController);
  }
  _updateFocusedLabels() {
    this.forEachGraphics3DSymbol(((e22, t14) => {
      t14 && e22.updateFocus((({ graphic: e23 }) => this.recreateGraphics([e23])), t14);
    }));
  }
  destroy() {
    this._unusedSymbolsCache.destroy(), this._abortInitialize(), this._rendererChangeAbortController = e2(this._rendererChangeAbortController), this._abortElevationInfoChange(), this._frameTaskHandle.remove(), this._frameTaskHandle = D, this._dataUpdateQueue.cancelAll(), this._updateQueue.cancelAll(), this._deconflictor = l(this._deconflictor), this._labeler = l(this._labeler), this._elevationAlignment = u(this._elevationAlignment), this._scaleVisibility = u(this._scaleVisibility), this._filterVisibility = u(this._filterVisibility), this._objectStates = u(this._objectStates), this.clear(), this._featureStore = u(this._featureStore), this._updatingPendingLoadedGraphicsChange = l(this._updatingPendingLoadedGraphicsChange), this._graphicStateTracking = u(this._graphicStateTracking), this.stage && (this.stageLayer = u(this.stageLayer), this.stage = null), this._set("owner", null);
    for (const e22 in this._whenGraphics3DGraphicRequests) this._whenGraphics3DGraphicRequests[e22].reject(new s("graphic:layer-destroyed", "Layer has been destroyed"));
    this._whenGraphics3DGraphicRequests = null, this._sharedSymbolResourcesOwnerHandle = l(this._sharedSymbolResourcesOwnerHandle), this._propertiesPool = u(this._propertiesPool), this._pendingUpdatesPool = null, this._symbolConversionCache.clear(), this._objectIdInvisibleSet.clear(), this._spatialIndex = u(this._spatialIndex);
  }
  clear() {
    this._objectStates?.allGraphicsDeleted(), null != this._graphicStateTracking && this._graphicStateTracking.allGraphicsDeleted(), this.graphics3DGraphics.forEach(((e22) => e22.destroy())), this._spatialIndex?.clear(), this.graphics3DGraphics.clear(), this._numberOfGraphics = 0, this._usedMemory = 0, this._updateLayerVisibility(), this._symbols.forEach(u), this._symbols.clear(), this._symbolMaterials = null, this._graphicsBySymbol.clear(), this._graphicsWithoutSymbol.clear(), this._graphicsWaitingForSymbol.clear(), this._pendingUpdates.clear(), this._pendingUpdatesPool.clear(), this._pendingAdds = 0, this._pendingRemoves = 0, this._applyPendingRemovesFirst = false, this.notifyChange("dataUpdating"), this.notifyChange("running"), this.notifyChange("updatingRemaining"), this._featureStore.events.emit("changed"), this.owner.notifyContentGeometryUpdate?.();
  }
  _initializeStage(e22, t14) {
    this.stage = e22.stage, this.stageLayer = new l9(this.stage, { visible: !this.suspendedOrOutsideOfView, updatePolicy: this.effectiveUpdatePolicy }, t14);
    const i12 = this.stageLayer.events;
    i12.on("transformationChanged", ((e23) => this.notifyGraphicGeometryChanged(e23.graphicUid))), i12.on("shaderTransformationChanged", ((e23) => this.notifyGraphicGeometryChanged(e23.graphicUid))), i12.on("visibilityChanged", ((e23) => this.notifyGraphicVisibilityChanged(e23.graphicUid))), i12.on("geometryAdded", ((e23) => this.notifyGraphicGeometryChanged(e23.object.graphicUid))), i12.on("geometryRemoved", ((e23) => this.notifyGraphicGeometryChanged(e23.object.graphicUid))), i12.on("attributesChanged", ((e23) => E2(e23.attribute) && this.notifyGraphicGeometryChanged(e23.object.graphicUid)));
  }
  notifyGraphicGeometryChanged(e22) {
    if (null == this._graphicStateTracking || null == e22) return;
    const t14 = this.graphics3DGraphics.get(e22);
    t14 && this._graphicStateTracking.updateGraphicGeometry(t14);
  }
  notifyGraphicVisibilityChanged(e22) {
    if (null == this._graphicStateTracking || null == e22) return;
    const t14 = this.graphics3DGraphics.get(e22);
    t14 && this._graphicStateTracking.updateGraphicVisibility(t14);
  }
  _updateLayerVisibility() {
    const e22 = this.displayFeatureLimit.maximumNumberOfFeatures, t14 = this._numberOfGraphics > e22 * qe, i12 = !this.suspendedOrOutsideOfView && !t14;
    i12 !== this._visible && (this._visible = i12, this._updateStageLayerVisibility());
  }
  _updateStageLayerVisibility() {
    const e22 = this._visible && (null == this.layer.opacity || this.layer.opacity >= o8);
    this.stageLayer.visible !== e22 && (this.stageLayer.visible = e22, e22 ? this.updateGraphicsVisibilities() : this._hideAllGraphics(), this.owner.notifyContentGeometryUpdate?.());
  }
  getGraphics3DGraphicById(e22) {
    return null != e22 ? this.graphics3DGraphics.get(e22) : void 0;
  }
  getGraphics3DGraphicByObjectId(e22) {
    return this.owner.layer?.objectIdField ? this._findGraphics3DGraphicByObjectId(e22) : null;
  }
  _getGraphicObjectID(e22, t14 = this.owner.layer?.objectIdField) {
    return R3(e22, t14);
  }
  get graphics3DGraphicsByObjectID() {
    const e22 = this.owner.layer?.objectIdField;
    if (!e22) return;
    const t14 = /* @__PURE__ */ new Map();
    return this.graphics3DGraphics.forEach(((i12) => {
      if (!i12) return;
      const r18 = i12.graphic, s17 = this._getGraphicObjectID(r18, e22);
      null != s17 && t14.set(s17, i12);
    })), t14;
  }
  get labelsEnabled() {
    return !!this._labeler?.layerLabelsEnabled();
  }
  async updateLabelingInfo(e22) {
    const t14 = this._deconflictor?.labelingInfoChange(e22), i12 = this._labeler?.labelingInfoChange(e22);
    await Promise.allSettled([t14, i12]);
  }
  updateVisibilityInfo() {
    this._deconflictor?.labelingInfoChange(), this._labeler?.visibilityInfoChange();
  }
  get symbolUpdateType() {
    if (this._pendingUpdates.size > 0) return "unknown";
    let e22 = false, t14 = false;
    for (const [i12, r18] of this._symbols) if (null != r18) {
      switch (r18.getFastUpdateStatus()) {
        case a9.Loading:
          return "unknown";
        case a9.Fast:
          this._graphicsBySymbol.has(i12) && (t14 = true);
          break;
        case a9.Slow:
          this._graphicsBySymbol.has(i12) && (e22 = true);
          break;
        case a9.Mixed:
          this._graphicsBySymbol.has(i12) && (t14 = e22 = true);
        case a9.Undefined:
      }
    }
    return t14 ? e22 ? "mixed" : "fast" : e22 ? "slow" : "mixed";
  }
  runTask(e22) {
    if (this._dataUpdateQueue.runTask(e22), this._updateQueue.runTask(e22), this._applyPendingUpdates(e22), this.notifyChange("running"), this.running || this.notifyChange("dataUpdating"), this.notifyChange("updatingRemaining"), !e22.hasProgressed) return o4;
  }
  setObjectIdVisibility(e22, t14) {
    t14 ? this._objectIdInvisibleSet.delete(e22) : this._objectIdInvisibleSet.add(e22);
    const i12 = this._findGraphics3DGraphicByObjectId(e22);
    null != i12 && this._updateUserVisibility(i12);
  }
  _findGraphics3DGraphicByObjectId(e22) {
    return r2(this.graphics3DGraphics, ((t14) => this._getGraphicObjectID(t14.graphic) === e22));
  }
  _updateUserVisibility(e22) {
    if (null == e22) return false;
    const t14 = e22.graphic, i12 = this._getGraphicObjectID(t14), r18 = t14.visible && !this.owner.suspended && this.stageLayer.visible && (null == i12 || !this._objectIdInvisibleSet.has(i12));
    return e22.setVisibilityFlag(A5.GRAPHIC, L5.USER, r18);
  }
  _whenGraphics3DGraphic(e22) {
    const t14 = this.graphics3DGraphics.get(e22.uid);
    if (t14) return Promise.resolve(t14);
    const i12 = this._whenGraphics3DGraphicRequests[e22.uid];
    if (i12) return i12.promise;
    const r18 = L2();
    return this._whenGraphics3DGraphicRequests[e22.uid] = r18, r18.promise;
  }
  async _boundsForGraphics3DGraphic(e22, t14) {
    const i12 = this._viewSpatialReference, r18 = this.owner.view.renderSpatialReference, s17 = this.owner.view.basemapTerrain.spatialReference, a15 = (e23, t15, s18) => o3(e23, r18, t15, e23, i12, t15, s18), n11 = (e23, t15, r19) => o3(e23, s17, t15, e23, i12, t15, r19), o14 = this._viewElevationProvider ? { service: this._viewElevationProvider, useViewElevation: null != t14 && !!t14.useViewElevation, minDemResolution: null != t14 ? t14.minDemResolution : null, minDemResolutionForPoints: this.owner.view.resolution } : null, l18 = await e22.getProjectedBoundingBox(a15, n11, o14, t14?.signal);
    if (!l18) return null;
    const h13 = l18.boundingBox;
    if (l18.requiresDrapedElevation) {
      const e23 = this.symbolCreationContext.elevationProvider;
      if (e23) {
        b3(h13, ze);
        const t15 = e23.getElevation(ze[0], ze[1], 0, i12, "ground") ?? 0;
        h13[2] = Math.min(h13[2], t15), h13[5] = Math.max(h13[5], t15);
      }
    }
    return { boundingBox: h13, screenSpaceObjects: l18.screenSpaceObjects };
  }
  async whenGraphicBounds(e22, t14) {
    await j((() => this.owner?.loadedGraphics));
    const i12 = this.owner.layer?.objectIdField, s17 = this.owner.loadedGraphics.find(((t15) => t15 === e22 || null != i12 && null != t15.attributes && e22.attributes && t15.attributes[i12] === e22.attributes[i12]));
    if (!s17) throw new s("internal:graphic-not-part-of-view", "Graphic is not part of this view");
    const a15 = await this._whenGraphics3DGraphic(s17);
    return this._boundsForGraphics3DGraphic(a15, t14);
  }
  computeAttachmentOrigin(e22, t14) {
    const i12 = this.graphics3DGraphics.get(e22.uid);
    if (!i12) return null;
    const r18 = i12.computeAttachmentOrigin();
    if (0 === r18.render.num && 0 === r18.draped.num) return null;
    o5(Ye, 0, 0, 0);
    let s17 = 0;
    if (r18.render.num > 0) {
      if (!n6(r18.render.origin, this.symbolCreationContext.renderCoordsHelper.spatialReference, Qe, t14)) return null;
      u5(Ye, Ye, Qe), s17++;
    }
    if (r18.draped.num > 0) {
      const [e23, i13] = r18.draped.origin, a15 = this._viewElevationProvider.getElevation(e23, i13, "ground") ?? 0;
      if (o5(Qe, e23, i13, a15), !n6(Qe, this._viewElevationProvider.spatialReference, Qe, t14)) return null;
      u5(Ye, Ye, Qe), s17++;
    }
    return s17 > 1 && g2(Ye, Ye, 1 / s17), new _2({ x: Ye[0], y: Ye[1], z: Ye[2], spatialReference: t14 });
  }
  getSymbolLayerSize(e22, t14) {
    const i12 = this._symbols.get(e22.id);
    if (null == i12) throw new s("internal:symbol-not-part-of-view", "Symbol is not part of this view");
    const s17 = e22.symbolLayers.indexOf(t14);
    if (-1 === s17) throw new s("internal:missing-symbol-layer", "Symbol layer is not in symbol");
    const a15 = i12.getSymbolLayerSize(s17);
    if (null == a15) throw new s("internal:missing-size", "Symbol layer has no valid size");
    return a15;
  }
  _graphicsCollectionChanged(e22) {
    this._startCreateGraphics && (this.add(e22.added), this.remove(e22.removed));
  }
  graphicUpdateHandler(e22) {
    const t14 = e22.graphic.uid, i12 = this.graphics3DGraphics.get(t14);
    if (null != i12 || null != this._graphicsWithoutSymbol.get(t14)) {
      switch (e22.property) {
        case "visible":
          this._graphicUpdateVisibleHandler(i12);
          break;
        case "geometry":
          this._graphicUpdateGeometryHandler(i12, e22);
          break;
        case "symbol":
          this._graphicUpdateSymbolHandler(i12, e22);
          break;
        case "attributes":
        case "popupTemplate":
          break;
        case "origin-transform":
          this._graphicUpdateTransformHandler(i12, e22);
      }
      this.owner.notifyContentGeometryUpdate?.();
    }
  }
  _graphicUpdateGeometryHandler(e22, t14) {
    this._graphicUpdateGeometryOrTransformHandler(e22, t14, (() => !(null == t14.newValue || null == e22 || !e22.graphics3DSymbol.updateGeometry(e22, t14.newValue) || !(this._labeler?.updateGraphicGeometry(e22) ?? 1)) && (this._labeler?.setDirty(), true)));
    const i12 = t14.graphic.geometry;
    null != i12 && this._expandComputedExtent(i12);
  }
  _graphicUpdateTransformHandler(e22, t14) {
    const i12 = t14.graphic.geometry;
    this._graphicUpdateGeometryOrTransformHandler(e22, t14, (() => null != t14.newValue && null != e22 && null != i12 && e22.graphics3DSymbol.updateTransform(e22, i12.spatialReference, t14.newValue, t14.action)));
  }
  _graphicUpdateGeometryOrTransformHandler(e22, t14, i12) {
    if (null != t14.graphic.geometry) if (null != e22) i12() || this._recreateGraphic(e22.graphic);
    else {
      const e23 = t14.graphic.symbol?.id;
      if (e23) {
        const t15 = this._symbols.get(e23);
        if (null != t15 && t15.loadStatus === l12.LOADING) return;
      }
      this._recreateGraphic(t14.graphic);
    }
    else this._recreateGraphic(t14.graphic);
  }
  _graphicUpdateSymbolHandler(e22, t14) {
    const i12 = t14.graphic, r18 = null != e22 ? e22.graphics3DSymbol : null != t14.oldValue ? this._symbols.get(t14.oldValue.id) : null;
    if (null == r18 || null == t14.newValue) return void this._recreateGraphic(i12);
    const s17 = r18.symbol, a15 = this._getConvertedSymbol(t14.newValue);
    if (null != a15 && (a15.type !== s17.type || "web-style" === a15.type) || "web-style" === s17.type) return void this._recreateGraphic(i12);
    const n11 = this._graphicsBySymbol.get(s17.id);
    if (n11 && 1 !== n11.size) return void this._recreateGraphic(i12);
    const o14 = y(s17, a15);
    if (null == o14) return void this._updateSymbolMapping(s17.id, a15);
    const l18 = { diff: o14, graphics3DGraphicPatches: [], symbolStatePatches: [] };
    if (r18.prepareSymbolPatch(l18), !d3(l18.diff)) return void this._recreateGraphic(i12);
    const h13 = this._getRenderingInfo(i12, false);
    if (null == h13) return void this._recreateGraphic(i12);
    const d15 = r18.extentPadding;
    for (const p12 of l18.symbolStatePatches) p12();
    if (d15 !== r18.extentPadding && this._recomputeExtentPadding(), null != e22) for (const p12 of l18.graphics3DGraphicPatches) p12(e22, h13);
    this._updateSymbolMapping(s17.id, a15);
  }
  _graphicUpdateVisibleHandler(e22) {
    this._updateUserVisibility(e22) && (this._labeler?.setDirty(), this._deconflictor?.setDirty());
  }
  recreateGraphics(e22) {
    this._suspendSymbolCleanup = true, this.remove(e22), this.add(e22), this._suspendSymbolCleanup = false, this.effectiveUpdatePolicy === C3.SYNC && this._cleanupSymbols();
  }
  _recreateGraphic(e22) {
    this.recreateGraphics([e22]);
  }
  _beginGraphicUpdate(e22) {
    const t14 = this._graphicsUpdateId;
    return this._graphicsUpdateId++, this._graphicsWaitingForSymbol.set(e22.uid, t14), 1 === this._graphicsWaitingForSymbol.size && this.notifyChange("dataUpdating"), t14;
  }
  _endGraphicUpdate(e22, t14) {
    e22 && (t14 && this._graphicStateTracking?.updateGraphicError(e22, t14), this._graphicsWaitingForSymbol.delete(e22.uid), 0 === this._graphicsWaitingForSymbol.size && (this._cleanupSymbols(), this.notifyChange("dataUpdating")));
  }
  _recomputeExtentPadding() {
    let e22 = 0;
    this._symbols.forEach(((t14) => {
      null != t14 && (e22 = Math.max(e22, t14.extentPadding));
    })), this._set("extentPadding", e22);
  }
  _expandComputedExtent(e22) {
    const t14 = We, i12 = e22.spatialReference;
    v(e22, t14);
    const r18 = this._viewSpatialReference, s17 = ke.tmpVec;
    if (s3(i12, r18) || t2(t14[0], t14[1], 0, i12, s17, r18) && (t14[0] = s17[0], t14[1] = s17[1], t2(t14[3], t14[4], 0, i12, s17, r18), t14[3] = s17[0], t14[4] = s17[1]), !(isFinite(t14[0]) && isFinite(t14[3]) && isFinite(t14[1]) && isFinite(t14[4]))) return;
    const a15 = this.computedExtent;
    let n11 = null;
    const o14 = isFinite(t14[2]) && isFinite(t14[5]), l18 = o14 && (null == a15?.zmin || t14[2] < a15.zmin), h13 = o14 && (null == a15?.zmax || t14[5] > a15.zmax);
    if (a15) {
      (t14[0] < a15.xmin || t14[1] < a15.ymin || t14[3] > a15.xmax || t14[4] > a15.ymax || l18 || h13) && (n11 = this._propertiesPool.get("computedExtent"), n11.xmin = Math.min(t14[0], a15.xmin), n11.ymin = Math.min(t14[1], a15.ymin), n11.xmax = Math.max(t14[3], a15.xmax), n11.ymax = Math.max(t14[4], a15.ymax), n11.spatialReference = r18);
    } else n11 = this._propertiesPool.get("computedExtent"), n11.xmin = t14[0], n11.ymin = t14[1], n11.xmax = t14[3], n11.ymax = t14[4], n11.spatialReference = r18;
    n11 && (l18 && (n11.zmin = t14[2]), h13 && (n11.zmax = t14[5]), this._set("computedExtent", n11));
  }
  _abortElevationInfoChange() {
    this._elevationInfoChangeAbortController && (this._elevationInfoChangeAbortController.abort(), this._elevationInfoChangeAbortController = null);
  }
  async elevationInfoChange() {
    this._abortElevationInfoChange();
    const e22 = new AbortController();
    this._elevationInfoChangeAbortController = e22;
    const t14 = d8(this.layer.elevationInfo, this.elevationFeatureExpressionEnabled);
    this.symbolCreationContext.featureExpressionInfoContext = await a8(t14, this._viewSpatialReference, e22.signal, i.getLogger(this)), s2(e22.signal), this._elevationInfoChangeAbortController = null, this._labeler?.elevationInfoChange(), this.forEachGraphics3DSymbol(((e23, t15, i12) => {
      e23.globalPropertyChanged("elevationInfo", t15) ? t15?.forEach(((e24) => {
        const t16 = e24.graphic, i13 = e24.labelLayers;
        for (const r18 of i13) {
          r18.graphics3DSymbolLayer.updateGraphicElevationContext(t16, r18);
        }
      })) : this._recreateSymbol(i12);
    })), this.updateStageLayerElevationProvider(), this._elevationAlignment?.elevationInfoChange();
  }
  updateStageLayerElevationProvider() {
    this._stageLayerElevationProvider ? (this.layer.elevationInfo && "relative-to-scene" === this.layer.elevationInfo.mode || 0 === this._numberOfGraphicsProvidingElevation) && (this.owner.view.elevationProvider.unregister(this._stageLayerElevationProvider), this._stageLayerElevationProvider = r3(this._stageLayerElevationProvider)) : (!this.layer.elevationInfo || this.layer.elevationInfo && "relative-to-scene" !== this.layer.elevationInfo.mode) && this._numberOfGraphicsProvidingElevation > 0 && (this._stageLayerElevationProvider = new y3({ layer: this.layer, stageLayer: this.stageLayer, view: this.owner.view }), this.owner.view.elevationProvider.register("scene", this._stageLayerElevationProvider));
  }
  _clearSymbolsAndGraphics() {
    this.clear(), null != this._filterVisibility && this._filterVisibility.clear(), this._labeler?.reset(), this._deconflictor?.clear(), this._elevationAlignment?.clear(), this.stageLayer?.invalidateSpatialQueryAccelerator(), this._stageLayerElevationProvider && (this.owner.view.elevationProvider.unregister(this._stageLayerElevationProvider), this._stageLayerElevationProvider = r3(this._stageLayerElevationProvider));
  }
  startCreateGraphics() {
    this._startCreateGraphics = true, this.recreateAllGraphics();
  }
  recreateAllGraphics() {
    this._recreateAllGraphics(false);
  }
  recreateAllGraphicsAndSymbols() {
    this._recreateAllGraphics(true);
  }
  _recreateAllGraphics(e22 = false) {
    if (!this._startCreateGraphics) return;
    const { loadedGraphics: t14, view: i12 } = this.owner, r18 = i12.basemapTerrain?.tilingScheme && t14?.length ? t14.toArray() : null;
    !e22 && r18 || this._clearSymbolsAndGraphics(), this.symbolCreationContext.screenSizePerspectiveEnabled = this.owner.view.screenSizePerspectiveEnabled && !!this.layer.screenSizePerspectiveEnabled, this.symbolCreationContext.slicePlaneEnabled = !!this.owner.slicePlaneEnabled, this._set("computedExtent", null), r18 && (e22 ? this.add(r18) : this.recreateGraphics(r18));
  }
  _recreateSymbol(e22) {
    const t14 = this._graphicsBySymbol.get(e22), i12 = [];
    t14 && (t14.forEach(((e23, t15) => {
      const r19 = e23.usedMemory;
      this._conditionalRemove(e23, t15), this._spatialIndex?.remove(e23), i12.push(e23.graphic), e23.destroy(), this._removeGraphics3DGraphic(t15, r19), this._updateLayerVisibility(), this._featureStore.events.emit("changed"), this.owner.notifyContentGeometryUpdate?.();
    })), this._graphicsBySymbol.set(e22, /* @__PURE__ */ new Map()));
    const r18 = this._symbols.get(e22);
    u(r18), this._symbols.delete(e22), this._symbolMaterials = null, u(this._unusedSymbolsCache.pop(e22)), this.add(i12);
  }
  _recreateGraphicsForSymbol(e22) {
    const t14 = this._graphicsBySymbol.get(e22);
    if (t14) {
      const e23 = [];
      t14.forEach(((t15) => e23.push(t15.graphic))), this.recreateGraphics(e23);
    }
  }
  _conditionalRemove(e22, t14) {
    this._graphicsDrapedUids.delete(t14), this._objectStates?.removeGraphic(e22), this._labeler?.removeGraphic(e22), this._deconflictor?.removeGraphic(e22), null != this._graphicStateTracking && this._graphicStateTracking.removeGraphic(e22);
  }
  add(e22) {
    e22 && 0 !== e22.length && (this.owner.view.basemapTerrain?.tilingScheme ? (this._updatePolicyForGraphics(e22) === C3.ASYNC ? this._addDelayed(e22) : this._addImmediate(e22), this.notifyChange("dataUpdating")) : i.getLogger(this).error("#add()", "Cannot add graphics before terrain surface has been initialized"));
  }
  _updatePolicyForGraphics(e22) {
    if (this.effectiveUpdatePolicy === C3.SYNC && ("mesh" === this.layer.geometryType || null == this.layer.geometryType)) {
      for (const t14 of e22) if (null != t14.geometry && "mesh" === t14.geometry.type && !t14.geometry.loaded) return C3.ASYNC;
    }
    return this.effectiveUpdatePolicy;
  }
  _addImmediate(e22) {
    this._geometryWarningLogged = false, this._symbolWarningLogged = false;
    for (const t14 of e22) this._addGraphic(t14, this._getRenderingInfo(t14), C3.SYNC);
    this._cleanupSymbols(), this._labeler?.setDirty(), this._deconflictor?.setDirty();
  }
  _addDelayed(e22) {
    for (const t14 of e22) {
      const e23 = t14.uid;
      let i12 = this._pendingUpdates.get(e23);
      i12 ? i12.add ? i12.state !== Ne.NEW && i12.abortController?.abort() : this._pendingAdds++ : (i12 = this._pendingUpdatesPool.pushNew(), this._pendingAdds++, this._pendingUpdates.set(e23, i12)), i12.add = t14;
    }
    this.notifyChange("running"), this.notifyChange("updatingRemaining"), this.notifyChange("dataUpdating");
  }
  remove(e22) {
    this.effectiveUpdatePolicy === C3.ASYNC ? this._removeDelayed(e22) : this._removeImmediate(e22), this.notifyChange("dataUpdating");
  }
  _removeImmediate(e22) {
    for (const t14 of e22) this._removeGraphic(t14);
    this._cleanupSymbols(), this._labeler?.setDirty(), this._deconflictor?.setDirty();
  }
  _removeDelayed(e22) {
    for (const t14 of e22) {
      const e23 = t14.uid, i12 = this._pendingUpdates.get(e23);
      if (i12) i12.add && (i12.remove ? i12.add = null : this._pendingUpdates.delete(e23), i12.state === Ne.LOADING && i12.abortController?.abort(), this._pendingAdds--);
      else {
        const i13 = this._pendingUpdatesPool.pushNew();
        i13.remove = t14, this._pendingUpdates.set(e23, i13), this._pendingRemoves++, this._applyPendingRemovesFirst = true;
      }
    }
    0 === this._pendingUpdates.size && this._finishPendingUpdates(), this.notifyChange("running"), this.notifyChange("updatingRemaining"), this.notifyChange("dataUpdating");
  }
  _finishPendingUpdates() {
    this._pendingUpdatesPool.clear(), this._cleanupSymbols(), (this._pendingAdds || this._pendingRemoves) && i.getLogger(this).warn("pendingAdds/Removes in inconsistent state!"), this._pendingAdds = 0, this._pendingRemoves = 0, this._applyPendingRemovesFirst = false;
  }
  _applyPendingUpdates(e22) {
    if (this._geometryWarningLogged = false, this._symbolWarningLogged = false, 0 === this._pendingUpdates.size && this._spatialIndex?.updating) return this._spatialIndex.update(), void e22.madeProgress();
    if (this._applyPendingRemovesFirst) {
      this._applyPendingRemovesFirst = false;
      for (const [t14, i12] of this._pendingUpdates) {
        if (e22.done) {
          this._applyPendingRemovesFirst = true;
          break;
        }
        if (i12.remove && !i12.add && (this._pendingRemoves--, e22.madeProgress(), this._removeGraphic(i12.remove), i12.remove = null, this._pendingUpdates.delete(t14), 0 === this._pendingRemoves)) break;
      }
    }
    for (const [t14, i12] of this._pendingUpdates) {
      if (e22.done) break;
      i12.add && i12.state === Ne.NEW && this._processPendingUpdateNew(i12);
      let r18 = this.effectiveUpdatePolicy;
      if (!i12.remove || i12.add && i12.state !== Ne.READY || (this._pendingRemoves--, e22.madeProgress(), this._removeGraphic(i12.remove), i12.remove = null, r18 = C3.SYNC), i12.add) switch (i12.state) {
        case Ne.READY:
          this._addGraphic(i12.add, i12.renderingInfo, r18), i12.add = null, this._pendingAdds--, e22.madeProgress();
          break;
        case Ne.REJECTED:
          i12.add = null, this._pendingAdds--;
        case Ne.LOADING:
      }
      null == i12.remove && null == i12.add && this._pendingUpdates.delete(t14);
    }
    0 === this._pendingUpdates.size && (this._finishPendingUpdates(), this.notifyChange("running"), this.notifyChange("dataUpdating"));
  }
  _processPendingUpdateNew(e22) {
    if (!e22.add) return void (e22.state = Ne.READY);
    const t14 = e22.add.geometry;
    null == t14 || "mesh" !== t14.type || t14.loaded ? this._processPendingUpdateNewRenderingInfo(e22) : this._processPendingUpdateNewMesh(e22, t14);
  }
  async _processPendingUpdateNewMesh(e22, t14) {
    e22.state = Ne.LOADING, e22.abortController = new AbortController();
    const i12 = e22.abortController.signal;
    try {
      await t14.load({ signal: i12 });
    } catch (r18) {
      return this._processPendingUpdateNewError(e22, r18);
    }
    e22.abortController = null, this._processPendingUpdateNewRenderingInfo(e22);
  }
  _processPendingUpdateNewError(e22, t14) {
    e22.abortController = null, b(t14) ? e22.state = Ne.NEW : e22.state = Ne.REJECTED;
  }
  async _processPendingUpdateNewRenderingInfo(e22) {
    if (null == this.layer.renderer || "dictionary" !== this.layer.renderer.type) return e22.renderingInfo = this._getRenderingInfo(e22.add), void (e22.state = Ne.READY);
    e22.state = Ne.LOADING, e22.abortController = new AbortController();
    let t14 = null;
    try {
      t14 = await this._getRenderingInfoAsync(e22.add, { signal: e22.abortController.signal });
    } catch (i12) {
      return e22.abortController = null, void (b(i12) ? e22.state = Ne.NEW : e22.state = Ne.REJECTED);
    }
    null == t14?.symbol ? (this._symbolWarningLogged || (this._symbolWarningLogged = true, i.getLogger(this).warn(`Graphic in layer ${this.layer.id} has no symbol and will not render`)), e22.renderingInfo = null) : e22.renderingInfo = t14, e22.state = Ne.READY;
  }
  _addGraphic(e22, t14, i12) {
    if (this._graphicsWithoutSymbol.set(e22.uid, e22), null == t14?.symbol || !b4(e22)) return;
    const r18 = this.stage.renderView.olidRenderHelper;
    if (r18 && this.setUidToIdOnAdd) {
      const t15 = c(this.owner.view, this.owner.layerViewUid);
      r18.setUidToObjectAndLayerId(e22.objectId, e22.uid, this.layer.id, this.owner.layerViewUid, !!this.layer.popupEnabled && !t15 && u9(this.layer, this.owner.view.popup?.defaultPopupTemplateEnabled));
    }
    const s17 = t14.symbol, a15 = this.getOrCreateGraphics3DSymbol(s17, t14.renderer);
    if (null == a15) return;
    this._expandComputedExtent(e22.geometry);
    const n11 = this._beginGraphicUpdate(e22), o14 = new r14(e22, t14, this.layer);
    let l18 = false;
    const h13 = (e23) => {
      e23 === a15.symbol.id && (l18 = true);
    };
    this._whenSymbolRemoved.push(h13);
    const d15 = () => {
      if (--this._loadingSymbols, this.destroyed) return;
      this._whenSymbolRemoved.removeUnordered(h13);
      if (this._graphicsWaitingForSymbol.get(e22.uid) !== n11 || l18 || a15.destroyed || this.graphicSymbolSupported && e22.symbol && e22.symbol.id !== a15.symbol.id) --a15.referenced, this._cleanupSymbols();
      else {
        const t15 = this._createGraphics3DGraphic(a15, o14);
        this._spatialIndex && null != t15 && this._spatialIndex.add(t15), --a15.referenced, this._endGraphicUpdate(e22);
      }
      this._featureStore.events.emit("changed"), this.owner.notifyContentGeometryUpdate?.(), this._labeler?.setDirty();
    }, p12 = (t15) => {
      --this._loadingSymbols, this.destroyed || (this._whenSymbolRemoved.removeUnordered(h13), l18 || (b(t15) ? this.add([e22]) : a15.destroyed || this._endGraphicUpdate(e22, t15)));
    };
    ++this._loadingSymbols, i12 === C3.ASYNC ? a15.load((() => this._dataUpdateQueue.push(d15, null).catch(d)), ((e23) => this._dataUpdateQueue.push((() => p12(e23)), null).catch(d))) : a15.load(d15, p12);
  }
  _removeGraphic(e22) {
    const t14 = e22.uid, i12 = this.graphics3DGraphics.get(t14);
    if (i12) {
      i12.graphics3DSymbol.onRemoveGraphic(i12);
      const e23 = i12.usedMemory, r18 = i12.isElevationSource;
      this._conditionalRemove(i12, t14), this._spatialIndex?.remove(i12);
      const s17 = i12.graphics3DSymbol.symbol.id;
      this._graphicsBySymbol.get(s17)?.delete(t14), this._graphicsWithoutSymbol.delete(t14), this._removeGraphics3DGraphic(t14, e23, r18), i12.destroy(), this._featureStore.events.emit("changed"), this.owner.notifyContentGeometryUpdate?.();
    } else this._graphicsWithoutSymbol.delete(t14), this._graphicsWaitingForSymbol.delete(t14), 0 === this._graphicsWaitingForSymbol.size && (this._cleanupSymbols(), this.notifyChange("dataUpdating"));
  }
  _hasLabelingContext(e22) {
    if (e22 instanceof f5 || e22 instanceof g3) {
      const t14 = this.symbolCreationContext.layer;
      return !!t14.labelingInfo && t14.labelingInfo.some(((t15) => t15.symbol === e22));
    }
    return false;
  }
  _hasValidSymbolCreationContext(e22) {
    return !(e22 instanceof f5 && !this._hasLabelingContext(e22)) || (i.getLogger(this).error("LabelSymbol3D is only valid as part of a LabelClass. Using LabelSymbol3D as a renderer symbol is not supported."), false);
  }
  _getRenderingInfo(e22, t14 = true) {
    const i12 = e22.geometry;
    if (null == i12) return t14 && !this._geometryWarningLogged && (this._geometryWarningLogged = true, i.getLogger(this).warn(`Graphic in layer ${this.layer.id} has no geometry and will not render`)), null;
    if (!L3(i12.spatialReference, this._viewSpatialReference)) return t14 && !this._geometryWarningLogged && (this._geometryWarningLogged = true, i.getLogger(this).warn(`Graphic in layer ${this.layer.id} has incompatible spatial reference and will not render`)), null;
    if (!this.graphicSymbolSupported && null != e22.symbol) return t14 && !this._symbolWarningLogged && (this._symbolWarningLogged = true, i.getLogger(this).warn(`Graphic in layer ${this.layer.id} is not allowed to have a symbol, use a renderer instead`)), null;
    const r18 = this.rendererHasGeometryOperations ? c4(e22, this.layer) : e22;
    let s17;
    if (this.owner.getRenderingInfo && (this.getRenderingInfoWithoutRenderer || null != this.currentRenderer)) s17 = this.owner.getRenderingInfo(r18, this.currentRenderer, this._arcadeOnDemand);
    else {
      const e23 = r18.symbol || d4(r18.geometry);
      s17 = new l11(null, e23);
    }
    return null == s17?.symbol ? (t14 && !this._symbolWarningLogged && (this._symbolWarningLogged = true, i.getLogger(this).warn(`Graphic in layer ${this.layer.id} has no symbol and will not render`)), null) : s17;
  }
  _getRenderingInfoAsync(e22, t14) {
    if (null == e22.geometry) return this._geometryWarningLogged || (this._geometryWarningLogged = true, i.getLogger(this).warn(`Graphic in layer ${this.layer.id} has no geometry and will not render`)), null;
    if (!this.graphicSymbolSupported && null != e22.symbol) return this._symbolWarningLogged || (this._symbolWarningLogged = true, i.getLogger(this).warn(`Graphic in layer ${this.layer.id} is not allowed to have a symbol, use a renderer instead`)), null;
    const i12 = this.rendererHasGeometryOperations ? c4(e22, this.layer) : e22;
    return this.owner.getRenderingInfoAsync(i12, this.currentRenderer, this._arcadeOnDemand, t14);
  }
  _createGraphics3DSymbol(e22, t14) {
    if (!this._hasValidSymbolCreationContext(e22)) return null;
    const i12 = this._getConvertedSymbol(e22);
    if (!i12) return null;
    let r18;
    if (null != t14 && "backgroundFillSymbol" in t14 && t14.backgroundFillSymbol) {
      const e23 = u6(t14.backgroundFillSymbol, { ignoreDrivers: true });
      null != e23.symbol && (r18 = e23.symbol.symbolLayers);
    }
    const s17 = t10(i12, this.symbolCreationContext, r18);
    return s17.load((() => {
      const e23 = s17.extentPadding;
      e23 > this.extentPadding && this._set("extentPadding", e23), this.notifyChange("averageSymbolComplexity");
    }), (() => {
    })), s17;
  }
  getOrCreateGraphics3DSymbol(e22, t14) {
    let i12 = this._symbols.get(e22.id);
    if (void 0 === i12) {
      const r18 = this._unusedSymbolsCache.pop(e22.id);
      i12 = null != r18 ? r18 : e22 instanceof u7 ? new o12(e22, ((e23) => this._dataUpdateQueue.push(e23, null)), ((e23) => this._createGraphics3DSymbol(e23, t14))) : this._createGraphics3DSymbol(e22, t14), this._symbols.set(e22.id, i12), this._symbolMaterials = null;
    }
    return null != i12 && ++i12.referenced, i12;
  }
  trackGraphicState(e22) {
    return null == this._graphicStateTracking && (this._graphicStateTracking = new s14(this)), this._graphicStateTracking.add(e22);
  }
  _addGraphics3DGraphic(e22) {
    this._usedMemory += e22.usedMemory, this.graphics3DGraphics.set(e22.graphic.uid, e22), this._numberOfGraphics++, e22.isElevationSource && (this._numberOfGraphicsProvidingElevation++, this.updateStageLayerElevationProvider()), this._updateLayerVisibility();
  }
  _removeGraphics3DGraphic(e22, t14, i12 = false) {
    this._usedMemory -= t14, this.graphics3DGraphics.delete(e22), this._numberOfGraphics--, i12 && (this._numberOfGraphicsProvidingElevation--, this.updateStageLayerElevationProvider()), this._updateLayerVisibility();
  }
  _createGraphics3DGraphic(e22, t14) {
    const i12 = t14.graphic;
    if (this._graphicsWithoutSymbol.delete(i12.uid), !this._symbols.has(e22.symbol.id)) return this.add([i12]), null;
    if (this.graphics3DGraphics.has(i12.uid)) return null;
    const r18 = e22.createGraphics3DGraphic(t14);
    if (null == r18) return null;
    this._addGraphics3DGraphic(r18);
    const s17 = e22.symbol.id;
    this._graphicsBySymbol.has(s17) || this._graphicsBySymbol.set(s17, /* @__PURE__ */ new Map()), this._graphicsBySymbol.get(s17).set(i12.uid, r18);
    if (r18.isDraped && this._graphicsDrapedUids.add(i12.uid), r18.centroid = null, null != i12.geometry && "point" !== i12.geometry.type && (r18.centroid = b5(i12.geometry, this._viewSpatialReference)), this._updateUserVisibility(r18), null != this._scaleVisibility && this._scaleVisibility.updateVisibility(r18), null != this._filterVisibility) {
      const { defaultVisibility: e23 } = this._filterVisibility;
      r18.setVisibilityFlag(A5.GRAPHIC, L5.FILTER, e23), e23 || this._filterVisibility.reapply();
    }
    this._deconflictor?.addGraphic(r18), this._labeler?.addGraphic(r18), this._objectStates?.addGraphic(r18), r18.initialize(this.stageLayer), null != this._graphicStateTracking && this._graphicStateTracking.addGraphic(r18);
    const a15 = this._whenGraphics3DGraphicRequests[i12.uid];
    return a15 && (delete this._whenGraphics3DGraphicRequests[i12.uid], a15.resolve(r18)), this._symbolMaterials = null, r18;
  }
  async rendererChange(e22) {
    if (this._rendererChangeAbortController = e2(this._rendererChangeAbortController), e22 !== this.currentRenderer) if (this._validateRenderer(e22), null == e22 && this._currentRendererChange(null, false), s10(e22)) if (e22?.arcadeRequired) {
      const t14 = new AbortController();
      this._rendererChangeAbortController = t14;
      const { arcadeUtils: i12 } = await this._ensureArcade();
      s2(t14);
      const r18 = i12.hasGeometryOperations(e22);
      r18 && (await i12.enableGeometryOperations(), s2(t14)), this.effectiveUpdatePolicy === C3.ASYNC ? await this._updateQueue.push((() => this._currentRendererChange(e22, r18)), t14.signal) : this._currentRendererChange(e22, r18), this._rendererChangeAbortController = null;
    } else if (this.effectiveUpdatePolicy === C3.ASYNC) {
      const t14 = new AbortController();
      this._rendererChangeAbortController = t14, await this._updateQueue.push((() => this._currentRendererChange(e22, false)), t14.signal), this._rendererChangeAbortController = null;
    } else this._currentRendererChange(e22, false);
    else this._currentRendererChange(e22, false);
  }
  async _ensureArcade() {
    return null == this._arcadeOnDemand ? (this._arcadeOnDemand = await e11(), this._arcadeOnDemand) : this._arcadeOnDemand;
  }
  _currentRendererChange(e22, t14) {
    this.currentRenderer = e22, this.rendererHasGeometryOperations = t14, this.symbolCreationContext.arcade = this._arcadeOnDemand;
    const i12 = this.symbolCreationContext.renderer;
    if (e22 === i12) return;
    if (this._symbolConversionCache.clear(), this._unusedSymbolsCache.clear(), null == e22) return this.symbolCreationContext.renderer = null, void this.recreateAllGraphicsAndSymbols();
    const r18 = y(i12, e22);
    this._updateUnchangedSymbolMappings(r18, e22, i12), this.symbolCreationContext.renderer = e22, null != r18 && ("complete" === r18.type ? this.recreateAllGraphicsAndSymbols() : "partial" === r18.type && (this._applyRendererDiff(r18, e22, i12) ? this._labeler?.reset() : this.recreateAllGraphicsAndSymbols()), this.notifyChange("averageSymbolComplexity"));
  }
  _diffHasSymbolChange(e22) {
    for (const t14 in e22.diff) switch (t14) {
      case "visualVariables":
      case "defaultSymbol":
      case "uniqueValueInfos":
        break;
      case "uniqueValueGroups":
      case "authoringInfo":
      case "fieldDelimiter":
        delete e22.diff[t14];
        break;
      default:
        return true;
    }
    return false;
  }
  _applySymbolSetDiff(e22, t14, i12) {
    e22 = e22 || [], t14 = t14 || [];
    const r18 = [];
    for (const s17 of t14) {
      const t15 = this._graphicsBySymbol.get(s17.id);
      t15 && t15.forEach(((a15, n11) => {
        const o14 = a15.graphic, l18 = this.layer instanceof h7 ? this.layer : null, h13 = this._arcadeOnDemand;
        if (s17 === i12.defaultSymbol && i12.getSymbol(c4(o14, l18), { arcade: h13 }) === i12.defaultSymbol) return;
        const d15 = a15.usedMemory;
        e22.length || i12.defaultSymbol ? r18.push(o14) : this._graphicsWithoutSymbol.set(n11, o14);
        const p12 = this.graphics3DGraphics.get(n11);
        this._conditionalRemove(p12, n11), a15.destroy(), t15.delete(n11), this._removeGraphics3DGraphic(n11, d15), this._updateLayerVisibility();
      })), this._whenSymbolRemoved.forAll(((e23) => e23(s17.id)));
    }
    (e22.length || r18.length) && (this._graphicsWithoutSymbol.forEach(((e23) => r18.push(e23))), this._graphicsWithoutSymbol.clear(), this.add(r18)), this._cleanupSymbols(), this._labeler?.setDirty(), this._deconflictor?.setDirty();
  }
  _applyUniqueValueRendererDiff(e22, t14, r18) {
    const s17 = e22.diff.defaultSymbol, a15 = e22.diff.uniqueValueInfos;
    if (s17 || a15) {
      const n11 = a15?.changed, o14 = a15?.unchanged;
      if (n11 && o14 && n11.some(((e23) => o14.some(((t15) => t15.oldValue.symbol?.id === e23.oldValue.symbol?.id))))) return false;
      const l18 = a15 ? a15.added.map(((e23) => e23.symbol)).filter(L) : [], h13 = a15 ? a15.removed.map(((e23) => e23.symbol)).filter(L) : [];
      if (n11) for (let e23 = 0; e23 < n11.length; e23++) l18.push(n11[e23].newValue.symbol), h13.push(n11[e23].oldValue.symbol);
      return s17 ? (r18.defaultSymbol && h13.push(r18.defaultSymbol), t14.defaultSymbol && l18.push(t14.defaultSymbol)) : r18.defaultSymbol && l18.length && h13.push(t14.defaultSymbol), this._applySymbolSetDiff(l18, h13, t14), delete e22.diff.defaultSymbol, delete e22.diff.uniqueValueInfos, true;
    }
    return false;
  }
  _calculateUnchangedSymbolMapping(e22, t14, i12) {
    if ("unique-value" !== t14?.type || "unique-value" !== i12?.type || null != e22 && "partial" !== e22.type) return [];
    const r18 = (e23) => null != e23 ? e23.id : null, s17 = e22 && e22.diff, a15 = s17?.defaultSymbol, n11 = s17 && s17.uniqueValueInfos;
    let o14;
    if (n11) o14 = n11.unchanged.map(((e23) => ({ oldId: r18(e23.oldValue.symbol), newId: r18(e23.newValue.symbol) })));
    else {
      o14 = [];
      for (const e23 of i12.uniqueValueInfos ?? []) {
        const i13 = r18(e23.symbol), s18 = t14.uniqueValueInfos?.find(((t15) => t15.value === e23.value));
        s18 && i13 !== r18(s18.symbol) && o14.push({ oldId: i13, newId: r18(s18.symbol) });
      }
    }
    return !a15 && i12.defaultSymbol && o14.push({ oldId: r18(i12.defaultSymbol), newId: r18(t14.defaultSymbol) }), o14;
  }
  _updateSymbolMapping(e22, t14) {
    const i12 = null != t14 && t14 ? "string" == typeof t14 ? t14 : t14.id : null;
    if (null == e22 || e22 === i12) return;
    const r18 = this._graphicsBySymbol.get(e22);
    this._graphicsBySymbol.delete(e22), void 0 !== r18 && this._graphicsBySymbol.set(i12, r18);
    const s17 = this._symbols.get(e22);
    if (void 0 !== s17 && (this._symbols.delete(e22), this._symbols.set(i12, s17), this._symbolMaterials = null, null != s17)) {
      const e23 = "string" == typeof t14 ? null : t14;
      null != e23 ? s17.symbol = e23 : s17.symbol.id = i12;
    }
  }
  _updateUnchangedSymbolMappings(e22, t14, i12) {
    const r18 = this._calculateUnchangedSymbolMapping(e22, t14, i12);
    for (const { oldId: s17, newId: a15 } of r18) this._updateSymbolMapping(s17, a15);
  }
  _applyRendererDiff(e22, t14, i12) {
    if (this._diffHasSymbolChange(e22)) return false;
    if (t14 instanceof $ && i12 instanceof $ && this._applyUniqueValueRendererDiff(e22, t14, i12) && 0 === Object.keys(e22.diff).length) return true;
    for (const r18 of this._graphicsBySymbol.keys()) {
      const i13 = this._symbols.get(r18);
      if (null != i13) switch (i13.applyRendererDiff(e22, t14)) {
        case e14.RecreateSymbol:
          this._recreateSymbol(r18);
          break;
        case e14.RecreateGraphics:
          this._recreateGraphicsForSymbol(r18);
        case e14.FastUpdate:
      }
    }
    return true;
  }
  opacityChange() {
    this._updateStageLayerVisibility(), this.forEachGraphics3DSymbol(((e22, t14) => e22.globalPropertyChanged("opacity", t14)));
  }
  _slicePlaneEnabledChange(e22) {
    e22 !== this.symbolCreationContext.slicePlaneEnabled && (this.symbolCreationContext.slicePlaneEnabled = e22, this.stageLayer.sliceable = e22, this.forEachGraphics3DSymbol(((e23, t14) => e23.globalPropertyChanged("slicePlaneEnabled", t14))), this._deconflictor?.slicePlaneEnabledChange(), this._labeler?.slicePlaneEnabledChange());
  }
  _physicalBasedRenderingChange(e22) {
    this.symbolCreationContext.physicalBasedRenderingEnabled = e22, this.forEachGraphics3DSymbol(((e23, t14, i12) => {
      e23.globalPropertyChanged("physicalBasedRenderingEnabled", t14) || this._recreateSymbol(i12);
    }));
  }
  _skipHighSymbolLoDsChange(e22) {
    this.symbolCreationContext.skipHighSymbolLods = e22, this.forEachGraphics3DSymbol(((e23, t14, i12) => {
      e23.globalPropertyChanged("skipHighSymbolLods", t14) || this._recreateSymbol(i12);
    }));
  }
  _pixelRatioChange() {
    this.forEachGraphics3DSymbol(((e22, t14, i12) => {
      e22.globalPropertyChanged("pixelRatio", t14) || this._recreateSymbol(i12);
    }));
  }
  _signalUpdatingDuringAsyncLoadedGraphicsChange() {
    this._updatingPendingLoadedGraphicsChange && this._updatingPendingLoadedGraphicsChange.remove(), this._updatingPendingLoadedGraphicsChange = A((() => {
      this._updatingPendingLoadedGraphicsChange = null;
    }));
  }
  setClippingExtent(e22, t14) {
    const i12 = this.symbolCreationContext.clippingExtent, r18 = u2();
    return u16(e22, r18, t14) ? this.symbolCreationContext.clippingExtent = B(u4(), r18) : this.symbolCreationContext.clippingExtent = null, !H(this.symbolCreationContext.clippingExtent, i12);
  }
  modifyGraphics3DGraphicVisibilities(e22) {
    if (this.destroyed) return;
    let t14 = false;
    this.graphics3DGraphics.forEach(((i12) => {
      e22(i12) && (t14 = true);
    })), t14 && (this._labeler?.setDirty(), this._deconflictor?.setDirty());
  }
  forEachGraphics3DSymbol(e22, t14) {
    for (const [i12, r18] of this._symbols) {
      if (null == r18) return;
      e22(r18, this._graphicsBySymbol.get(i12) || $e, i12);
    }
    if (!t14?.excludeUnused) for (const i12 of this._unusedSymbolsCache) e22(i12, void 0, i12.symbol.id);
  }
  updateGraphicsVisibilities() {
    null != this._filterVisibility && this._filterVisibility.reapply(), this.modifyGraphics3DGraphicVisibilities(((e22) => {
      const t14 = this._updateUserVisibility(e22), i12 = !!this._scaleVisibility?.updateVisibility(e22);
      return t14 || i12;
    }));
  }
  _hideAllGraphics() {
    this.modifyGraphics3DGraphicVisibilities(((e22) => e22.setVisibilityFlag(A5.GRAPHIC, L5.USER, false)));
  }
  _validateRenderer(e22) {
    const t14 = () => `'${this.layer.title ? `${this.layer.title}, ` : ""}id:${this.layer.id}'`, i12 = t8(e22, { geometryType: this.layer?.geometryType, logWarning: (e23, i13) => i.getLogger(this).warn(e23, `Symbology conversion for layer ${t14()}: ${i13}`) });
    if (i12) {
      const e23 = `Renderer for layer ${t14} is not supported in a SceneView`;
      i.getLogger(this).warn(e23, i12.message);
    }
  }
  _cleanupSymbols() {
    if (this._graphicsWaitingForSymbol.size > 0 || this._suspendSymbolCleanup) return;
    let e22 = false;
    this._symbols.forEach(((t14, i12) => {
      if (null == t14 || t14.referenced > 0) return;
      const r18 = this._graphicsBySymbol.get(i12);
      r18 && 0 !== r18.size || (this._graphicsBySymbol.delete(i12), this._symbols.delete(i12), this._symbolMaterials = null, this._unusedSymbolsCache.put(i12, t14, t), e22 = true);
    })), e22 && (this._recomputeExtentPadding(), this.notifyChange("averageSymbolComplexity"));
  }
  get test() {
  }
  get performanceInfo() {
    return new s13(this.graphics3DGraphics.size, Array.from(this.graphics3DGraphics.values()).reduce(((e22, t14) => e22 + (t14.isVisible() ? 1 : 0)), 0), this._graphicsWithoutSymbol.size, this._pendingUpdates.size);
  }
}, ke = _a, _a.tmpVec = n2(), _a);
var Ne;
r([m({ readOnly: true })], He.prototype, "computedExtent", void 0), r([m()], He.prototype, "currentRenderer", void 0), r([m()], He.prototype, "rendererHasGeometryOperations", void 0), r([m()], He.prototype, "_frameTaskHandle", void 0), r([m()], He.prototype, "_dataUpdateQueue", void 0), r([m()], He.prototype, "_updateQueue", void 0), r([m({ readOnly: true })], He.prototype, "_viewSpatialReference", null), r([m()], He.prototype, "_rendererChangeAbortController", void 0), r([m()], He.prototype, "_elevationInfoChangeAbortController", void 0), r([m()], He.prototype, "_initializeAbortController", void 0), r([m()], He.prototype, "_elevationAlignment", void 0), r([m()], He.prototype, "_scaleVisibility", void 0), r([m()], He.prototype, "_filterVisibility", void 0), r([m()], He.prototype, "_initializePromise", void 0), r([m()], He.prototype, "_spatialIndex", void 0), r([m({ readOnly: true })], He.prototype, "extentPadding", void 0), r([m()], He.prototype, "_updatingPendingLoadedGraphicsChange", void 0), r([m()], He.prototype, "_featureStore", void 0), r([m()], He.prototype, "_objectStates", void 0), r([m()], He.prototype, "_loadingSymbols", void 0), r([m({ constructOnly: true })], He.prototype, "compressionTracker", void 0), r([m()], He.prototype, "preferredUpdatePolicy", void 0), r([m()], He.prototype, "_forcedUpdatePolicy", void 0), r([m({ readOnly: true })], He.prototype, "effectiveUpdatePolicy", null), r([m({ constructOnly: true })], He.prototype, "elevationFeatureExpressionEnabled", void 0), r([m({ constructOnly: true })], He.prototype, "owner", void 0), r([m({ constructOnly: true })], He.prototype, "layer", void 0), r([m({ constructOnly: true })], He.prototype, "graphicSymbolSupported", void 0), r([m({ constructOnly: true })], He.prototype, "getRenderingInfoWithoutRenderer", void 0), r([m({ constructOnly: true })], He.prototype, "componentFactories", void 0), r([m({ constructOnly: true })], He.prototype, "setUidToIdOnAdd", void 0), r([m()], He.prototype, "featureStore", null), r([m()], He.prototype, "initializePromise", null), r([m()], He.prototype, "scaleVisibility", null), r([m()], He.prototype, "elevationAlignment", null), r([m()], He.prototype, "objectStates", null), r([m()], He.prototype, "filterVisibility", null), r([m({ readOnly: true })], He.prototype, "updating", null), r([m({ readOnly: true })], He.prototype, "dataUpdating", null), r([m({ readOnly: true })], He.prototype, "running", null), r([m({ readOnly: true })], He.prototype, "suspendedOrOutsideOfView", null), r([m({ readOnly: true, dependsOn: [] })], He.prototype, "updatingRemaining", null), r([m({ readOnly: true })], He.prototype, "displayFeatureLimit", null), r([m({ readOnly: true, dependsOn: [] })], He.prototype, "averageSymbolComplexity", null), r([m({ constructOnly: true })], He.prototype, "hasZ", void 0), r([m({ constructOnly: true })], He.prototype, "hasM", void 0), r([m()], He.prototype, "_objectIdField", null), He = ke = r([a("esri.views.3d.layers.graphics.Graphics3DCore")], He), (function(e22) {
  e22[e22.NEW = 0] = "NEW", e22[e22.LOADING = 1] = "LOADING", e22[e22.READY = 2] = "READY", e22[e22.REJECTED = 3] = "REJECTED";
})(Ne || (Ne = {}));
var Be = class {
  constructor() {
    this.add = null, this.renderingInfo = null, this.state = Ne.NEW, this.abortController = null, this.remove = null;
  }
  clear() {
    this.add = null, this.renderingInfo = null, this.state = Ne.NEW, this.abortController = null, this.remove = null;
  }
};
var qe = 10;
var Ye = n2();
var Qe = n2();
var $e = /* @__PURE__ */ new Map();

// node_modules/@arcgis/core/views/3d/layers/graphics/ExtentSet.js
var h8 = 0.05;
var a13 = class {
  constructor() {
    this._extents = new r4({ allocator: (t14) => t14 || u2() }), this._tmpExtent = u2(), this._dirty = false;
  }
  get empty() {
    return 0 === this._extents.length;
  }
  get size() {
    return this._extents.length;
  }
  clear() {
    this._extents.clear();
  }
  add(t14) {
    this._contains(t14) || (this._removeContained(t14), a4(this._extents.pushNew(), t14), this._dirty = true);
  }
  pop() {
    return this._dirty && this._mergeTight(), this._extents.pop();
  }
  merge(t14) {
    return this._mergeTight(t14), t14.hasProgressed;
  }
  _mergeTight(t14 = C) {
    const e22 = this._extents, o14 = /* @__PURE__ */ new Set();
    let a15 = 0;
    for (; a15 !== e22.length; ) {
      e22.sort(((t15, e23) => t15[0] - e23[0])), a15 = e22.length, o14.clear();
      for (let i12 = 0; i12 < e22.length; ++i12) {
        if (t14.done) return;
        const a16 = e22.at(i12);
        if (a16) {
          for (let t15 = i12 + 1; t15 < e22.length; ++t15) {
            const r18 = e22.at(t15);
            if (null == r18 || r18[0] >= a16[2]) break;
            o14.add(r18);
          }
          o14.forEach(((i13) => {
            if (a16 === i13) return;
            if (i13[2] <= a16[0]) return void o14.delete(i13);
            const l18 = l3(a16), _5 = l3(i13), c10 = this._tmpExtent;
            f4(a16, i13, c10);
            const d15 = l18 + _5;
            (l3(c10) - d15) / d15 < h8 && (a4(a16, c10), o14.delete(i13), e22.remove(i13), t14.madeProgress());
          })), o14.add(a16);
        }
      }
    }
    this._dirty = false;
  }
  _contains(t14) {
    return this._extents.some(((e22) => d2(e22, t14)));
  }
  _removeContained(t14) {
    this._extents.filterInPlace(((e22) => !d2(t14, e22)));
  }
  get test() {
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DElevationAlignment.js
var p11 = class extends b2 {
  constructor(t14) {
    super(t14), this._dirtyExtents = new a13(), this._globalDirty = false, this._averageExtentUpdateSize = 0, this._dirtyGraphicsSet = /* @__PURE__ */ new Set(), this._updateElevation = false, this.graphicsCoreOwner = null, this.graphicsCore = null, this.events = new o();
  }
  initialize() {
    const t14 = this.elevationProvider, e22 = this.graphicsCoreOwner.view.resourceController.scheduler;
    this._task = e22.registerTask(d14(this.graphicsCore.layer.elevationInfo?.mode), this), this.addHandles([t14.on("elevation-change", ((t15) => this._elevationChanged(t15))), l2((() => this.graphicsCoreOwner.suspended), (() => this._suspendedChange())), this._task, l2((() => d14(this.graphicsCore.layer.elevationInfo?.mode)), ((t15) => this._task.priority = t15))]);
  }
  destroy() {
    this._dirtyGraphicsSet.clear(), this.graphicsCoreOwner = null, this.graphicsCore = null, this.queryGraphicUIDsInExtent = null, this.elevationProvider = null;
  }
  clear() {
    this._dirtyGraphicsSet.clear(), this.notifyChange("updating");
  }
  _suspendedChange() {
    true === this.graphicsCoreOwner.suspended ? this._updateElevation = false : false === this.graphicsCoreOwner.suspended && this._updateElevation && (this._globalDirty = true, this.notifyChange("updating"));
  }
  elevationInfoChange() {
    this._globalDirty = true, this.notifyChange("updating");
  }
  get updating() {
    return this.running;
  }
  get running() {
    return this._dirtyGraphicsSet.size > 0 || this._dirtyExtents && !this._dirtyExtents.empty || this._globalDirty;
  }
  get updatingRemaining() {
    return this._dirtyGraphicsSet.size + this._dirtyExtents.size * this._averageExtentUpdateSize;
  }
  runTask(t14) {
    for (this._globalDirty && (this._markAllGraphicsElevationDirty(), this._globalDirty = false, t14.madeProgress()), t14.run((() => this._dirtyExtents.merge(t14))); this.running && !t14.done; ) this._updateDirtyGraphics(t14), this._updateDirtyExtents(t14);
    this.notifyChange("updating");
  }
  _updateDirtyGraphics(t14) {
    const e22 = this.graphicsCoreOwner.view.renderCoordsHelper, i12 = this.graphicsCore.effectiveUpdatePolicy === C3.ASYNC;
    for (const r18 of this._dirtyGraphicsSet.keys()) {
      const s17 = this.graphicsCore.getGraphics3DGraphicById(r18);
      if (this._dirtyGraphicsSet.delete(r18), null != s17 && (s17.alignWithElevation(this.elevationProvider, e22, i12), this.graphicsCore.deconflictor?.setDirty(), t14.madeProgress()), t14.done) return;
    }
  }
  _updateDirtyExtents(t14) {
    for (; !this._dirtyExtents.empty && !t14.done; ) {
      const e22 = this._dirtyExtents.pop(), i12 = this.elevationProvider.spatialReference;
      this.events.emit("invalidate-elevation", { extent: e22, spatialReference: i12 });
      const r18 = this._dirtyGraphicsSet.size;
      this.queryGraphicUIDsInExtent(e22, i12, ((t15) => {
        const e23 = this.graphicsCore.getGraphics3DGraphicById(t15);
        null != e23 && e23.needsElevationUpdates() && this._dirtyGraphicsSet.add(t15);
      })), this._averageExtentUpdateSize = 0.1 * (this._dirtyGraphicsSet.size - r18) + 0.9 * this._averageExtentUpdateSize, t14.madeProgress();
    }
  }
  _markAllGraphicsElevationDirty() {
    this._dirtyExtents.clear(), this._dirtyGraphicsSet.clear(), this.graphicsCore.graphics3DGraphics.forEach(((t14, e22) => this._dirtyGraphicsSet.add(e22)));
  }
  _elevationChanged(t14) {
    if ("scene" === t14.context && (!this.graphicsCore.layer.elevationInfo || "relative-to-scene" !== this.graphicsCore.layer.elevationInfo.mode)) return;
    const e22 = t14.extent;
    if (this.graphicsCoreOwner.suspended) {
      if (!this._updateElevation) {
        const t15 = this.graphicsCore.computedExtent;
        t15 && e22[2] > t15.xmin && e22[0] < t15.xmax && e22[3] > t15.ymin && e22[1] < t15.ymax && (this._updateElevation = true);
      }
      this.events.emit("invalidate-elevation", t14);
    } else e22[0] === -1 / 0 ? this._globalDirty = true : this._dirtyExtents.add(e22), this.notifyChange("updating");
  }
};
function d14(t14) {
  return null == t14 ? g.ELEVATION_ALIGNMENT : "relative-to-scene" === t14 ? g.ELEVATION_ALIGNMENT_SCENE : g.ELEVATION_ALIGNMENT;
}
r([m()], p11.prototype, "graphicsCoreOwner", void 0), r([m()], p11.prototype, "graphicsCore", void 0), r([m()], p11.prototype, "queryGraphicUIDsInExtent", void 0), r([m()], p11.prototype, "elevationProvider", void 0), r([m({ readOnly: true })], p11.prototype, "updating", null), r([m({ readOnly: true })], p11.prototype, "updatingRemaining", null), p11 = r([a("esri.views.3d.layers.graphics.Graphics3DElevationAlignment")], p11);

// node_modules/@arcgis/core/views/3d/support/intersectionUtils.js
function g9(r18, n11, t14, i12) {
  return h9(r18, n11, t14, v5(i12, n11, t14, true));
}
var b9 = { dir: n2(), len: 0, clip: n4() };
function v5(r18, n11, i12, f7) {
  const l18 = b9;
  return r18 ? (i12 && f7 && (l18.len = p2(n11, i12)), s7(l18.dir, r18)) : f7 ? (l18.len = p2(n11, i12), c2(l18.dir, i12, n11), g2(l18.dir, l18.dir, 1 / l18.len)) : (c2(l18.dir, i12, n11), A2(l18.dir, l18.dir)), l18;
}
function x3(r18, t14, i12) {
  const e22 = P2(O2(r18), i12.dir), c10 = -V3(r18, t14);
  if (c10 < 0 && e22 >= 0) return false;
  if (e22 > -1e-6 && e22 < 1e-6) return c10 > 0;
  if ((c10 < 0 || e22 < 0) && !(c10 < 0 && e22 < 0)) return true;
  const o14 = c10 / e22;
  return e22 > 0 ? o14 < i12.clip[1] && (i12.clip[1] = o14) : o14 > i12.clip[0] && (i12.clip[0] = o14), i12.clip[0] <= i12.clip[1];
}
function h9(r18, n11, t14, i12) {
  i12.clip[0] = 0, i12.clip[1] = t14 ? i12.len : Number.MAX_VALUE;
  for (let e22 = 0; e22 < r18.length; e22++) if (!x3(r18[e22], n11, i12)) return false;
  return true;
}

// node_modules/@arcgis/core/views/3d/support/FrustumExtentIntersection.js
var M4 = 0.5 * Math.PI;
var F2 = M4 / Math.PI * 180;
var N = class {
  constructor(t14) {
    this._extent = new Array(4), this._planes = new Array(6), this._maxSpan = 0, this._center = { origin: n2(), direction: n2() }, this._renderCoordsHelper = t14.renderCoordsHelper;
    for (let e22 = 0; e22 < 4; e22++) this._extent[e22] = { origin: n2(), direction: n2(), cap: { next: null, direction: n2() } }, this._planes[e22] = M3();
    this._planes[j2.NEAR] = M3(), this._planes[j2.FAR] = M3(), this._planesWithoutFar = this._planes.slice(0, 5);
  }
  update(t14, e22, i12, r18 = true) {
    const a15 = this._extent;
    this._toRenderBoundingExtent(t14, e22, i12), u5(this._center.origin, a15[0].origin, a15[2].origin), g2(this._center.origin, this._center.origin, 0.5), this._renderCoordsHelper.worldUpAtPosition(this._center.origin, this._center.direction), r18 || g2(this._center.direction, this._center.direction, -1);
    for (let n11 = 0; n11 < 4; n11++) {
      const t15 = a15[n11];
      this._renderCoordsHelper.worldUpAtPosition(t15.origin, t15.direction);
      const e23 = a15[3 === n11 ? 0 : n11 + 1];
      t15.cap.next = e23.origin, K(t15.cap.direction, t15.origin, e23.origin), P3(t15.direction, t15.cap.direction, t15.origin, this._planes[n11]), r18 || g2(t15.direction, t15.direction, -1);
    }
    P3(a15[0].cap.direction, a15[1].cap.direction, a15[0].origin, this._planes[j2.NEAR]), r18 ? L4(this._planes[j2.NEAR], this._planes[j2.FAR]) : (h4(this._planes[j2.FAR], this._planes[j2.NEAR]), L4(this._planes[j2.NEAR], this._planes[j2.NEAR])), this._maxSpan = Math.max(Math.abs(t14[0] - t14[2]), Math.abs(t14[1] - t14[3])), this._maxSpanSpatialReference = e22, this._minGlobalAltitude = 0.9 * s4(this._maxSpanSpatialReference).radius;
  }
  isVisibleInFrustum(t14, e22, i12 = false) {
    if (null == t14) return false;
    if (this._renderCoordsHelper.viewingMode === l8.Global) {
      const i13 = this._maxSpanSpatialReference.isGeographic ? F2 : M4 * e22;
      if (this._maxSpan > i13) return true;
      if (null != t14.altitude && t14.altitude >= this._minGlobalAltitude) return this._isVisibleInFrustumGlobal(t14);
    }
    if (0 === this._maxSpan) {
      const e23 = this._extent[0];
      return !(i12 || !t14.intersectsRay(k2(e23.origin, e23.direction)));
    }
    for (let n11 = 0; n11 < this._extent.length; n11++) {
      const e23 = this._extent[n11];
      if (!i12 && t14.intersectsRay(k2(e23.origin, e23.direction))) return true;
      if (t14.intersectsLineSegment(h5(e23.origin, e23.cap.next, k3), e23.cap.direction)) return true;
    }
    const r18 = i12 ? this._planes : this._planesWithoutFar;
    for (let n11 = 0; n11 < t14.lines.length; n11++) {
      const e23 = t14.lines[n11];
      if (g9(r18, e23.origin, e23.endpoint, e23.direction)) return true;
    }
    return false;
  }
  _toRenderBoundingExtentGlobal(t14, r18, n11) {
    const o14 = 5;
    p(t14, V4), V4[2] = n11, m2(r18, V4, v6, this._renderCoordsHelper.spatialReference), h2(I2, v6), q(L7);
    for (const { x0: i12, x1: s17, y0: c10, y1: l18 } of U3) for (let p12 = 0; p12 < o14; p12++) {
      const h13 = p12 / (o14 - 1);
      V4[0] = o2(t14[i12], t14[s17], h13), V4[1] = o2(t14[c10], t14[l18], h13), V4[2] = n11, n6(V4, r18, V4, this._renderCoordsHelper.spatialReference), E(V4, V4, I2), l4(L7, V4);
    }
    o5(this._extent[0].origin, L7[0], L7[1], L7[2]), o5(this._extent[1].origin, L7[3], L7[1], L7[2]), o5(this._extent[2].origin, L7[3], L7[4], L7[2]), o5(this._extent[3].origin, L7[0], L7[4], L7[2]);
    for (let e22 = 0; e22 < 4; ++e22) E(this._extent[e22].origin, this._extent[e22].origin, v6);
  }
  _toRenderBoundingExtentLocal(t14, e22, i12) {
    i8(t14, e22, P5, this._renderCoordsHelper.spatialReference), o5(this._extent[0].origin, P5[0], P5[1], i12), o5(this._extent[1].origin, P5[2], P5[1], i12), o5(this._extent[2].origin, P5[2], P5[3], i12), o5(this._extent[3].origin, P5[0], P5[3], i12);
  }
  _toRenderBoundingExtent(e22, i12, r18) {
    switch (this._renderCoordsHelper.viewingMode) {
      case l8.Global:
        this._toRenderBoundingExtentGlobal(e22, i12, r18);
        break;
      case l8.Local:
        this._toRenderBoundingExtentLocal(e22, i12, r18);
        break;
      default:
        n(this._renderCoordsHelper.viewingMode);
    }
  }
  _isVisibleInFrustumGlobal(t14) {
    if (V3(t14.planes[j2.NEAR], this._center.origin) < 0 && P2(this._center.direction, t14.direction) < 0) return true;
    for (let e22 = 0; e22 < 4; e22++) {
      const i12 = this._extent[e22];
      if (V3(t14.planes[j2.NEAR], i12.origin) < 0 && P2(i12.direction, t14.direction) < 0) return true;
    }
    return false;
  }
};
var U3 = [{ x0: 0, y0: 1, x1: 2, y1: 1 }, { x0: 0, y0: 3, x1: 2, y1: 3 }, { x0: 0, y0: 1, x1: 0, y1: 3 }, { x0: 2, y0: 1, x1: 2, y1: 3 }];
var V4 = n2();
var v6 = e8();
var I2 = e8();
var L7 = u4();
var P5 = u2();
var k3 = v2();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DFrustumVisibility.js
var h10 = 1.2;
var u17 = class extends b2 {
  constructor(e22) {
    super(e22), this.suspended = false, this._extent = null, this._extentIntersectionDirty = true, this._isVisibleBelowSurfaceInternal = false, this.graphicsCoreOwner = null, this.updating = true;
  }
  initialize() {
    const { graphicsCoreOwner: e22 } = this;
    this._extentIntersection = new N({ renderCoordsHelper: e22.view.renderCoordsHelper });
    const t14 = e22.view, n11 = t14.basemapTerrain, o14 = t14.resourceController.scheduler;
    this.addHandles([t14.on("resize", (() => this._viewChange())), l2((() => t14.state.camera), (() => this._viewChange()), U), o14.registerTask(g.FRUSTUM_VISIBILITY, this), l2((() => n11.visibleElevationBounds), (() => this._elevationBoundsChange()))]), "local" === t14.viewingMode ? this._isVisibleBelowSurface = true : this.addHandles([l2((() => [n11.baseOpacity, n11.wireframe, t14.map?.ground?.navigationConstraint?.type]), (() => this._updateIsVisibleBelowSurface()), h)]);
  }
  destroy() {
    this._set("graphicsCoreOwner", null), this._extent = null, this._extentIntersection = null;
  }
  _setDirty() {
    this.updating || this._set("updating", true);
  }
  setExtent(e22) {
    this._extent = e22, this._extentIntersectionDirty = true, this._setDirty();
  }
  _viewChange() {
    this._setDirty();
  }
  _elevationBoundsChange() {
    this._setDirty(), this._extentIntersectionDirty = true;
  }
  set _isVisibleBelowSurface(e22) {
    this._isVisibleBelowSurfaceInternal = e22, this._setDirty(), this._extentIntersectionDirty = true;
  }
  _updateIsVisibleBelowSurface() {
    const e22 = this.graphicsCoreOwner.view, t14 = e22.basemapTerrain, s17 = "local" === e22.viewingMode, i12 = "none" === e22.map.ground?.navigationConstraint?.type;
    this._isVisibleBelowSurface = s17 || !t14.opaque || i12;
  }
  _updateExtentIntersection() {
    if (!this._extentIntersectionDirty) return;
    this._extentIntersectionDirty = false;
    const e22 = this.graphicsCoreOwner.view;
    let t14;
    if (this._isVisibleBelowSurfaceInternal) t14 = -0.3 * s4(e22.spatialReference).radius;
    else {
      const { min: s17, max: i12 } = e22.basemapTerrain.visibleElevationBounds;
      t14 = s17 - Math.max(1, (i12 - s17) * (h10 - 1));
    }
    this._extentIntersection.update(this._extent, e22.spatialReference, t14);
  }
  get running() {
    return this.updating;
  }
  runTask(e22) {
    if (this._set("updating", false), !this._extent) return this._set("suspended", false), o4;
    this._updateExtentIntersection();
    const t14 = this.graphicsCoreOwner.view.frustum, s17 = s4(this.graphicsCoreOwner.view.spatialReference).radius;
    this._set("suspended", !this._extentIntersection.isVisibleInFrustum(t14, s17)), e22.madeProgress();
  }
};
r([m({ readOnly: true })], u17.prototype, "suspended", void 0), r([m({ constructOnly: true })], u17.prototype, "graphicsCoreOwner", void 0), r([m({ readOnly: true })], u17.prototype, "updating", void 0), u17 = r([a("esri.views.3d.layers.graphics.Graphics3DFrustumVisibility")], u17);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Object3DStateSet.js
var t11 = class {
};
var s15 = class extends t11 {
  constructor(e22, t14) {
    super(), this.objectStateId = e22, this.object = t14;
  }
  remove() {
    this.object.removeStateID(this.objectStateId);
  }
};
var o13 = class extends t11 {
  constructor(e22, t14, s17) {
    super(), this.objectStateId = e22, this.object = t14, this.owner = s17;
  }
  remove() {
    this.owner.removeRenderGeometryObjectState(this.object, this.objectStateId);
  }
};
var c7 = class extends t11 {
  constructor(e22, t14) {
    super(), this.objectStateId = e22, this._removeCallback = t14, this.object = null;
  }
  remove() {
    this._removeCallback(this.objectStateId);
  }
};
var r16 = class {
  constructor() {
    this._items = [];
  }
  addObject(e22, t14) {
    this._items.push(new s15(t14, e22));
  }
  addRenderGeometry(e22, t14, s17) {
    this._items.push(new o13(t14, e22, s17));
  }
  addExternal(e22, t14) {
    this._items.push(new c7(t14, e22));
  }
  remove(e22) {
    this._remove(((t14) => t14.objectStateId === e22));
  }
  removeByObject(e22) {
    this._remove(((t14) => t14.object === e22));
  }
  removeAll() {
    this._items.forEach(((e22) => e22.remove())), this._items = [];
  }
  _remove(e22) {
    const { _items: t14 } = this;
    for (let s17 = t14.length - 1; s17 >= 0; --s17) {
      const o14 = t14[s17];
      e22(o14) && (o14.remove(), t14.splice(s17, 1));
    }
  }
};
var i9 = class extends r16 {
  constructor() {
    super(...arguments), this.stateType = t3.MaskOccludee;
  }
};
var h11 = class extends r16 {
  constructor(t14) {
    super(), this.highlightName = t14, this.stateType = t3.Highlight;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObjectStateSet.js
var i10 = class {
  constructor(t14) {
    this.objectIdField = t14, this.ids = /* @__PURE__ */ new Set(), this.paused = false;
  }
  hasGraphic(t14) {
    const e22 = this.objectIdField ? t14.graphic.attributes[this.objectIdField] : t14.graphic.uid;
    return this.ids.has(e22);
  }
};
var c8 = class extends i10 {
  constructor(s17) {
    super(s17), this.stateType = t3.MaskOccludee, this.objectStateSet = new i9();
  }
};
var h12 = class extends i10 {
  constructor(e22, i12) {
    super(i12), this.highlightName = e22, this.stateType = t3.Highlight, this.objectStateSet = new h11(e22);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObjectStates.js
var a14 = class {
  constructor(t14) {
    this._graphicsCore = t14, this._stateSets = new Array();
  }
  destroy() {
    this.reset(), this._stateSets = null;
  }
  reset() {
    this._stateSets && (this._stateSets.forEach(((t14) => t14.objectStateSet.removeAll())), this._stateSets.length = 0);
  }
  acquireOccludeeSet(s17) {
    const a15 = new c8(s17);
    this._stateSets.push(a15);
    const i12 = e((() => this.releaseSet(a15)));
    return { set: a15, handle: i12 };
  }
  acquireHighlightSet(e22, a15) {
    const i12 = new h12(e22, a15);
    this._stateSets.push(i12);
    const c10 = e((() => this.releaseSet(i12)));
    return { set: i12, handle: c10 };
  }
  releaseSet(t14) {
    t14.objectStateSet.removeAll();
    const e22 = this._stateSets ? this._stateSets.indexOf(t14) : -1;
    -1 !== e22 && this._stateSets.splice(e22, 1);
  }
  setUid(t14, e22) {
    t14.ids.add(e22);
    const s17 = this._graphicsCore.graphics3DGraphics.get(e22);
    s17 && s17.addObjectStateSet(t14.objectStateSet);
  }
  setUids(t14, e22) {
    e22.forEach(((e23) => this.setUid(t14, e23)));
  }
  setObjectIds(t14, e22) {
    e22.forEach(((e23) => t14.ids.add(e23))), this._initializeSet(t14);
  }
  addGraphic(t14) {
    this._stateSets.forEach(((e22) => {
      !e22.paused && e22.hasGraphic(t14) && t14.addObjectStateSet(e22.objectStateSet);
    }));
  }
  removeGraphic(t14) {
    this._stateSets.forEach(((e22) => {
      e22.hasGraphic(t14) && t14.removeObjectState(e22.objectStateSet);
    }));
  }
  allGraphicsDeleted() {
    this._stateSets && this._stateSets.forEach(((t14) => t14.objectStateSet.removeAll()));
  }
  _initializeSet(t14) {
    const e22 = this._graphicsCore.graphics3DGraphics;
    t14.objectIdField ? e22.forEach(((e23) => {
      e23 && t14.hasGraphic(e23) && e23.addObjectStateSet(t14.objectStateSet);
    })) : t14.ids.forEach(((s17) => {
      const a15 = e22.get(s17);
      a15 && a15.addObjectStateSet(t14.objectStateSet);
    }));
  }
  get test() {
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DScaleVisibility.js
var u18 = class extends b2 {
  constructor(e22) {
    super(e22), this._scaleRangeActive = false, this._layerScaleRangeVisibilityQuery = false, this._extent = null, this._updatingHandles = new h3(), this.graphicsCoreOwner = null, this.layer = null, this.queryGraphicUIDsInExtent = null, this.graphicsCore = null, this.basemapTerrain = null, this.layerScaleEnabled = true, this.suspended = false, this._dirty = true;
  }
  initialize() {
    this.updateScaleRangeActive();
    const e22 = this.graphicsCoreOwner.view.resourceController.scheduler;
    this.addHandles(e22.registerTask(g.SCALE_VISIBILITY, this)), this._updatingHandles.add((() => this.layer.effectiveScaleRange), (() => this.layerMinMaxScaleChangeHandler()));
  }
  destroy() {
    this._updatingHandles.destroy(), this.removeHandles(), this._dirty = false, this._extent = null, this.graphicsCoreOwner = null, this.layer = null, this.queryGraphicUIDsInExtent = null, this.graphicsCore = null, this.basemapTerrain = null;
  }
  get updating() {
    return this._dirty || this._updatingHandles.updating;
  }
  _setDirty() {
    this._dirty = true;
  }
  setExtent(e22) {
    const i12 = this.graphicsCoreOwner.view.spatialReference, t14 = this.graphicsCoreOwner.view.basemapTerrain.spatialReference;
    if (i12 === t14) this._extent = e22 ?? null;
    else {
      const r18 = u2();
      i8(e22, i12, r18, t14) ? this._extent = r18 : this._extent = null;
    }
    this._setDirty();
  }
  scaleRangeActive() {
    return this._scaleRangeActive;
  }
  updateScaleRangeActive() {
    const e22 = this.layer, i12 = e22.effectiveScaleRange;
    let t14 = this.layerScaleEnabled && null != i12 && g10(i12.minScale, i12.maxScale);
    e22.labelingInfo && !t14 && (t14 = e22.labelingInfo.some(((e23) => e23 && g10(e23.minScale ?? 0, e23.maxScale ?? 0))));
    const r18 = this._scaleRangeActive !== t14;
    return this._scaleRangeActive = t14, t14 && !this.hasHandles(y4) && this.basemapTerrain ? (this.addHandles(this.basemapTerrain.on("scale-change", ((e23) => this._scaleUpdateHandler(e23))), y4), this.layerScaleEnabled && this.addHandles(this.basemapTerrain.on("tiles-visibility-changed", (() => this._setDirty())), y4)) : !t14 && this.hasHandles(y4) && this.removeHandles(y4), r18;
  }
  get running() {
    return !(!this.graphicsCoreOwner.view.basemapTerrain || !this.updating);
  }
  runTask(e22) {
    const i12 = this.graphicsCoreOwner.view.basemapTerrain;
    if (this._extent && i12 && i12.ready && this._scaleRangeActive && this.layerScaleEnabled) {
      if (this._layerScaleRangeVisibilityQuery) return o4;
      {
        this._layerScaleRangeVisibilityQuery = true;
        const { minScale: e23, maxScale: t14 } = this.layer.effectiveScaleRange;
        i12.queryVisibleScaleRange(this._extent, e23, t14, ((e24) => this._finishUpdate(e24)));
      }
    } else this._finishUpdate(true);
    e22.madeProgress();
  }
  _finishUpdate(e22) {
    this._layerScaleRangeVisibilityQuery = false, this._set("suspended", !e22), this._dirty = false;
  }
  _visibleAtLayerScale(e22) {
    const i12 = this.layer.effectiveScaleRange;
    return !this.layerScaleEnabled || r9(e22, i12.minScale || 0, i12.maxScale || 0);
  }
  _visibleAtLabelScale(e22, i12) {
    return r9(e22, i12.minScale || 0, i12.maxScale || 0);
  }
  _graphicScale(e22) {
    let i12;
    if (null != e22.centroid ? i12 = e22.centroid : null != e22.graphic.geometry && "point" === e22.graphic.geometry.type && (i12 = e22.graphic.geometry), i12) {
      return this.graphicsCoreOwner.view.basemapTerrain ? this.graphicsCoreOwner.view.basemapTerrain.getScale(i12) : 1;
    }
    return null;
  }
  _graphicVisible(e22) {
    if (!this.layerScaleEnabled) return true;
    const i12 = this._graphicScale(e22);
    return this._visibleAtLayerScale(i12);
  }
  updateVisibility(e22) {
    if (!this._scaleRangeActive) return false;
    const i12 = this._graphicVisible(e22);
    return e22.setVisibilityFlag(A5.GRAPHIC, L5.SCALE_RANGE, i12);
  }
  updateGraphicLabelScaleVisibility(e22) {
    if (!this._scaleRangeActive) return false;
    if (!e22.labelLayers.length) return false;
    const i12 = this._graphicScale(e22), t14 = this._updateLabelScaleVisibility(e22, i12);
    return t14 && (this.graphicsCore.deconflictor?.setDirty(), this.graphicsCore.labeler?.setDirty()), t14;
  }
  _updateLabelScaleVisibility(e22, i12) {
    if (!e22.labelLayers.length) return false;
    const t14 = e22.labelLayers[0].labelClass;
    if (null != t14?.minScale && null != t14.maxScale) {
      const r18 = this._visibleAtLabelScale(i12, t14);
      if (e22.setVisibilityFlag(A5.LABEL, L5.SCALE_RANGE, r18)) return true;
    }
    return false;
  }
  _scaleUpdateHandler(e22) {
    if (this._setDirty(), !this.graphicsCore.visible) return;
    const i12 = e22.extent, r18 = e22.scale, s17 = this._visibleAtLayerScale(r18);
    let a15 = false;
    const n11 = this.graphicsCoreOwner.view.spatialReference, h13 = e22.spatialReference;
    if (null == h13) return void i.getLogger(this).error("scaleUpdate: Internal error, no SpatialReference given for tiles");
    const p12 = !h13.equals(n11);
    if (p12) {
      if (!i8(i12, h13, m8, n11)) return void i.getLogger(this).error("scaleUpdate: Internal error, cannot project AABR from " + h13 + " to wkid " + n11);
    }
    const d15 = p12 ? m8 : i12;
    this.queryGraphicUIDsInExtent(d15, n11, ((e23) => {
      const t14 = this.graphicsCore.getGraphics3DGraphicById(e23);
      if (null == t14) return;
      const l18 = t14.centroid;
      null != l18 && (i12[0] > l18.x || i12[1] > l18.y || i12[2] < l18.x || i12[3] < l18.y) || (t14.setVisibilityFlag(A5.GRAPHIC, L5.SCALE_RANGE, s17) && (a15 = true), this._updateLabelScaleVisibility(t14, r18) && (a15 = true));
    })), a15 && (this.graphicsCore.deconflictor?.setDirty(), this.graphicsCore.labeler?.setDirty());
  }
  layerMinMaxScaleChangeHandler() {
    this.updateScaleRangeActive() && !this._scaleRangeActive ? this.graphicsCore.modifyGraphics3DGraphicVisibilities(((e22) => e22.setVisibilityFlag(A5.GRAPHIC, L5.SCALE_RANGE, true))) : this._scaleRangeActive && this.graphicsCore.updateGraphicsVisibilities(), this._setDirty();
  }
};
function g10(e22, i12) {
  return e22 > 0 || i12 > 0;
}
r([m()], u18.prototype, "graphicsCoreOwner", void 0), r([m()], u18.prototype, "layer", void 0), r([m()], u18.prototype, "queryGraphicUIDsInExtent", void 0), r([m()], u18.prototype, "graphicsCore", void 0), r([m()], u18.prototype, "basemapTerrain", void 0), r([m({ constructOnly: true })], u18.prototype, "layerScaleEnabled", void 0), r([m({ readOnly: true })], u18.prototype, "suspended", void 0), r([m({ readOnly: true })], u18.prototype, "updating", null), r([m()], u18.prototype, "_dirty", void 0), u18 = r([a("esri.views.3d.layers.graphics.Graphics3DScaleVisibility")], u18);
var y4 = "terrain-events";
var m8 = u2();

// node_modules/@arcgis/core/views/3d/layers/support/highlightUtils.js
function e21(o14) {
  return V.isCollection(o14) ? o14.toArray() : Array.isArray(o14) ? o14 : i11(o14) || i2(o14) || c9(o14) ? [o14] : n10;
}
function i11(r18) {
  return "number" == typeof r18 || "string" == typeof r18;
}
var n10 = [];
var s16 = e();
function c9(r18) {
  return "esri.views.3d.layers.i3s.PointCloudGraphic" === r18.declaredClass;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/GraphicsProcessor.js
var x4 = class extends b2 {
  constructor(i12) {
    super(i12), this.drapeSourcePriorityOffset = 0, this.type = "graphics-3d", this.graphicsCore = null, this.drapeSourceType = e12.Features, this.scaleVisibilityEnabled = false, this.frustumVisibilityEnabled = false, this._suspendResumeExtent = null, this._updatingHandles = new h3();
  }
  initialize() {
    const { layer: i12 } = this, t14 = "effectiveScaleRange" in i12 ? i12 : null, e22 = !o7() && this.scaleVisibilityEnabled && null != t14, r18 = new He({ owner: this, layer: this.owner.layer, preferredUpdatePolicy: C3.SYNC, graphicSymbolSupported: true, componentFactories: { elevationAlignment: (i13, t15) => new p11({ graphicsCoreOwner: this, graphicsCore: i13, queryGraphicUIDsInExtent: t15, elevationProvider: this.view.elevationProvider }), scaleVisibility: e22 ? (i13, e23) => new u18({ graphicsCoreOwner: this, layer: t14, queryGraphicUIDsInExtent: e23, graphicsCore: i13, basemapTerrain: this.owner.view.basemapTerrain }) : null, objectStates: (i13) => new a14(i13) } });
    if (this._set("graphicsCore", r18), this.frustumVisibilityEnabled && this._set("frustumVisibility", new u17({ graphicsCoreOwner: this })), "fullOpacity" in this.owner) {
      const i13 = this.owner;
      this._updatingHandles.add((() => i13.fullOpacity), (() => this.graphicsCore.opacityChange()));
    }
    if ("elevationInfo" in i12) {
      const t15 = i12;
      this._updatingHandles.add((() => t15.elevationInfo), ((i13, t16) => {
        y(i13, t16) && this._updatingHandles.addPromise(this.graphicsCore.elevationInfoChange());
      }));
    }
    this._set("initializePromise", this._initializeAsync()), this._updatingHandles.addPromise(this.initializePromise);
  }
  async _initializeAsync() {
    try {
      await this.graphicsCore.initializePromise;
    } catch (i12) {
      if (b(i12)) return;
      throw i12;
    }
    this.destroyed || (this.addHandles(l2((() => this.view.clippingArea), (() => this._updateClippingExtent()), U)), this._updateClippingExtent(), this._setupSuspendResumeExtent(), this.graphicsCore.startCreateGraphics());
  }
  destroy() {
    this._updatingHandles.destroy(), this._set("frustumVisibility", u(this.frustumVisibility)), this._set("graphicsCore", u(this.graphicsCore));
  }
  get layer() {
    return this.owner.layer;
  }
  get layerViewUid() {
    return this.owner.uid;
  }
  get view() {
    return this.owner.view;
  }
  get scaleVisibility() {
    return this.graphicsCore?.scaleVisibility;
  }
  get elevationAlignment() {
    return this.graphicsCore?.elevationAlignment;
  }
  get scaleVisibilitySuspended() {
    return !(null == this.scaleVisibility || !this.scaleVisibility.suspended);
  }
  get frustumVisibilitySuspended() {
    return null != this.frustumVisibility && this.frustumVisibility.suspended;
  }
  get suspended() {
    return this.owner.suspended ?? false;
  }
  get updating() {
    return !!(this.graphicsCore?.updating || null != this.scaleVisibility && this.scaleVisibility.updating || null != this.frustumVisibility && this.frustumVisibility.updating || this._updatingHandles.updating);
  }
  get graphics3DGraphics() {
    return this.graphicsCore?.graphics3DGraphics;
  }
  get graphics3DGraphicsByObjectID() {
    return this.graphicsCore?.graphics3DGraphicsByObjectID;
  }
  get loadedGraphics() {
    return this.owner.loadedGraphics;
  }
  get fullOpacity() {
    return this.owner.fullOpacity ?? 1;
  }
  get slicePlaneEnabled() {
    return this.owner.slicePlaneEnabled;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  notifyGraphicGeometryChanged(i12) {
    this.graphicsCore.notifyGraphicGeometryChanged(i12);
  }
  notifyGraphicVisibilityChanged(i12) {
    this.graphicsCore.notifyGraphicVisibilityChanged(i12);
  }
  notifyContentGeometryUpdate() {
    this.owner.notifyContentGeometryUpdate?.();
  }
  getRenderingInfo(i12, t14, e22) {
    const r18 = r11(i12, { renderer: t14, arcade: e22 });
    if (r18?.color) {
      const i13 = r18.color;
      i13[0] = i13[0] / 255, i13[1] = i13[1] / 255, i13[2] = i13[2] / 255;
    }
    return r18;
  }
  getRenderingInfoAsync(i12, t14, e22, r18) {
    return n9(i12, { renderer: t14, arcade: e22, ...r18 });
  }
  getHit(i12) {
    if (this.owner.loadedGraphics) {
      const t14 = this.owner.loadedGraphics.find(((t15) => t15.uid === i12));
      if (t14) {
        const i13 = this.layer instanceof h7 ? this.layer : null, e22 = c4(t14, i13);
        return { type: "graphic", graphic: e22, layer: e22.layer };
      }
    }
    return null;
  }
  whenGraphicBounds(i12, t14) {
    return this.graphicsCore ? this.graphicsCore.whenGraphicBounds(i12, t14) : Promise.reject();
  }
  computeAttachmentOrigin(i12, t14) {
    return this.graphicsCore ? this.graphicsCore.computeAttachmentOrigin(i12, t14) : null;
  }
  getSymbolLayerSize(i12, t14) {
    return this.graphicsCore ? this.graphicsCore.getSymbolLayerSize(i12, t14) : null;
  }
  maskOccludee(i12) {
    const t14 = this.graphicsCore?.objectStates;
    if (!t14) return e();
    const { set: e22, handle: s17 } = t14.acquireOccludeeSet(null);
    return t14.setUid(e22, i12.uid), s17;
  }
  highlight(i12, e22) {
    const r18 = this.graphicsCore?.objectStates;
    if (!r18) return P6;
    if (i12 instanceof R2) return P6;
    const s17 = e21(i12);
    if (0 === s17.length) return P6;
    if (s17[0] instanceof d5) {
      const i13 = s17.map(((i14) => i14.uid)), { set: t14, handle: n11 } = r18.acquireHighlightSet(e22, null);
      return r18.setUids(t14, i13), n11;
    }
    if ("number" == typeof s17[0]) {
      const i13 = s17, { set: t14, handle: n11 } = r18.acquireHighlightSet(e22, null);
      return r18.setObjectIds(t14, i13), n11;
    }
    return P6;
  }
  _setupSuspendResumeExtent() {
    const { scaleVisibility: i12, frustumVisibility: t14 } = this;
    if (null == i12 && null == t14) return;
    const e22 = ({ computedExtent: e23, extentPadding: r18 }) => {
      this._suspendResumeExtent = S(e23, this._suspendResumeExtent, r12, r18), null != i12 && i12.setExtent(this._suspendResumeExtent), null != t14 && t14.setExtent(this._suspendResumeExtent);
    };
    this.addHandles(l2((() => ({ computedExtent: this.graphicsCore?.computedExtent, extentPadding: this.graphicsCore?.extentPadding })), ((i13) => e22(i13)), w2));
  }
  _updateClippingExtent() {
    const i12 = this.view.clippingArea;
    this.graphicsCore.setClippingExtent(i12, this.view.spatialReference) && this.graphicsCore.recreateAllGraphics();
  }
};
r([m()], x4.prototype, "drapeSourcePriorityOffset", void 0), r([m()], x4.prototype, "type", void 0), r([m({ constructOnly: true })], x4.prototype, "owner", void 0), r([m()], x4.prototype, "layer", null), r([m()], x4.prototype, "layerViewUid", null), r([m()], x4.prototype, "view", null), r([m({ constructOnly: true })], x4.prototype, "graphicsCore", void 0), r([m()], x4.prototype, "scaleVisibility", null), r([m({ constructOnly: true })], x4.prototype, "frustumVisibility", void 0), r([m()], x4.prototype, "elevationAlignment", null), r([m()], x4.prototype, "scaleVisibilitySuspended", null), r([m({ readOnly: true })], x4.prototype, "frustumVisibilitySuspended", null), r([m()], x4.prototype, "suspended", null), r([m({ readOnly: true })], x4.prototype, "updating", null), r([m()], x4.prototype, "loadedGraphics", null), r([m()], x4.prototype, "fullOpacity", null), r([m()], x4.prototype, "slicePlaneEnabled", null), r([m()], x4.prototype, "drapeSourceType", void 0), r([m()], x4.prototype, "updatePolicy", null), r([m({ constructOnly: true })], x4.prototype, "scaleVisibilityEnabled", void 0), r([m({ constructOnly: true })], x4.prototype, "frustumVisibilityEnabled", void 0), r([m()], x4.prototype, "initializePromise", void 0), x4 = r([a("esri.views.3d.layers.graphics.GraphicsProcessor")], x4);
var P6 = e();

// node_modules/@arcgis/core/views/3d/layers/graphics/queryForSymbologySnapping.js
async function r17(r18, a15, s17) {
  if (null == r18 || 0 === a15.candidates.length) return t12;
  const i12 = r18.graphics3DGraphicsByObjectID ?? r18.graphics3DGraphics, o14 = [], c10 = [], { renderer: d15 } = r18, l18 = null != d15 && "arcadeRequired" in d15 && d15.arcadeRequired ? e11() : null, p12 = async (e22, { graphic: n11, graphics3DSymbol: t14 }) => {
    const a16 = await l18, i13 = await r18.getRenderingInfoAsync(n11, d15, a16, { signal: s17 });
    return null == i13 ? [] : t14.queryForSnapping(e22, g11, i13, s17);
  }, { candidates: u19, spatialReference: g11 } = a15;
  for (let e22 = 0; e22 < u19.length; ++e22) {
    const n11 = u19[e22], { objectId: r19 } = n11, t14 = "number" == typeof r19 ? i12?.get(r19) : void 0;
    if (null == t14) continue;
    const { graphics3DSymbol: a16 } = t14;
    a16.symbologySnappingSupported && (o14.push(p12(n11, t14)), c10.push(e22));
  }
  if (0 === o14.length) return t12;
  const h13 = await Promise.all(o14);
  s2(s17);
  const f7 = [], m9 = [];
  for (let e22 = 0; e22 < h13.length; ++e22) {
    const n11 = h13[e22], r19 = c10[e22];
    for (const e23 of n11) f7.push(e23), m9.push(r19);
  }
  return { candidates: f7, sourceCandidateIndices: m9 };
}
var t12 = { candidates: [], sourceCandidateIndices: [] };

// node_modules/@arcgis/core/views/3d/layers/support/LayerViewPerformanceInfo.js
var t13 = class {
  constructor(t14, e22 = 0, s17 = 0, r18 = 0, i12 = 0, o14 = null) {
    this.usedMemory = t14, this.displayedFeatures = e22, this.totalFeatures = s17, this.maximumFeatures = r18, this.nodes = i12, this.core = o14;
  }
};

// node_modules/@arcgis/core/views/3d/layers/GraphicsLayerView3D.js
var f6 = class extends l13(u10) {
  constructor() {
    super(...arguments), this.type = "graphics-3d", this.symbologySnappingSupported = true, this._slicePlaneEnabled = false, this.fullExtentInLocalViewSpatialReference = null, this.ignoresMemoryFactor = true;
  }
  get highlightOptions() {
    return null;
  }
  initialize() {
    this._set("processor", new x4({ owner: this, scaleVisibilityEnabled: true, frustumVisibilityEnabled: true })), this.addResolvingPromise(this.processor.initializePromise), this.addHandles(this.layer.on("graphic-update", ((e22) => this.processor.graphicsCore.graphicUpdateHandler(e22)))), this.layer.internal ? this.notifyChange("updating") : ("local" === this.view.viewingMode && this.addResolvingPromise((async () => this.fullExtentInLocalViewSpatialReference = await p5(this.layer.fullExtent, this.view.spatialReference))()), this.addHandles(f2((() => this.view?.basemapTerrain?.ready), (() => () => this.notifyChange("updating")), { once: true })));
  }
  destroy() {
    this._updatingHandles.removeAll(), this._set("processor", u(this.processor));
  }
  get loadedGraphics() {
    return this.layer.graphics;
  }
  get legendEnabled() {
    return this.canResume() && !this.processor?.frustumVisibilitySuspended;
  }
  get visibleAtCurrentScale() {
    return o7() ? t5(this.layer.effectiveScaleRange, this.view.scale) : !this.processor?.scaleVisibilitySuspended;
  }
  get slicePlaneEnabled() {
    const e22 = this.layer.internal;
    return this._slicePlaneEnabled && !e22;
  }
  set slicePlaneEnabled(e22) {
    this._slicePlaneEnabled = e22;
  }
  getSuspendInfo() {
    const e22 = super.getSuspendInfo();
    return e22.outsideOfView = this.processor?.frustumVisibilitySuspended ?? false, e22;
  }
  getHit(e22) {
    return this.processor.getHit(e22);
  }
  whenGraphicBounds(e22, r18) {
    return this.processor.whenGraphicBounds(e22, r18);
  }
  computeAttachmentOrigin(e22, r18) {
    return this.processor?.computeAttachmentOrigin(e22, r18);
  }
  getSymbolLayerSize(e22, r18) {
    return this.processor.getSymbolLayerSize(e22, r18);
  }
  queryGraphics() {
    return Promise.resolve(this.loadedGraphics);
  }
  maskOccludee(e22) {
    return this.processor.maskOccludee(e22);
  }
  highlight(e22, r18) {
    return this.processor.highlight(e22, r18?.name ?? c5);
  }
  notifyContentGeometryUpdate() {
    this.emit("visible-geometry-changed");
  }
  async elevationAlignPointsInFeatures(e22, s17) {
    const { processor: i12 } = this;
    if (null == i12?.graphics3DGraphics) throw new s("graphicslayerview3d:missing-processor", "A Graphics3D processor is needed to resolve graphics elevation.");
    const { graphics3DGraphics: t14 } = i12, o14 = (e23) => "number" == typeof e23 ? t14.get(e23) : void 0;
    return l14(this.view, this.layer, o14, e22, s17);
  }
  async queryForSymbologySnapping(e22, r18) {
    return r17(this.processor, e22, r18);
  }
  get updatePolicy() {
    return this.processor?.graphicsCore.effectiveUpdatePolicy || C3.SYNC;
  }
  isUpdating() {
    return this.view && this.layer && !(!this.processor?.updating && (this.layer.internal || this.view.basemapTerrain?.ready));
  }
  get performanceInfo() {
    return new t13(this.usedMemory, this.loadedGraphics.length, -1, -1);
  }
  get usedMemory() {
    return this.processor?.graphicsCore?.usedMemory ?? 0;
  }
  get unloadedMemory() {
    return this.processor?.graphicsCore?.unprocessedMemoryEstimate;
  }
  get test() {
    return { graphics3DProcessor: this.processor, loadedGraphics: this.loadedGraphics };
  }
};
r([m()], f6.prototype, "highlightOptions", null), r([m()], f6.prototype, "loadedGraphics", null), r([m({ readOnly: true })], f6.prototype, "legendEnabled", null), r([m()], f6.prototype, "layer", void 0), r([m({ readOnly: true })], f6.prototype, "processor", void 0), r([m({ readOnly: true })], f6.prototype, "visibleAtCurrentScale", null), r([m()], f6.prototype, "_slicePlaneEnabled", void 0), r([m({ type: Boolean })], f6.prototype, "slicePlaneEnabled", null), f6 = r([a("esri.views.3d.layers.GraphicsLayerView3D")], f6);
var b10 = f6;
export {
  b10 as default
};
//# sourceMappingURL=GraphicsLayerView3D-NP7U3IKD.js.map
