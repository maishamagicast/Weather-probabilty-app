import {
  a as a6
} from "./chunk-OXB7DIZS.js";
import {
  o as o3
} from "./chunk-QPVOPDXB.js";
import {
  i
} from "./chunk-GBOUNRWE.js";
import {
  t
} from "./chunk-FNXTTV6Z.js";
import {
  l as l2
} from "./chunk-LBDNG364.js";
import {
  t as t3
} from "./chunk-LP5PTXVN.js";
import {
  c
} from "./chunk-CEHNSC4S.js";
import "./chunk-GYJ4UTXD.js";
import {
  d
} from "./chunk-VCKINPGN.js";
import {
  q
} from "./chunk-SDCRJECE.js";
import "./chunk-4G42CJX6.js";
import "./chunk-NEI5HAVK.js";
import "./chunk-D7G7U7XX.js";
import "./chunk-2CS746FZ.js";
import "./chunk-UET4BL4J.js";
import "./chunk-YMT7TAQQ.js";
import "./chunk-RZGBA4KS.js";
import "./chunk-FSYN2HHU.js";
import "./chunk-7I4TWCTW.js";
import "./chunk-SCMB64VM.js";
import "./chunk-MBJ7YPSH.js";
import "./chunk-D34PNYRG.js";
import "./chunk-APMQAZ5Z.js";
import "./chunk-R7YP6EQJ.js";
import {
  f as f2
} from "./chunk-EWP4DLQF.js";
import {
  p
} from "./chunk-CHGKJUJ3.js";
import "./chunk-3YBQQHIP.js";
import "./chunk-OJQCHQYS.js";
import {
  t as t2
} from "./chunk-N3W3EVP3.js";
import {
  b2,
  d as d2,
  y
} from "./chunk-5BYUGSWZ.js";
import "./chunk-SIRTOV2N.js";
import {
  j
} from "./chunk-ORRXYRSR.js";
import {
  S,
  a as a5
} from "./chunk-OFINLTIW.js";
import "./chunk-Y3I5OGQC.js";
import "./chunk-M4XVX74D.js";
import "./chunk-UZ3YWBWC.js";
import "./chunk-2EOHKZLO.js";
import {
  h
} from "./chunk-A7I2KMJU.js";
import "./chunk-BPI4BR4E.js";
import "./chunk-3L5JZOMH.js";
import "./chunk-N77BULFI.js";
import "./chunk-NEIJCC5O.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-A6R2FXH6.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-4KZLIAP7.js";
import "./chunk-62NATJWT.js";
import "./chunk-FOPBVVXE.js";
import {
  n
} from "./chunk-INI6MHIQ.js";
import "./chunk-QUZZIDFR.js";
import "./chunk-CBCDVQSA.js";
import "./chunk-RKF6WUZT.js";
import "./chunk-RMRI4NYS.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-BLBN3L5Q.js";
import "./chunk-XNUSHDFN.js";
import "./chunk-4AKMPOG7.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-ZJQPHR3K.js";
import "./chunk-R4XAU2TW.js";
import "./chunk-YVMULGDJ.js";
import "./chunk-3LLHBKLI.js";
import {
  V
} from "./chunk-74GULGYB.js";
import {
  U,
  a as a4,
  l
} from "./chunk-HYAO4PVV.js";
import "./chunk-SRNKPAJX.js";
import "./chunk-VNQUG2TO.js";
import "./chunk-MOMLPET6.js";
import "./chunk-3QHX4R4B.js";
import "./chunk-ORMKIVR7.js";
import "./chunk-TOCH3L2K.js";
import "./chunk-EULNFFHG.js";
import {
  DateTime,
  FixedOffsetZone
} from "./chunk-SDIBXPSJ.js";
import {
  z
} from "./chunk-CBXZL53X.js";
import "./chunk-LPCUYJ2B.js";
import "./chunk-SMO33YG7.js";
import {
  f
} from "./chunk-LCBAL6ER.js";
import {
  s as s4
} from "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import {
  s as s3
} from "./chunk-67AKDROO.js";
import "./chunk-CM3TIXEV.js";
import {
  H,
  b
} from "./chunk-POWGZO3T.js";
import {
  Ht,
  I,
  _,
  k,
  x
} from "./chunk-OUZJZB6I.js";
import {
  o as o2
} from "./chunk-NJZD7WM5.js";
import {
  r as r2
} from "./chunk-CL7VLXUR.js";
import {
  g
} from "./chunk-FCX4ZA3Z.js";
import {
  m2 as m
} from "./chunk-2ZPU5IZX.js";
import {
  a2 as a3
} from "./chunk-S62CSPIH.js";
import {
  w,
  x as x2
} from "./chunk-X26VPODZ.js";
import {
  o
} from "./chunk-XNYPRDKK.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import "./chunk-JNYZ3I5R.js";
import {
  a as a2
} from "./chunk-N626Y23H.js";
import {
  a,
  s,
  s2
} from "./chunk-TJPLHZCD.js";
import {
  L
} from "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/WMSSublayer.js
var h2;
var c2 = 0;
var m2 = h2 = class extends n.IdentifiableMixin(a5) {
  constructor(e) {
    super(e), this.description = null, this.dimensions = null, this.fullExtent = null, this.fullExtents = null, this.legendUrl = null, this.legendEnabled = true, this.layer = null, this.maxScale = 0, this.minScale = 0, this.name = null, this.parent = null, this.popupEnabled = false, this.queryable = false, this.sublayers = null, this.spatialReferences = null, this.title = null, this.addHandles([a4((() => this.sublayers), "after-add", (({ item: e2 }) => {
      e2.parent = this, e2.layer = this.layer;
    }), U), a4((() => this.sublayers), "after-remove", (({ item: e2 }) => {
      e2.layer = e2.parent = null;
    }), U), l((() => this.sublayers), ((e2, t4) => {
      if (t4) for (const r3 of t4) r3.layer = r3.parent = null;
      if (e2) for (const r3 of e2) r3.parent = this, r3.layer = this.layer;
    }), U), l((() => this.layer), ((e2) => {
      if (this.sublayers) for (const t4 of this.sublayers) t4.layer = e2;
    }), U)]);
  }
  get id() {
    const e = this._get("id");
    return e ?? c2++;
  }
  set id(e) {
    this._set("id", e);
  }
  readLegendUrl(e, t4) {
    return t4.legendUrl ?? t4.legendURL ?? null;
  }
  get effectiveScaleRange() {
    const { minScale: e, maxScale: t4 } = this;
    return { minScale: e, maxScale: t4 };
  }
  castSublayers(e) {
    return w(V.ofType(h2), e);
  }
  set visible(e) {
    this._setAndNotifyLayer("visible", e);
  }
  clone() {
    const e = new h2();
    return this.hasOwnProperty("description") && (e.description = this.description), this.hasOwnProperty("fullExtent") && (e.fullExtent = this.fullExtent.clone()), this.hasOwnProperty("fullExtents") && (e.fullExtents = this.fullExtents?.map(((e2) => e2.clone())) ?? null), this.hasOwnProperty("legendUrl") && (e.legendUrl = this.legendUrl), this.hasOwnProperty("legendEnabled") && (e.legendEnabled = this.legendEnabled), this.hasOwnProperty("layer") && (e.layer = this.layer), this.hasOwnProperty("name") && (e.name = this.name), this.hasOwnProperty("parent") && (e.parent = this.parent), this.hasOwnProperty("queryable") && (e.queryable = this.queryable), this.hasOwnProperty("sublayers") && (e.sublayers = this.sublayers?.map(((e2) => e2.clone()))), this.hasOwnProperty("spatialReferences") && (e.spatialReferences = this.spatialReferences?.map(((e2) => e2))), this.hasOwnProperty("visible") && (e.visible = this.visible), this.hasOwnProperty("title") && (e.title = this.title), e;
  }
  _setAndNotifyLayer(e, t4) {
    const r3 = this.layer;
    this._get(e) !== t4 && (this._set(e, t4), r3 && r3.emit("wms-sublayer-update", { propertyName: e, id: this.id }));
  }
};
r([m()], m2.prototype, "description", void 0), r([m({ readOnly: true })], m2.prototype, "dimensions", void 0), r([m({ type: z, json: { name: "extent" } })], m2.prototype, "fullExtent", void 0), r([m()], m2.prototype, "fullExtents", void 0), r([m({ type: Number, json: { write: { enabled: false, overridePolicy: () => ({ ignoreOrigin: true, enabled: true }) } } })], m2.prototype, "id", null), r([m({ type: String, json: { name: "legendUrl", write: { ignoreOrigin: true } } })], m2.prototype, "legendUrl", void 0), r([o2("legendUrl", ["legendUrl", "legendURL"])], m2.prototype, "readLegendUrl", null), r([m({ type: Boolean, json: { name: "showLegend", origins: { "web-map": { read: false, write: false }, "web-scene": { read: false, write: false } } } })], m2.prototype, "legendEnabled", void 0), r([m()], m2.prototype, "layer", void 0), r([m()], m2.prototype, "maxScale", void 0), r([m()], m2.prototype, "minScale", void 0), r([m({ readOnly: true })], m2.prototype, "effectiveScaleRange", null), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], m2.prototype, "name", void 0), r([m()], m2.prototype, "parent", void 0), r([m({ type: Boolean, json: { read: { source: "showPopup" }, write: { ignoreOrigin: true, target: "showPopup" } } })], m2.prototype, "popupEnabled", void 0), r([m({ type: Boolean, json: { write: { ignoreOrigin: true } } })], m2.prototype, "queryable", void 0), r([m()], m2.prototype, "sublayers", void 0), r([s3("sublayers")], m2.prototype, "castSublayers", null), r([m({ type: [Number], json: { read: { source: "spatialReferences" } } })], m2.prototype, "spatialReferences", void 0), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], m2.prototype, "title", void 0), r([m({ type: Boolean, value: true, json: { read: { source: "defaultVisibility" } } })], m2.prototype, "visible", null), m2 = h2 = r([a3("esri.layers.support.WMSSublayer")], m2);

// node_modules/@arcgis/core/layers/support/wmsUtils.js
var o4 = { 84: 4326, 83: 4269, 27: 4267 };
function a7(n2) {
  if (!n2) return null;
  const r3 = { idCounter: -1 };
  if ("string" == typeof n2) {
    n2 = new DOMParser().parseFromString(n2, "text/xml");
  }
  const i2 = n2.documentElement;
  if ("ServiceExceptionReport" === i2.nodeName) {
    const e = Array.prototype.slice.call(i2.childNodes).map(((e2) => e2.textContent)).join("\r\n");
    throw new s2("wmslayer:wms-capabilities-xml-is-not-valid", "The server returned errors when the WMS capabilities were requested.", e);
  }
  const s5 = d3("Capability", i2), o5 = d3("Service", i2), a8 = s5 && d3("Request", s5);
  if (!s5 || !o5 || !a8) return null;
  const l4 = d3("Layer", s5);
  if (!l4) return null;
  const m4 = "WMS_Capabilities" === i2.nodeName || "WMT_MS_Capabilities" === i2.nodeName ? i2.getAttribute("version") : "1.3.0", f4 = x3("Title", o5, "") || x3("Name", o5, ""), p3 = x3("AccessConstraints", o5, ""), h4 = /^none$/i.test(p3) ? "" : p3, y3 = x3("Abstract", o5, ""), S3 = parseInt(x3("MaxWidth", o5, "5000"), 10), E = parseInt(x3("MaxHeight", o5, "5000"), 10), L3 = g2(a8, "GetMap"), C = N(a8, "GetMap"), M2 = b3(l4, m4, r3);
  if (!M2) return null;
  let T2, R2 = 0;
  const I3 = Array.prototype.slice.call(s5.childNodes), v2 = M2.sublayers ?? [], w3 = (e) => {
    null != e && v2.push(e);
  };
  I3.forEach(((e) => {
    "Layer" === e.nodeName && (0 === R2 ? T2 = e : 1 === R2 ? (M2.name && (M2.name = "", w3(b3(T2, m4, r3))), w3(b3(e, m4, r3))) : w3(b3(e, m4, r3)), R2++);
  }));
  const U3 = M2.sublayers ?? [], V3 = M2.fullExtents ?? [];
  0 === U3.length && U3.push(M2), M2.extent ??= U3[0].extent;
  const _3 = M2.spatialReferences.length > 0 ? M2.spatialReferences : u(M2), O2 = N(a8, "GetFeatureInfo"), B2 = O2 ? g2(a8, "GetFeatureInfo") : null, k3 = c3(U3), q3 = M2.minScale || 0, X3 = M2.maxScale || 0, D = M2.dimensions ?? [], $ = k3.reduce(((e, t4) => e.concat(t4.dimensions ?? [])), []), j2 = D.concat($).filter(F);
  let G = null;
  if (j2.length) {
    const t4 = j2.map(((e) => {
      const { extent: t5 } = e;
      return A(t5) ? t5.map(((e2) => e2.getTime())) : t5?.map(((e2) => [e2.min.getTime(), e2.max.getTime()]));
    })).flat(2).filter(L), { start: n3, end: r4 } = t4.reduce(((e, t5) => ({ start: Math.min(e.start, t5), end: Math.max(e.end, t5) })), { start: 1 / 0, end: -1 / 0 });
    G = { startTimeField: null, endTimeField: null, trackIdField: void 0, timeExtent: [n3, r4] };
  }
  return { copyright: h4, description: y3, dimensions: D, extent: M2.extent, fullExtents: V3, featureInfoFormats: B2, featureInfoUrl: O2, mapUrl: C, maxWidth: S3, maxHeight: E, maxScale: X3, minScale: q3, layers: k3, spatialReferences: _3, supportedImageFormatTypes: L3, timeInfo: G, title: f4, version: m4 };
}
function l3(e) {
  const t4 = e.filter(((e2) => e2.popupEnabled && e2.name && e2.queryable));
  return t4.length ? t4.map((({ name: e2 }) => e2)).join() : null;
}
function u(e) {
  if (e.spatialReferences.length > 0) return e.spatialReferences;
  if (e.sublayers) for (const t4 of e.sublayers) {
    const e2 = u(t4);
    if (e2.length > 0) return e2;
  }
  return [];
}
function c3(e) {
  let t4 = [];
  for (const n2 of e) t4.push(n2), n2.sublayers?.length && (t4 = t4.concat(c3(n2.sublayers)), delete n2.sublayers);
  return t4;
}
function m3(e, t4, n2) {
  return t4.getAttribute(e) ?? n2;
}
function f3(e, t4, n2, r3) {
  const i2 = d3(e, n2);
  return i2 ? m3(t4, i2, r3) : r3;
}
function d3(e, t4) {
  for (let n2 = 0; n2 < t4.childNodes.length; n2++) {
    const r3 = t4.childNodes[n2];
    if (S2(r3) && r3.nodeName === e) return r3;
  }
  return null;
}
function p2(e, t4) {
  if (null == t4) return [];
  const n2 = [];
  for (let r3 = 0; r3 < t4.childNodes.length; r3++) {
    const i2 = t4.childNodes[r3];
    S2(i2) && i2.nodeName === e && n2.push(i2);
  }
  return n2;
}
function x3(e, t4, n2) {
  return d3(e, t4)?.textContent ?? n2;
}
function h3(e, t4, n2) {
  const r3 = parseFloat(e.getAttribute("minx") ?? "0"), i2 = parseFloat(e.getAttribute("miny") ?? "0"), s5 = parseFloat(e.getAttribute("maxx") ?? "0"), o5 = parseFloat(e.getAttribute("maxy") ?? "0");
  return { xmin: n2 ? isNaN(i2) ? -Number.MAX_VALUE : i2 : isNaN(r3) ? -Number.MAX_VALUE : r3, ymin: n2 ? isNaN(r3) ? -Number.MAX_VALUE : r3 : isNaN(i2) ? -Number.MAX_VALUE : i2, xmax: n2 ? isNaN(o5) ? Number.MAX_VALUE : o5 : isNaN(s5) ? Number.MAX_VALUE : s5, ymax: n2 ? isNaN(s5) ? Number.MAX_VALUE : s5 : isNaN(o5) ? Number.MAX_VALUE : o5, spatialReference: { wkid: t4 } };
}
function N(e, t4) {
  const n2 = d3(t4, e);
  if (n2) {
    const e2 = d3("DCPType", n2);
    if (e2) {
      const t5 = d3("HTTP", e2);
      if (t5) {
        const e3 = d3("Get", t5);
        if (e3) {
          let t6 = f3("OnlineResource", "xlink:href", e3, null);
          if (t6) {
            const e4 = t6.indexOf("&");
            return -1 !== e4 && e4 === t6.length - 1 && (t6 = t6.slice(0, -1)), M(t6, ["service", "request"]);
          }
        }
      }
    }
  }
  return null;
}
function g2(t4, n2) {
  const r3 = p2("Operation", t4);
  if (!r3.length) {
    return p2("Format", d3(n2, t4)).map((({ textContent: e }) => e)).filter(L);
  }
  const i2 = [];
  for (const e of r3) if (e.getAttribute("name") === n2) {
    const t5 = p2("Format", e);
    for (const { textContent: e2 } of t5) null != e2 && i2.push(e2);
  }
  return i2;
}
function y2(e, t4, n2) {
  const r3 = d3(t4, e);
  if (!r3) return n2;
  const { textContent: i2 } = r3;
  if (null == i2 || "" === i2) return n2;
  const s5 = Number(i2);
  return isNaN(s5) ? n2 : s5;
}
function b3(e, t4, n2) {
  if (!e) return null;
  const i2 = e.getAttribute("queryable")?.toLowerCase(), s5 = "1" === i2 || "true" === i2, a8 = { id: n2.idCounter++, fullExtents: [], parentLayerId: null, queryable: s5, spatialReferences: [], sublayers: null }, l4 = d3("LatLonBoundingBox", e), u2 = d3("EX_GeographicBoundingBox", e), c4 = l4 ? h3(l4, 4326) : u2 ? { xmin: parseFloat(x3("westBoundLongitude", u2, "0")), ymin: parseFloat(x3("southBoundLatitude", u2, "0")), xmax: parseFloat(x3("eastBoundLongitude", u2, "0")), ymax: parseFloat(x3("northBoundLatitude", u2, "0")), spatialReference: { wkid: 4326 } } : { xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: { wkid: 4326 } };
  a8.minScale = y2(e, "MaxScaleDenominator", 0), a8.maxScale = y2(e, "MinScaleDenominator", 0);
  const f4 = ["1.0.0", "1.1.0", "1.1.1"].includes(t4) ? "SRS" : "CRS";
  return Array.prototype.slice.call(e.childNodes).forEach(((e2) => {
    if ("Name" === e2.nodeName) a8.name = e2.textContent || "";
    else if ("Title" === e2.nodeName) a8.title = e2.textContent || "";
    else if ("Abstract" === e2.nodeName) a8.description = e2.textContent || "";
    else if ("BoundingBox" === e2.nodeName) {
      const n3 = e2.getAttribute(f4), i3 = n3?.indexOf(":");
      if (i3 && i3 > -1) {
        let s6 = parseInt(n3.slice(i3 + 1), 10);
        0 === s6 || isNaN(s6) || (s6 = o4[s6] ?? s6);
        const l5 = "1.3.0" === t4 ? h3(e2, s6, o3(s6)) : h3(e2, s6);
        l5 && a8.fullExtents && a8.fullExtents.push(l5);
      }
    } else if (e2.nodeName === f4) {
      (e2.textContent?.split(" ") ?? []).forEach(((e3) => {
        let t5 = NaN;
        if (e3.includes(":")) {
          const [n3, r3] = e3.toUpperCase().split(":");
          "CRS" !== n3 && "EPSG" !== n3 || (t5 = parseInt(r3, 10));
        } else t5 = parseInt(e3, 10);
        if (0 !== t5 && !isNaN(t5)) {
          const e4 = o4[t5] ?? t5;
          a8.spatialReferences.includes(e4) || a8.spatialReferences.push(e4);
        }
      }));
    } else if ("Style" !== e2.nodeName || a8.legendUrl) {
      if ("Layer" === e2.nodeName) {
        const r3 = b3(e2, t4, n2);
        r3 && (r3.parentLayerId = a8.id, a8.sublayers || (a8.sublayers = []), a8.sublayers.push(r3));
      }
    } else {
      const t5 = d3("LegendURL", e2);
      if (t5) {
        const e3 = d3("OnlineResource", t5);
        e3 && (a8.legendUrl = e3.getAttribute("xlink:href"));
      }
    }
  })), a8.extent = c4, a8.dimensions = p2("Dimension", e).filter(((e2) => e2.getAttribute("name") && e2.getAttribute("units") && e2.textContent)).map(((e2) => {
    const t5 = e2.getAttribute("name"), n3 = e2.getAttribute("units"), r3 = e2.textContent, i3 = e2.getAttribute("unitSymbol") ?? void 0, s6 = e2.getAttribute("default") ?? void 0, o5 = "0" !== m3("default", e2, "0"), a9 = "0" !== m3("nearestValue", e2, "0"), l5 = "0" !== m3("current", e2, "0");
    if (F({ name: t5, units: n3 })) {
      return { name: "time", units: "ISO8601", extent: I2(r3), default: I2(s6), multipleValues: o5, nearestValue: a9, current: l5 };
    }
    if (L2({ name: t5, units: n3 })) {
      return { name: "elevation", units: n3, extent: T(r3), unitSymbol: i3, default: T(s6), multipleValues: o5, nearestValue: a9 };
    }
    return { name: t5, units: n3, extent: R(r3), unitSymbol: i3, default: R(s6), multipleValues: o5, nearestValue: a9 };
  })), a8;
}
function A(e) {
  return Array.isArray(e) && e.length > 0 && e[0] instanceof Date;
}
function S2(e) {
  return e.nodeType === Node.ELEMENT_NODE;
}
function L2(e) {
  return /^elevation$/i.test(e.name) && /^(epsg|crs):\d+$/i.test(e.units);
}
function F(e) {
  return /^time$/i.test(e.name) && /^iso8601$/i.test(e.units);
}
function M(e, t4) {
  const r3 = [], i2 = I(e);
  for (const n2 in i2.query) i2.query.hasOwnProperty(n2) && (t4.includes(n2.toLowerCase()) || r3.push(n2 + "=" + i2.query[n2]));
  return i2.path + (r3.length ? "?" + r3.join("&") : "");
}
function T(t4) {
  if (!t4) return;
  const n2 = t4.includes("/"), r3 = t4.split(",");
  return n2 ? r3.map(((e) => {
    const t5 = e.split("/");
    if (t5.length < 2) return null;
    return { min: parseFloat(t5[0]), max: parseFloat(t5[1]), resolution: t5.length >= 3 && "0" !== t5[2] ? parseFloat(t5[2]) : void 0 };
  })).filter(L) : r3.map(((e) => parseFloat(e)));
}
function R(t4) {
  if (!t4) return;
  const n2 = t4.includes("/"), r3 = t4.split(",");
  return n2 ? r3.map(((e) => {
    const t5 = e.split("/");
    if (t5.length < 2) return null;
    return { min: t5[0], max: t5[1], resolution: t5.length >= 3 && "0" !== t5[2] ? t5[2] : void 0 };
  })).filter(L) : r3;
}
function I2(t4) {
  if (!t4) return;
  const n2 = t4.includes("/"), r3 = t4.split(",");
  return n2 ? r3.map(((e) => {
    const t5 = e.split("/");
    if (t5.length < 2) return null;
    return { min: v(t5[0]), max: v(t5[1]), resolution: t5.length >= 3 && "0" !== t5[2] ? w2(t5[2]) : void 0 };
  })).filter(L) : r3.map(((e) => v(e)));
}
function v(e) {
  return DateTime.fromISO(e, { zone: FixedOffsetZone.utcInstance }).toJSDate();
}
function w2(e) {
  const t4 = /(?:p(\d+y|\d+(?:\.|,)\d+y)?(\d+m|\d+(?:\.|,)\d+m)?(\d+d|\d+(?:\.|,)\d+d)?)?(?:t(\d+h|\d+(?:\.|,)\d+h)?(\d+m|\d+(?:\.|,)\d+m)?(\d+s|\d+(?:\.|,)\d+s)?)?/i, n2 = e.match(t4);
  if (!n2) return null;
  return { years: U2(n2[1]), months: U2(n2[2]), days: U2(n2[3]), hours: U2(n2[4]), minutes: U2(n2[5]), seconds: U2(n2[6]) };
}
function U2(e) {
  if (!e) return 0;
  const t4 = /(?:\d+(?:\.|,)\d+|\d+)/, n2 = e.match(t4);
  if (!n2) return 0;
  const r3 = n2[0].replace(",", ".");
  return Number(r3);
}
function V2(e) {
  return e.toISOString().replace(/\.[0-9]{3}/, "");
}
var _2 = "0000-01-01T00:00:00Z";
var O = "9999-12-31T23:59:59Z";
function B(e) {
  if (!e || e.isAllTime || e.isEmpty) return;
  const { start: t4, end: n2 } = e;
  if (t4 && n2 && t4.getTime() === n2.getTime()) return `${V2(t4)}`;
  return `${t4 ? V2(t4) : _2}/${n2 ? V2(n2) : O}`;
}
var k2 = /* @__PURE__ */ new Set([102100, 3857, 102113, 900913]);
var q2 = /* @__PURE__ */ new Set([3395, 54004]);
function X(e, t4) {
  let n2 = e.wkid;
  return null == t4 ? n2 : (null != n2 && t4.includes(n2) || !e.latestWkid || (n2 = e.latestWkid), null != n2 && k2.has(n2) ? t4.find(((e2) => k2.has(e2))) || t4.find(((e2) => q2.has(e2))) || 102100 : n2);
}

// node_modules/@arcgis/core/layers/WMSLayer.js
var Q = new o({ bmp: "image/bmp", gif: "image/gif", jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml" }, { ignoreUnknown: false });
function K(e) {
  return "text/html" === e;
}
function X2(e) {
  return "text/plain" === e;
}
var Y = class extends p(c(f2(t2(b2(j(S(h))))))) {
  constructor(...e) {
    super(...e), this.allSublayers = new l2({ getCollections: () => [this.sublayers], getChildrenFunction: (e2) => e2.sublayers }), this.customParameters = null, this.customLayerParameters = null, this.copyright = null, this.description = null, this.dimensions = null, this.fullExtent = null, this.fullExtents = null, this.featureInfoFormats = null, this.featureInfoUrl = null, this.fetchFeatureInfoFunction = null, this.imageFormat = null, this.imageMaxHeight = 2048, this.imageMaxWidth = 2048, this.imageTransparency = true, this.legendEnabled = true, this.mapUrl = null, this.isReference = null, this.operationalLayerType = "WMS", this.spatialReference = null, this.spatialReferences = null, this.sublayers = null, this.type = "wms", this.version = null, this.addHandles([a4((() => this.sublayers), "after-add", (({ item: e2 }) => {
      e2.parent = e2.layer = this;
    }), U), a4((() => this.sublayers), "after-remove", (({ item: e2 }) => {
      e2.layer = e2.parent = null;
    }), U), l((() => this.sublayers), ((e2, t4) => {
      if (t4) for (const r3 of t4) r3.layer = r3.parent = null;
      if (e2) for (const r3 of e2) r3.parent = r3.layer = this;
    }), U)]);
  }
  normalizeCtorArgs(e, t4) {
    return "string" == typeof e ? { url: e, ...t4 } : e;
  }
  destroy() {
    this.allSublayers.destroy();
  }
  load(e) {
    const t4 = null != e ? e.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["WMS"] }, e).catch(a2).then((() => this._fetchService(t4))).then((() => this._checkLayerValidity()))), Promise.resolve(this);
  }
  readFullExtentFromItemOrMap(e, t4) {
    const r3 = t4.extent;
    return r3 ? new z({ xmin: r3[0][0], ymin: r3[0][1], xmax: r3[1][0], ymax: r3[1][1] }) : null;
  }
  writeFullExtent(e, t4) {
    t4.extent = [[e.xmin, e.ymin], [e.xmax, e.ymax]];
  }
  get featureInfoFormat() {
    return null == this.featureInfoFormats ? null : this.featureInfoFormats.find(K) ?? this.featureInfoFormats.find(X2) ?? null;
  }
  set featureInfoFormat(e) {
    null == e ? (this.revert("featureInfoFormat", "service"), this._clearOverride("featureInfoFormat")) : (K(e) || X2(e)) && this._override("featureInfoFormat", e);
  }
  readImageFormat(e, t4) {
    const r3 = t4.supportedImageFormatTypes;
    return r3 && r3.includes("image/png") ? "image/png" : r3 && r3[0];
  }
  readSpatialReferenceFromItemOrDocument(e, t4) {
    return new f(t4.spatialReferences[0]);
  }
  writeSpatialReferences(e, t4) {
    const r3 = this.spatialReference?.wkid;
    e && r3 ? (t4.spatialReferences = e.filter(((e2) => e2 !== r3)), t4.spatialReferences.unshift(r3)) : t4.spatialReferences = e;
  }
  readSublayersFromItemOrMap(e, t4, r3) {
    return ee(t4.layers, r3, t4.visibleLayers);
  }
  readSublayers(e, t4, r3) {
    return ee(t4.layers, r3);
  }
  writeSublayers(e, t4, r3, o5) {
    t4.layers = [];
    const s5 = /* @__PURE__ */ new Map(), i2 = e.flatten((({ sublayers: e2 }) => e2 ?? []));
    for (const a8 of i2) if ("number" == typeof a8.parent?.id) {
      const e2 = s5.get(a8.parent.id);
      null != e2 ? e2.push(a8.id) : s5.set(a8.parent.id, [a8.id]);
    }
    for (const a8 of i2) {
      const e2 = { sublayer: a8, ...o5 }, r4 = a8.write({ parentLayerId: "number" == typeof a8.parent?.id ? a8.parent.id : -1 }, e2);
      if (s5.has(a8.id) && (r4.sublayerIds = s5.get(a8.id)), !a8.sublayers && a8.name) {
        const r5 = a8.write({}, e2);
        delete r5.id, t4.layers.push(r5);
      }
    }
    t4.visibleLayers = i2.filter((({ visible: e2, sublayers: t5 }) => e2 && !t5)).map((({ name: e2 }) => e2)).toArray();
  }
  set url(e) {
    if (!e) return void this._set("url", e);
    const { path: t4, query: r3 } = I(e);
    for (const s5 in r3) /^(request|service)$/i.test(s5) && delete r3[s5];
    const o5 = Ht(t4, r3 ?? {});
    this._set("url", o5);
  }
  createExportImageParameters(e, t4, r3, o5) {
    const s5 = o5?.pixelRatio ?? 1, i2 = i({ extent: e, width: t4 }) * s5, a8 = new a6({ layer: this, scale: i2 }), { xmin: n2, ymin: l4, xmax: p3, ymax: m4, spatialReference: u2 } = e, c4 = X(u2, this.spatialReferences), y3 = "1.3.0" === this.version && o3(c4) ? `${l4},${n2},${m4},${p3}` : `${n2},${l4},${p3},${m4}`, f4 = a8.toJSON(), d4 = "1.3.0" === this.version ? "crs" : "srs";
    return { bbox: y3, [d4]: null == c4 || isNaN(c4) ? void 0 : "EPSG:" + c4, ...f4 };
  }
  async fetchImage(e, t4, r3, o5) {
    const i2 = this.mapUrl, a8 = this.createExportImageParameters(e, t4, r3, o5);
    if (!a8.layers) {
      const e2 = document.createElement("canvas");
      return e2.width = t4, e2.height = r3, e2;
    }
    const n2 = B(o5?.timeExtent), l4 = { responseType: "image", query: this._mixCustomParameters({ width: t4, height: r3, ...a8, time: n2, ...this.refreshParameters }), signal: o5?.signal };
    return H(i2 ?? "", l4).then(((e2) => e2.data));
  }
  async fetchImageBitmap(e, t4, r3, o5) {
    const i2 = this.mapUrl ?? "", a8 = this.createExportImageParameters(e, t4, r3, o5);
    if (!a8.layers) {
      const e2 = document.createElement("canvas");
      return e2.width = t4, e2.height = r3, e2;
    }
    const n2 = B(o5?.timeExtent), l4 = { responseType: "blob", query: this._mixCustomParameters({ width: t4, height: r3, ...a8, time: n2, ...this.refreshParameters }), signal: o5?.signal }, { data: p3 } = await H(i2, l4);
    return t3(p3, i2, o5?.signal);
  }
  fetchFeatureInfo(e, t4, r3, o5, s5) {
    const i2 = i({ extent: e, width: t4 }), a8 = new a6({ layer: this, scale: i2 }), n2 = l3(a8.visibleSublayers);
    if (null == this.featureInfoUrl || null == n2) return Promise.resolve([]);
    if (null == this.fetchFeatureInfoFunction && null == this.featureInfoFormat) return Promise.resolve([]);
    const l4 = "1.3.0" === this.version ? { I: o5, J: s5 } : { x: o5, y: s5 }, p3 = { query_layers: n2, request: "GetFeatureInfo", info_format: this.featureInfoFormat, feature_count: 25, width: t4, height: r3, ...l4 }, m4 = { ...this.createExportImageParameters(e, t4, r3), ...p3 }, u2 = this._mixCustomParameters(m4);
    return null != this.fetchFeatureInfoFunction ? this.fetchFeatureInfoFunction(u2) : this._defaultFetchFeatureInfoFunction(Ht(this.featureInfoUrl, u2));
  }
  findSublayerById(e) {
    return this.allSublayers.find(((t4) => t4.id === e));
  }
  findSublayerByName(e) {
    return this.allSublayers.find(((t4) => t4.name === e));
  }
  serviceSupportsSpatialReference(e) {
    return b(this.url) || null != this.spatialReferences && this.spatialReferences.some(((t4) => {
      const r3 = 900913 === t4 ? f.WebMercator : new f({ wkid: t4 });
      return s4(r3, e);
    }));
  }
  _defaultFetchFeatureInfoFunction(e) {
    const t4 = document.createElement("iframe");
    t4.src = k(t.sanitizeUrl(_(e))), t4.style.border = "none", t4.style.margin = "0", t4.style.width = "100%", t4.setAttribute("sandbox", "");
    const s5 = new q({ title: this.title, content: t4 }), i2 = new d({ sourceLayer: this, popupTemplate: s5 });
    return Promise.resolve([i2]);
  }
  async _fetchService(e) {
    if (!this.resourceInfo && this.parsedUrl?.path) {
      const { path: t4, query: r3 } = this.parsedUrl, { data: o5 } = await H(t4, { query: { SERVICE: "WMS", REQUEST: "GetCapabilities", ...r3, ...this.customParameters }, responseType: "xml", signal: e });
      this.resourceInfo = a7(o5);
    }
    if (this.parsedUrl) {
      const e2 = new x(this.parsedUrl.path), { httpsDomains: r3 } = s.request;
      "https" !== e2.scheme || e2.port && "443" !== e2.port || !e2.host || r3.includes(e2.host) || r3.push(e2.host);
    }
    this.read(this.resourceInfo, { origin: "service" });
  }
  _checkLayerValidity() {
    if (!this.allSublayers.length) throw new s2("wmslayer:empty-layer", "The layer doesn't have any sublayer");
  }
  _mixCustomParameters(e) {
    if (!this.customLayerParameters && !this.customParameters) return e;
    const t4 = { ...this.customParameters, ...this.customLayerParameters };
    for (const r3 in t4) e[r3.toLowerCase()] = t4[r3];
    return e;
  }
};
function Z(e, t4) {
  return e.some(((e2) => {
    for (const r3 in e2) if (g(e2, r3, null, t4)) return true;
    return false;
  }));
}
function ee(e, t4, r3) {
  e = e ?? [];
  const o5 = /* @__PURE__ */ new Map();
  e.every(((e2) => null == e2.id)) && (e = a(e)).forEach(((e2, t5) => e2.id = t5));
  for (const i2 of e) {
    const e2 = new m2();
    e2.read(i2, t4), r3 && !r3.includes(e2.name) && (e2.visible = false), o5.set(e2.id, e2);
  }
  const s5 = [];
  for (const a8 of e) {
    const e2 = null != a8.id ? o5.get(a8.id) : null;
    if (e2) if (null != a8.parentLayerId && a8.parentLayerId >= 0) {
      const t5 = o5.get(a8.parentLayerId);
      if (!t5) continue;
      t5.sublayers || (t5.sublayers = new V()), t5.sublayers.push(e2);
    } else s5.push(e2);
  }
  return s5;
}
r([m({ readOnly: true })], Y.prototype, "allSublayers", void 0), r([m({ json: { type: Object, write: true } })], Y.prototype, "customParameters", void 0), r([m({ json: { type: Object, write: true } })], Y.prototype, "customLayerParameters", void 0), r([m({ type: String, json: { write: true } })], Y.prototype, "copyright", void 0), r([m()], Y.prototype, "description", void 0), r([m({ readOnly: true })], Y.prototype, "dimensions", void 0), r([m({ json: { type: [[Number]], read: { source: "extent" }, write: { target: "extent" }, origins: { "web-document": { write: { ignoreOrigin: true } }, "portal-item": { write: { ignoreOrigin: true } } } } })], Y.prototype, "fullExtent", void 0), r([o2(["web-document", "portal-item"], "fullExtent", ["extent"])], Y.prototype, "readFullExtentFromItemOrMap", null), r([r2(["web-document", "portal-item"], "fullExtent", { extent: { type: [[Number]] } })], Y.prototype, "writeFullExtent", null), r([m({ type: [z] })], Y.prototype, "fullExtents", void 0), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], Y.prototype, "featureInfoFormat", null), r([m({ type: [String], readOnly: true })], Y.prototype, "featureInfoFormats", void 0), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], Y.prototype, "featureInfoUrl", void 0), r([m()], Y.prototype, "fetchFeatureInfoFunction", void 0), r([m({ type: String, json: { origins: { "web-document": { default: "image/png", type: Q.jsonValues, read: { reader: Q.read, source: "format" }, write: { writer: Q.write, target: "format" } } } } })], Y.prototype, "imageFormat", void 0), r([o2("imageFormat", ["supportedImageFormatTypes"])], Y.prototype, "readImageFormat", null), r([m({ type: Number, json: { read: { source: "maxHeight" }, write: { target: "maxHeight" } } })], Y.prototype, "imageMaxHeight", void 0), r([m({ type: Number, json: { read: { source: "maxWidth" }, write: { target: "maxWidth" } } })], Y.prototype, "imageMaxWidth", void 0), r([m()], Y.prototype, "imageTransparency", void 0), r([m(d2)], Y.prototype, "legendEnabled", void 0), r([m({ type: ["show", "hide", "hide-children"] })], Y.prototype, "listMode", void 0), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], Y.prototype, "mapUrl", void 0), r([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], Y.prototype, "isReference", void 0), r([m({ type: ["WMS"] })], Y.prototype, "operationalLayerType", void 0), r([m()], Y.prototype, "resourceInfo", void 0), r([m({ type: f, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, write: false } })], Y.prototype, "spatialReference", void 0), r([o2(["web-document", "portal-item"], "spatialReference", ["spatialReferences"])], Y.prototype, "readSpatialReferenceFromItemOrDocument", null), r([m({ type: [x2], json: { read: false, origins: { service: { read: true }, "web-document": { read: false, write: { ignoreOrigin: true } }, "portal-item": { read: false, write: { ignoreOrigin: true } } } } })], Y.prototype, "spatialReferences", void 0), r([r2(["web-document", "portal-item"], "spatialReferences")], Y.prototype, "writeSpatialReferences", null), r([m({ type: V.ofType(m2), json: { write: { target: "layers", overridePolicy(e, t4, r3) {
  if (Z(this.allSublayers, r3)) return { ignoreOrigin: true };
} } } })], Y.prototype, "sublayers", void 0), r([o2(["web-document", "portal-item"], "sublayers", ["layers", "visibleLayers"])], Y.prototype, "readSublayersFromItemOrMap", null), r([o2("service", "sublayers", ["layers"])], Y.prototype, "readSublayers", null), r([r2("sublayers", { layers: { type: [m2] }, visibleLayers: { type: [String] } })], Y.prototype, "writeSublayers", null), r([m({ json: { read: false }, readOnly: true, value: "wms" })], Y.prototype, "type", void 0), r([m(y)], Y.prototype, "url", null), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], Y.prototype, "version", void 0), Y = r([a3("esri.layers.WMSLayer")], Y);
var te = Y;
export {
  te as default
};
//# sourceMappingURL=WMSLayer-DYSJD5KC.js.map
