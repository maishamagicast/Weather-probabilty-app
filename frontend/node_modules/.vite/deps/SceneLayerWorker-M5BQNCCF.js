import "./chunk-Z7JTE6WT.js";
import "./chunk-TJAY2AVU.js";
import "./chunk-QYDHMHNZ.js";
import "./chunk-3IQRKLNB.js";
import "./chunk-ZYWMFOAJ.js";
import "./chunk-4LDLOXAQ.js";
import "./chunk-RHVCSVQD.js";
import "./chunk-HXOI7XVG.js";
import "./chunk-KRZHFMU4.js";
import "./chunk-BWEEMT5B.js";
import "./chunk-JITSIG7E.js";
import "./chunk-Q75IV5IU.js";
import "./chunk-OHGGPE27.js";
import "./chunk-CGESJDPA.js";
import "./chunk-RZPBZYCG.js";
import "./chunk-O3DVK2IK.js";
import "./chunk-FL3AEKKI.js";
import "./chunk-TNLCQYJ3.js";
import "./chunk-OJQPIMLV.js";
import "./chunk-FXWNGVAA.js";
import "./chunk-6HU6D6AI.js";
import "./chunk-RFR37KMN.js";
import "./chunk-AYV3XLBY.js";
import "./chunk-MJTI6OYZ.js";
import "./chunk-7WMSTTK2.js";
import "./chunk-TOD32WVA.js";
import "./chunk-DTPLSS5W.js";
import "./chunk-KX3QNWMZ.js";
import "./chunk-HPADPQJ7.js";
import "./chunk-ULRXIASY.js";
import {
  d,
  n as n3
} from "./chunk-M72BPMIY.js";
import "./chunk-BZGZCX3L.js";
import "./chunk-4QM2FHGA.js";
import "./chunk-Z5RRLQK4.js";
import {
  i,
  i2
} from "./chunk-3ISR2POR.js";
import "./chunk-3JKWT76Y.js";
import "./chunk-LOLNWH3R.js";
import "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-BDYPDR3Y.js";
import "./chunk-DKFJHHQ4.js";
import "./chunk-Z34SUCTX.js";
import "./chunk-2RL34CVC.js";
import "./chunk-B6C2GOG6.js";
import "./chunk-K3VYMAVM.js";
import "./chunk-LQYJLB4P.js";
import "./chunk-D6GGPM6D.js";
import "./chunk-FQY65CBA.js";
import "./chunk-HH4Q2NN5.js";
import "./chunk-3CFYBBSV.js";
import "./chunk-AACFCXAP.js";
import "./chunk-BPI4BR4E.js";
import "./chunk-CJDZN5K5.js";
import "./chunk-N77BULFI.js";
import "./chunk-6TZIEYTZ.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-3TSZDV6B.js";
import "./chunk-P4O4YCLI.js";
import "./chunk-MSSQA3XK.js";
import "./chunk-RZGBA4KS.js";
import "./chunk-W5UOLFE2.js";
import "./chunk-AZ2S2PYZ.js";
import "./chunk-SCMB64VM.js";
import "./chunk-FOPBVVXE.js";
import "./chunk-CBCDVQSA.js";
import {
  n as n2
} from "./chunk-RKF6WUZT.js";
import "./chunk-RMRI4NYS.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-BLBN3L5Q.js";
import "./chunk-CBXZL53X.js";
import "./chunk-SRNKPAJX.js";
import "./chunk-MOMLPET6.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-LPCUYJ2B.js";
import "./chunk-3QHX4R4B.js";
import "./chunk-SMO33YG7.js";
import {
  f
} from "./chunk-LCBAL6ER.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import "./chunk-67AKDROO.js";
import {
  n
} from "./chunk-CM3TIXEV.js";
import "./chunk-2AYGXVZI.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-XNUSHDFN.js";
import "./chunk-4AKMPOG7.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-APMQAZ5Z.js";
import {
  T
} from "./chunk-ZJQPHR3K.js";
import "./chunk-NJZD7WM5.js";
import "./chunk-CL7VLXUR.js";
import "./chunk-FCX4ZA3Z.js";
import "./chunk-2ZPU5IZX.js";
import "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import "./chunk-JNYZ3I5R.js";
import "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import {
  r
} from "./chunk-5REYU5G2.js";
import "./chunk-N626Y23H.js";
import "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/libs/i3s/enums.js
var n4;
var e;
!(function(n8) {
  n8[n8.None = 0] = "None", n8[n8.Int16 = 1] = "Int16", n8[n8.Int32 = 2] = "Int32";
})(n4 || (n4 = {})), (function(n8) {
  n8[n8.Replace = 0] = "Replace", n8[n8.Outside = 1] = "Outside", n8[n8.Inside = 2] = "Inside", n8[n8.Finished = 3] = "Finished";
})(e || (e = {}));

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n5 || (n5 = new Promise(((t) => import("./i3s-BJAEI45Z.js").then(((t2) => t2.i)).then((({ default: e4 }) => {
    const n8 = e4({ locateFile: i3, onRuntimeInitialized: () => t(n8) });
    delete n8.then;
  })))).catch(((t) => {
    throw t;
  }))), n5;
}
function i3(e4) {
  return n(`esri/libs/i3s/${e4}`);
}
var n5;

// node_modules/@arcgis/core/views/3d/layers/I3SMeshWorkerHandle.js
var n7 = class {
  constructor(s, e4, t, o2, r4, i5) {
    this.layout = s, this.interleavedVertexData = e4, this.indices = t, this.hasColors = o2, this.hasModifications = r4, this.positionData = i5;
  }
};
var p = class {
  constructor(s, e4, t, o2, r4, i5, h3) {
    this.componentOffsets = s, this.featureIds = e4, this.anchorIds = t, this.anchors = o2, this.transformedGeometry = r4, this.globalTrafo = i5, this.obb = h3;
  }
};
var u = new r({ deallocator: null });
var c = n2();

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SNode.js
var o;
var r3;
var a;
var d2;
var c2;
!(function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.Culled = 1] = "Culled", e4[e4.NotChecked = 2] = "NotChecked";
})(o || (o = {})), (function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.PotentiallyModified = 1] = "PotentiallyModified", e4[e4.Culled = 2] = "Culled", e4[e4.Unknown = 3] = "Unknown", e4[e4.NotChecked = 4] = "NotChecked";
})(r3 || (r3 = {}));
!(function(e4) {
  e4[e4.Unknown = 0] = "Unknown", e4[e4.Uncached = 1] = "Uncached", e4[e4.Cached = 2] = "Cached";
})(a || (a = {})), (function(e4) {
  e4[e4.None = 0] = "None", e4[e4.MaxScreenThreshold = 1] = "MaxScreenThreshold", e4[e4.ScreenSpaceRelative = 2] = "ScreenSpaceRelative", e4[e4.RemovedFeatureDiameter = 3] = "RemovedFeatureDiameter", e4[e4.DistanceRangeFromDefaultCamera = 4] = "DistanceRangeFromDefaultCamera";
})(d2 || (d2 = {})), (function(e4) {
  e4[e4.Hole = 0] = "Hole", e4[e4.Leaf = 1] = "Leaf";
})(c2 || (c2 = {}));

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function u2(e4) {
  E = await U();
  const r4 = [e4.geometryBuffer];
  return { result: A(E, e4, r4), transferList: r4 };
}
async function m(e4) {
  E = await U();
  const r4 = [e4.geometryBuffer], { geometryBuffer: t } = e4, o2 = t.byteLength, n8 = E._malloc(o2), s = new Uint8Array(E.HEAPU8.buffer, n8, o2);
  s.set(new Uint8Array(t));
  const i5 = E.dracoDecompressPointCloudData(n8, s.byteLength);
  if (E._free(n8), i5.error.length > 0) throw new Error(`i3s.wasm: ${i5.error}`);
  const a2 = i5.featureIds?.length > 0 ? i5.featureIds.slice() : null, f2 = i5.positions.slice();
  return a2 && r4.push(a2.buffer), r4.push(f2.buffer), { result: { positions: f2, featureIds: a2 }, transferList: r4 };
}
async function y(e4) {
  await U(), S(e4);
  const r4 = { buffer: e4.buffer };
  return { result: r4, transferList: [r4.buffer] };
}
async function p2(e4) {
  await U(), j(e4);
}
async function d3(e4) {
  E = await U(), E.setLegacySchema(e4.context, e4.jsonSchema);
}
async function h2(e4) {
  const { localMatrix: n8, origin: s, positions: i5, vertexSpace: a2 } = e4, f2 = f.fromJSON(e4.inSpatialReference), c3 = f.fromJSON(e4.outSpatialReference);
  let l;
  const [{ projectBuffer: u3 }, { initializeProjection: m2 }] = await Promise.all([import("./projectBuffer-QBHBNIFD.js"), import("./projectionUtils-ZJU3P2N5.js")]);
  await m2(f2, c3);
  const y2 = [0, 0, 0];
  if (!u3(s, f2, 0, y2, c3, 0)) throw new Error("Failed to project");
  if ("georeferenced" === a2.type && null == a2.origin) {
    if (l = new Float64Array(i5.length), !u3(i5, f2, 0, l, c3, 0, l.length / 3)) throw new Error("Failed to project");
  } else {
    const e5 = "georeferenced" === a2.type ? i.fromJSON(a2) : i2.fromJSON(a2), { projectMeshVertexPositions: r4 } = await import("./projectMeshVertexPositions-NISF4NGH.js"), s2 = r4({ vertexAttributes: { position: i5 }, transform: n8 ? { localMatrix: n8 } : void 0, vertexSpace: e5, spatialReference: f2 }, c3);
    if (!s2) throw new Error("Failed to project");
    l = s2;
  }
  const p3 = l.length, [d4, h3, b2] = y2;
  for (let r4 = 0; r4 < p3; r4 += 3) l[r4] -= d4, l[r4 + 1] -= h3, l[r4 + 2] -= b2;
  return { result: { projected: l, original: i5, projectedOrigin: y2 }, transferList: [l.buffer, i5.buffer] };
}
async function b({ normalMatrix: r4, normals: t }) {
  const o2 = new Float32Array(t.length);
  return n3(o2, t, r4), T(r4) && d(o2, o2), { result: { transformed: o2, original: t }, transferList: [o2.buffer, t.buffer] };
}
function g(e4) {
  x(e4);
}
var w;
var E;
function j(e4) {
  if (!E) return;
  const r4 = e4.modifications, t = E._malloc(8 * r4.length), o2 = new Float64Array(E.HEAPU8.buffer, t, r4.length);
  for (let n8 = 0; n8 < r4.length; ++n8) o2[n8] = r4[n8];
  E.setModifications(e4.context, t, r4.length, e4.isGeodetic), E._free(t);
}
function A(e4, r4, t) {
  const { context: o2, globalTrafo: n8, mbs: s, obbData: a2, elevationOffset: l, geometryBuffer: u3, geometryDescriptor: m2, indexToVertexProjector: y2, vertexToRenderProjector: p3 } = r4, d4 = e4._malloc(u3.byteLength), h3 = 33, b2 = e4._malloc(h3 * Float64Array.BYTES_PER_ELEMENT), g2 = new Uint8Array(e4.HEAPU8.buffer, d4, u3.byteLength);
  g2.set(new Uint8Array(u3));
  const w2 = new Float64Array(e4.HEAPU8.buffer, b2, h3);
  _(w2, [NaN, NaN, NaN]);
  let E2 = w2.byteOffset + 3 * w2.BYTES_PER_ELEMENT, j2 = new Float64Array(w2.buffer, E2);
  _(j2, n8), E2 += 16 * w2.BYTES_PER_ELEMENT, j2 = new Float64Array(w2.buffer, E2), _(j2, s), E2 += 4 * w2.BYTES_PER_ELEMENT, a2 && (j2 = new Float64Array(w2.buffer, E2), _(j2, a2));
  const A2 = m2, L3 = { isDraco: false, isLegacy: false, color: r4.layouts.some(((e5) => e5.some(((e6) => "color" === e6.name)))), normal: r4.needNormals && r4.layouts.some(((e5) => e5.some(((e6) => "normalCompressed" === e6.name)))), uv0: r4.layouts.some(((e5) => e5.some(((e6) => "uv0" === e6.name)))), uvRegion: r4.layouts.some(((e5) => e5.some(((e6) => "uvRegion" === e6.name)))), featureIndex: A2.featureIndex }, S2 = e4.process(o2, !!r4.obbData, d4, g2.byteLength, A2, L3, b2, l, y2, p3, r4.normalReferenceFrame);
  if (e4._free(b2), e4._free(d4), S2.error.length > 0) throw new Error(`i3s.wasm: ${S2.error}`);
  if (S2.discarded) return null;
  const x2 = S2.componentOffsets.length > 0 ? S2.componentOffsets.slice() : null, P2 = S2.featureIds.length > 0 ? S2.featureIds.slice() : null, U2 = S2.anchorIds.length > 0 ? Array.from(S2.anchorIds) : null, M2 = S2.anchors.length > 0 ? Array.from(S2.anchors) : null, N = S2.interleavedVertedData.slice().buffer, I = S2.indicesType === n4.Int16 ? new Uint16Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 2).slice() : new Uint32Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 4).slice(), F = S2.positions.slice(), { buffer: T2, byteOffset: B, byteLength: O } = S2.positionIndices, R = S2.positionIndicesType === n4.Int16 ? new Uint16Array(T2, B, O / 2).slice() : new Uint32Array(T2, B, O / 4).slice(), v = new n7(r4.layouts[0], N, I, S2.hasColors, S2.hasModifications, { data: F, indices: R });
  return P2 && t.push(P2.buffer), x2 && t.push(x2.buffer), t.push(N), t.push(I.buffer), t.push(F.buffer), t.push(R.buffer), new p(x2, P2, U2, M2, v, n8, S2.obb);
}
function L2(e4) {
  return 0 === e4 ? r3.Unmodified : 1 === e4 ? r3.PotentiallyModified : 2 === e4 ? r3.Culled : r3.Unknown;
}
function S(e4) {
  if (!E) return;
  const { context: r4, buffer: t } = e4, o2 = E._malloc(t.byteLength), n8 = t.byteLength / Float64Array.BYTES_PER_ELEMENT, s = new Float64Array(E.HEAPU8.buffer, o2, n8), i5 = new Float64Array(t);
  s.set(i5), E.filterOBBs(r4, o2, n8), i5.set(s), E._free(o2);
}
function x(e4) {
  E && 0 === E.destroy(e4) && (E = null);
}
function _(e4, r4) {
  for (let t = 0; t < r4.length; ++t) e4[t] = r4[t];
}
async function P() {
  E || await U();
}
async function U() {
  return E || (E = await (w ??= e2())), E;
}
var M = { transform: (e4, r4) => E && A(E, e4, r4), destroy: x };
export {
  g as destroyContext,
  m as dracoDecompressPointCloudData,
  y as filterObbsForModifications,
  S as filterObbsForModificationsSync,
  P as initialize,
  L2 as interpretObbModificationResults,
  u2 as process,
  h2 as project,
  d3 as setLegacySchema,
  p2 as setModifications,
  j as setModificationsSync,
  M as test,
  b as transformNormals
};
//# sourceMappingURL=SceneLayerWorker-M5BQNCCF.js.map
