import {
  L as L2,
  w2
} from "./chunk-VFKFSI5B.js";
import {
  k as k3
} from "./chunk-SZ4I37ZN.js";
import {
  u as u6
} from "./chunk-DPZUWQQD.js";
import {
  A as A3
} from "./chunk-BZSAIP56.js";
import {
  V as V3,
  k as k2
} from "./chunk-AXEQLPYK.js";
import {
  a as a6
} from "./chunk-BB6EK2RQ.js";
import {
  s as s2
} from "./chunk-R3HU2OBM.js";
import "./chunk-5ZJG2W6X.js";
import "./chunk-7JSCPQTK.js";
import "./chunk-EYECC3PG.js";
import {
  i as i2
} from "./chunk-3GQTEESV.js";
import {
  t as t3
} from "./chunk-UBVWE2LK.js";
import {
  l as l2
} from "./chunk-32DGBWKL.js";
import {
  a as a8
} from "./chunk-DJRZXLB2.js";
import "./chunk-3ESJRJZD.js";
import {
  A as A2,
  l as l3
} from "./chunk-D2DRG2DH.js";
import {
  e as e2
} from "./chunk-HOVLU5XA.js";
import {
  c as c2
} from "./chunk-2DCDAX3U.js";
import {
  u as u5
} from "./chunk-EZ5REY53.js";
import {
  p as p3
} from "./chunk-3HYSKSYM.js";
import {
  f as f2
} from "./chunk-EWP4DLQF.js";
import {
  p as p2
} from "./chunk-CHGKJUJ3.js";
import "./chunk-3YBQQHIP.js";
import "./chunk-OJQCHQYS.js";
import {
  t as t2
} from "./chunk-N3W3EVP3.js";
import {
  b2 as b,
  c as c3,
  d,
  j as j3,
  l as l4,
  p as p4,
  u as u7,
  v as v2
} from "./chunk-ZJXLBTN2.js";
import {
  a as a4
} from "./chunk-SIRTOV2N.js";
import {
  j
} from "./chunk-LINWZZJL.js";
import {
  A,
  B,
  C,
  D,
  E,
  F as F2,
  H,
  L,
  O,
  P,
  Q,
  R as R2,
  T,
  U as U2,
  Y,
  q as q2,
  v
} from "./chunk-QZISYUPA.js";
import "./chunk-HQRWZZNA.js";
import {
  m as m2
} from "./chunk-CKFS2QIU.js";
import {
  $
} from "./chunk-PI2R2EZ2.js";
import {
  a as a7
} from "./chunk-JLGVQWP5.js";
import "./chunk-LCT65JMM.js";
import "./chunk-IR6JOM7Y.js";
import "./chunk-MK7DDFJN.js";
import {
  j as j2
} from "./chunk-H2PFGMJP.js";
import {
  S
} from "./chunk-OFINLTIW.js";
import "./chunk-TIU3P5HE.js";
import "./chunk-EU5HNJUP.js";
import "./chunk-FFY3IMAS.js";
import "./chunk-2UINVE7X.js";
import {
  F
} from "./chunk-CLMM4HHK.js";
import "./chunk-PTLGJ4Y6.js";
import {
  T as T2
} from "./chunk-VQWEDC6T.js";
import "./chunk-PHSQVJNW.js";
import "./chunk-KFNWBWN4.js";
import "./chunk-K55CXVYD.js";
import "./chunk-G2F62CY5.js";
import "./chunk-Q37ABIVM.js";
import "./chunk-VFMQPCCZ.js";
import {
  S as S2,
  c,
  u as u4
} from "./chunk-63ZT5BWV.js";
import "./chunk-OPQ3FCJ4.js";
import "./chunk-W3BJJE6D.js";
import "./chunk-UZ3YWBWC.js";
import "./chunk-2EOHKZLO.js";
import "./chunk-S7GLMIAQ.js";
import "./chunk-YIVJSMJO.js";
import "./chunk-QMUTCCDX.js";
import "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-LQQCPLIT.js";
import "./chunk-4O46EK5T.js";
import "./chunk-EMULKSUV.js";
import "./chunk-UXVQ5YGS.js";
import {
  R
} from "./chunk-LQYJLB4P.js";
import "./chunk-D6GGPM6D.js";
import "./chunk-FQY65CBA.js";
import "./chunk-HH4Q2NN5.js";
import "./chunk-3CFYBBSV.js";
import {
  t
} from "./chunk-EU64TE5C.js";
import {
  h as h2
} from "./chunk-R25QZWQ7.js";
import "./chunk-BELQIHLO.js";
import "./chunk-BPI4BR4E.js";
import "./chunk-YVMULGDJ.js";
import "./chunk-CJDZN5K5.js";
import "./chunk-N77BULFI.js";
import "./chunk-6TZIEYTZ.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-A6R2FXH6.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-QLKHFYAN.js";
import "./chunk-FV6ZNHFI.js";
import "./chunk-PBKE5BCM.js";
import {
  q
} from "./chunk-FOALQHMM.js";
import "./chunk-7HS3ESHX.js";
import "./chunk-2CS746FZ.js";
import "./chunk-NEI5HAVK.js";
import "./chunk-RCOFAQFP.js";
import "./chunk-CO2J5JPW.js";
import "./chunk-CHAHOTAY.js";
import "./chunk-RZGBA4KS.js";
import "./chunk-FSYN2HHU.js";
import "./chunk-7I4TWCTW.js";
import {
  I as I2,
  g
} from "./chunk-W5UOLFE2.js";
import {
  r as r3
} from "./chunk-AZ2S2PYZ.js";
import "./chunk-SCMB64VM.js";
import {
  n as n2
} from "./chunk-FOPBVVXE.js";
import {
  n
} from "./chunk-INI6MHIQ.js";
import "./chunk-R7YP6EQJ.js";
import "./chunk-QUZZIDFR.js";
import {
  a as a5
} from "./chunk-CBCDVQSA.js";
import {
  V as V2
} from "./chunk-74GULGYB.js";
import "./chunk-RKF6WUZT.js";
import "./chunk-RMRI4NYS.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-BLBN3L5Q.js";
import "./chunk-5EWIWLNU.js";
import {
  p
} from "./chunk-TOCH3L2K.js";
import "./chunk-CBXZL53X.js";
import {
  U,
  l
} from "./chunk-HYAO4PVV.js";
import "./chunk-SRNKPAJX.js";
import "./chunk-MOMLPET6.js";
import "./chunk-VNQUG2TO.js";
import "./chunk-EULNFFHG.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-LPCUYJ2B.js";
import "./chunk-3QHX4R4B.js";
import "./chunk-SMO33YG7.js";
import {
  f
} from "./chunk-LCBAL6ER.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import "./chunk-67AKDROO.js";
import "./chunk-CM3TIXEV.js";
import {
  w
} from "./chunk-2AYGXVZI.js";
import {
  I,
  V
} from "./chunk-OUZJZB6I.js";
import "./chunk-WO5FLTVY.js";
import "./chunk-MGA7XBRB.js";
import "./chunk-XNUSHDFN.js";
import "./chunk-4AKMPOG7.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-APMQAZ5Z.js";
import "./chunk-ZJQPHR3K.js";
import {
  o
} from "./chunk-NJZD7WM5.js";
import {
  r as r2
} from "./chunk-CL7VLXUR.js";
import "./chunk-FCX4ZA3Z.js";
import {
  m2 as m
} from "./chunk-2ZPU5IZX.js";
import {
  a2 as a3,
  u as u3
} from "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import {
  u
} from "./chunk-JNYZ3I5R.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import {
  a as a2,
  h,
  k,
  u2
} from "./chunk-N626Y23H.js";
import {
  a,
  e,
  i3 as i,
  s2 as s
} from "./chunk-TJPLHZCD.js";
import "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/subtypeGroupLayerUtils.js
var f3 = { key: "type", base: a7, errorContext: "renderer", typeMap: { simple: m2, "unique-value": $, "class-breaks": j } };
var i3 = u3({ types: f3 });
function c4(e3, r4) {
  const s3 = e3.drawingInfo?.renderer, o2 = s3 ? i3(s3, e3, r4) : null;
  if ("simple" !== o2?.type) return;
  return w2(o2.symbol, null) ? o2.symbol.clone() : null;
}
var u8 = ["#ed5151", "#149ece", "#a7c636", "#9e559c", "#fc921f", "#ffde3e", "#f789d8", "#b7814a", "#3caf99", "#6b6bd6", "#b54779", "#7f7f7f"];
function a9(r4, s3) {
  return T2(u8, r4, { offset: true, shuffle: true }).reverse().map(((e3) => {
    const r5 = s3.clone();
    return "cim" === r5.type ? k3(r5, e3) : L2(r5, e3), new m2({ symbol: r5 });
  }));
}

// node_modules/@arcgis/core/layers/support/SubtypeSublayer.js
var M = s2();
var U3 = 0;
function k4(e3, t4) {
  let r4 = e3.json.write;
  return "object" != typeof r4 && (r4 = e3.json.write = {}), r4.ignoreOrigin = true, t4?.spatialOnly && (r4.layerContainerTypes = a4), e3;
}
function Q2(e3) {
  const t4 = { write: { ignoreOrigin: true } };
  return e3?.name && (t4.name = e3.name), "object" == typeof t4.write && (e3?.spatialOnly && (t4.write.layerContainerTypes = a4), e3?.target && (t4.write.target = e3.target)), t4;
}
function B2(e3) {
  return new m2({ symbol: H2(e3) });
}
function H2(e3) {
  switch (e3) {
    case "point":
    case "multipoint":
      return S2.clone();
    case "polyline":
      return u4.clone();
    case "polygon":
    case "multipatch":
      return c.clone();
    default:
      return null;
  }
}
function J(e3, t4) {
  return !!t4 && ("unique-value" === e3?.type && null != e3.field && e3.field.toLowerCase() === t4.toLowerCase() && !e3.field2 && !e3.field3 && !e3.valueExpression);
}
function W(e3, t4) {
  return null == e3 ? null : t4.subtypes?.find(((t5) => t5.code === e3));
}
function z(e3, t4) {
  let r4 = null;
  switch (t4.geometryType) {
    case "esriGeometryPoint":
    case "esriGeometryMultipoint":
      r4 = "point";
      break;
    case "esriGeometryPolyline":
      r4 = "line";
      break;
    case "esriGeometryPolygon":
    case "esriGeometryMultiPatch":
      r4 = "polygon";
      break;
    default:
      t4.type, r4 = null;
  }
  const i4 = {}, o2 = W(e3, t4);
  if (null != o2) {
    const { defaultValues: e4 } = o2;
    for (const t5 in e4) i4[t5] = e4[t5];
  }
  return i4[t4.subtypeField] = e3, new a8({ name: "New Feature", drawingTool: r4, prototype: { attributes: i4 } });
}
var K = class extends S(a5.ClonableMixin(n.IdentifiableMixin(p))) {
  constructor(e3) {
    super(e3), this.attributeTableTemplate = null, this.charts = null, this.editingEnabled = true, this.fieldOverrides = null, this.fieldsIndex = null, this.formTemplate = null, this.id = `${Date.now().toString(16)}-subtype-sublayer-${U3++}`, this.type = "subtype-sublayer", this.labelsVisible = true, this.labelingInfo = null, this.layerType = "ArcGISFeatureLayer", this.legendEnabled = true, this.listMode = "show", this.minScale = 0, this.maxScale = 0, this.opacity = 1, this.parent = null, this.popupEnabled = true, this.popupTemplate = null, this.subtypeCode = null, this.templates = null, this.title = null, this.visible = true;
  }
  load(e3) {
    return g(this.renderer, this.fieldsIndex), Promise.resolve(this);
  }
  get _titleCreator() {
    const e3 = this._get("_titleCreator");
    return u2(e3), new u6({ fieldsIndex: this.fieldsIndex, objectIdField: this.objectIdField, displayField: this.parent?.displayField ?? "", fields: this.fields, effectivePopupTemplate: this.popupTemplate ?? this.defaultPopupTemplate });
  }
  get capabilities() {
    return this.parent?.capabilities;
  }
  get effectiveCapabilities() {
    return this.parent?.effectiveCapabilities;
  }
  get effectiveEditingEnabled() {
    const { parent: e3 } = this;
    return e3 ? e3.effectiveEditingEnabled && this.editingEnabled : this.editingEnabled;
  }
  get elevationInfo() {
    return this.parent?.elevationInfo;
  }
  get featureTitleFields() {
    return [...this._titleCreator.requiredFields];
  }
  writeFieldOverrides(e3, t4, r4) {
    const { fields: i4, parent: o2 } = this;
    let l5;
    if (i4) {
      l5 = [];
      let e4 = 0;
      i4.forEach((({ name: t5, alias: r5, editable: i5, visible: n3 }) => {
        if (!n3) return;
        const s3 = o2?.fields?.find(((e5) => e5.name === t5));
        if (!s3) return;
        const a10 = { name: t5 };
        let p5 = false;
        r5 !== s3.alias && (a10.alias = r5, p5 = true), i5 !== s3.editable && (a10.editable = i5, p5 = true), l5.push(a10), p5 && e4++;
      })), 0 === e4 && l5.length === i4.length && (l5 = null);
    } else l5 = a(e3);
    l5?.length && e(r4, l5, t4);
  }
  get fields() {
    const { parent: e3, fieldOverrides: t4, subtypeCode: r4 } = this, i4 = e3?.fields;
    if (!e3 || !i4?.length) return null;
    const { subtypes: o2, subtypeField: n3 } = e3, l5 = o2?.find(((e4) => e4.code === r4)), s3 = l5?.defaultValues, a10 = l5?.domains, p5 = [];
    for (const d2 of i4) {
      const e4 = d2.clone(), { name: i5 } = e4, o3 = t4?.find(((e5) => e5.name === i5));
      if (e4.visible = !t4?.length || !!o3, o3) {
        const { alias: t5, editable: r5 } = o3;
        t5 && (e4.alias = t5), false === r5 && (e4.editable = false);
      }
      const l6 = s3?.[i5] ?? null;
      e4.defaultValue = i5 === n3 ? r4 : l6;
      const u9 = a10?.[i5] ?? null;
      e4.domain = i5 === n3 ? null : u9 ? "inherited" === u9.type ? e4.domain : u9.clone() : null, p5.push(e4);
    }
    return p5;
  }
  get floorInfo() {
    return this.parent?.floorInfo;
  }
  get isTable() {
    return !!this.parent?.isTable;
  }
  get geometryType() {
    return this.parent?.geometryType;
  }
  get globalIdField() {
    return this.parent ? this.parent.globalIdField : (i.getLogger(this).error(Z("globalIdField")), null);
  }
  get effectiveScaleRange() {
    const { minScale: e3, maxScale: t4 } = this;
    return { minScale: e3, maxScale: t4 };
  }
  get objectIdField() {
    return this.parent || i.getLogger(this).error(Z("objectIdField")), this.parent?.objectIdField;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get relationships() {
    return this.parent?.relationships;
  }
  set renderer(e3) {
    g(e3, this.fieldsIndex), this._override("renderer", e3);
  }
  get renderer() {
    if (this._isOverridden("renderer")) return this._get("renderer");
    const { parent: e3 } = this;
    return e3 && !e3.isTable && "mesh" !== e3.geometryType ? B2(e3.geometryType) : null;
  }
  readRendererFromService(e3, t4, r4) {
    if ("Table" === t4.type) return null;
    const i4 = t4.drawingInfo?.renderer, o2 = i3(i4, t4, r4);
    let n3;
    const { subtypeCode: l5 } = this;
    if (null != l5 && J(o2, t4.subtypeField)) {
      const e4 = o2.uniqueValueInfos?.find((({ value: e5 }) => (e5 = "number" == typeof e5 ? String(e5) : e5) === String(l5)));
      e4 && (n3 = new m2({ symbol: e4.symbol }));
    } else "simple" !== o2?.type || o2.visualVariables?.length || (n3 = o2);
    return n3;
  }
  readRenderer(e3, t4, r4) {
    const i4 = t4?.layerDefinition?.drawingInfo?.renderer;
    if (!i4) return;
    const o2 = i4.visualVariables?.some(((e4) => "rotationInfo" !== e4.type));
    return o2 ? void 0 : i3(i4, t4, r4) || void 0;
  }
  get spatialReference() {
    return this.parent?.spatialReference ?? f.WGS84;
  }
  get subtypeField() {
    return this.parent?.subtypeField;
  }
  readTemplatesFromService(e3, t4) {
    return [z(this.subtypeCode, t4)];
  }
  readTitleFromService(e3, t4) {
    const r4 = W(this.subtypeCode, t4);
    return null != r4 ? r4.name : null;
  }
  get url() {
    return this.parent?.url;
  }
  get userHasUpdateItemPrivileges() {
    return !!this.parent?.userHasUpdateItemPrivileges;
  }
  async addAttachment(e3, t4) {
    const { parent: r4 } = this;
    if (!r4) throw Z("addAttachment");
    if (e3.getAttribute(r4.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:addAttachment", "The feature provided does not belong to this SubtypeSublayer");
    return r4.addAttachment(e3, t4);
  }
  async updateAttachment(e3, t4, r4) {
    const { parent: o2 } = this;
    if (!o2) throw Z("updateAttachment");
    if (e3.getAttribute(o2.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:updateAttachment", "The feature provided does not belong to this SubtypeSublayer");
    return o2.updateAttachment(e3, t4, r4);
  }
  async deleteAttachments(e3, t4) {
    const { parent: r4 } = this;
    if (!r4) throw Z("deleteAttachments");
    if (e3.getAttribute(r4.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:deleteAttachments", "The feature provided does not belong to this SubtypeSublayer");
    return r4.deleteAttachments(e3, t4);
  }
  async applyEdits(e3, t4) {
    if (!this.parent) throw Z("applyEdits");
    return this.parent.applyEdits(e3, t4);
  }
  createPopupTemplate(e3) {
    let t4 = this;
    const { parent: r4, fields: i4, title: o2 } = this;
    if (r4) {
      const { displayField: e4, editFieldsInfo: n3, objectIdField: l5 } = r4;
      t4 = { displayField: e4, editFieldsInfo: n3, fields: i4, objectIdField: l5, title: o2 };
    }
    return p3(t4, e3);
  }
  createQuery() {
    if (!this.parent) throw Z("createQuery");
    const e3 = R2(this.parent), t4 = `${this.parent.subtypeField}=${this.subtypeCode}`;
    return e3.where = r3(t4, this.parent.definitionExpression), e3;
  }
  getFeatureTitle(e3, t4) {
    return this._titleCreator.getTitle(this, e3, t4);
  }
  getFeatureTitles(e3, t4) {
    return this._titleCreator.getTitles(this, e3, t4);
  }
  getField(e3) {
    return this.fieldsIndex.get(e3);
  }
  getFieldDomain(e3, t4) {
    if (!t4?.excludeImpliedDomains && this.parent) {
      const t5 = U2(this.parent, e3);
      if (t5) return t5;
    }
    return this._getLayerDomain(e3);
  }
  async queryAttachments(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryAttachments");
    const i4 = e3.clone();
    return i4.where = Y2(i4.where, r4.parent.subtypeField, r4.subtypeCode), r4.parent.queryAttachments(e3, t4);
  }
  async queryFeatureCount(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryFeatureCount");
    return r4.parent.queryFeatureCount(X(r4.parent, r4, e3), t4);
  }
  async queryFeatures(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryFeatures");
    return r4.parent.queryFeatures(X(r4.parent, r4, e3), t4);
  }
  async queryObjectIds(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryObjectIds");
    return r4.parent.queryObjectIds(X(r4.parent, r4, e3), t4);
  }
  async queryRelatedFeatures(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryRelatedFeatures");
    return r4.parent.queryRelatedFeatures(e3, t4);
  }
  async queryRelatedFeaturesCount(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Z("queryRelatedFeaturesCount");
    return r4.parent.queryRelatedFeaturesCount(e3, t4);
  }
  _getLayerDomain(e3) {
    const t4 = this.fieldsIndex.get(e3);
    return t4 ? t4.domain : null;
  }
};
r([m({ clonable: false, readOnly: true })], K.prototype, "_titleCreator", null), r([m({ type: c3, json: Q2({ name: "attributeTableInfo" }) })], K.prototype, "attributeTableTemplate", void 0), r([m({ readOnly: true, json: { read: false } })], K.prototype, "capabilities", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "effectiveCapabilities", null), r([m({ json: Q2() })], K.prototype, "charts", void 0), r([m({ type: Boolean, nonNullable: true, json: Q2({ name: "enableEditing" }) })], K.prototype, "editingEnabled", void 0), r([m({ type: Boolean, readOnly: true })], K.prototype, "effectiveEditingEnabled", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "elevationInfo", null), r([m({ clonable: false, readOnly: true })], K.prototype, "featureTitleFields", null), r([m({ json: { name: "layerDefinition.fieldOverrides", origins: { service: { read: false } }, write: { ignoreOrigin: true, allowNull: true } } })], K.prototype, "fieldOverrides", void 0), r([r2("fieldOverrides")], K.prototype, "writeFieldOverrides", null), r([m({ ...M.fields, readOnly: true, json: { read: false } })], K.prototype, "fields", null), r([m(M.fieldsIndex)], K.prototype, "fieldsIndex", void 0), r([m({ readOnly: true, json: { read: false } })], K.prototype, "floorInfo", null), r([m({ type: V3, json: Q2({ name: "formInfo" }) })], K.prototype, "formTemplate", void 0), r([m({ type: String, clonable: false, json: { origins: { service: { read: false }, "portal-item": { read: false } }, write: { ignoreOrigin: true } } })], K.prototype, "id", void 0), r([m({ readOnly: true, json: { read: false } })], K.prototype, "isTable", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "geometryType", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "globalIdField", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "type", void 0), r([m(k4(a(p4)))], K.prototype, "labelsVisible", void 0), r([m({ type: [A2], json: { name: "layerDefinition.drawingInfo.labelingInfo", origins: { service: { read: false } }, read: { reader: l3 }, write: { ignoreOrigin: true, layerContainerTypes: a4 } } })], K.prototype, "labelingInfo", void 0), r([m({ type: ["ArcGISFeatureLayer"], readOnly: true, json: { read: false, write: { ignoreOrigin: true, layerContainerTypes: a4 } } })], K.prototype, "layerType", void 0), r([m(k4(a(d)))], K.prototype, "legendEnabled", void 0), r([m({ type: ["show", "hide"] })], K.prototype, "listMode", void 0), r([m((() => {
  const e3 = a(j3);
  return e3.json.origins.service.read = false, k4(e3, { spatialOnly: true });
})())], K.prototype, "minScale", void 0), r([m((() => {
  const e3 = a(v2);
  return e3.json.origins.service.read = false, k4(e3, { spatialOnly: true });
})())], K.prototype, "maxScale", void 0), r([m({ readOnly: true })], K.prototype, "effectiveScaleRange", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "objectIdField", null), r([m({ type: Number, range: { min: 0, max: 1 }, nonNullable: true, json: Q2({ spatialOnly: true }) })], K.prototype, "opacity", void 0), r([m({ clonable: false })], K.prototype, "parent", void 0), r([m(k4(a(l4)))], K.prototype, "popupEnabled", void 0), r([m({ type: q, json: Q2({ name: "popupInfo" }) })], K.prototype, "popupTemplate", void 0), r([m({ readOnly: true })], K.prototype, "defaultPopupTemplate", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "relationships", null), r([m({ types: f3, json: Q2({ target: "layerDefinition.drawingInfo.renderer", spatialOnly: true }) })], K.prototype, "renderer", null), r([o("service", "renderer", ["drawingInfo.renderer", "subtypeField", "type"])], K.prototype, "readRendererFromService", null), r([o("renderer", ["layerDefinition.drawingInfo.renderer"])], K.prototype, "readRenderer", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "spatialReference", null), r([m({ type: Number, json: { origins: { service: { read: false } }, write: { ignoreOrigin: true } } })], K.prototype, "subtypeCode", void 0), r([m({ readOnly: true, json: { read: false } })], K.prototype, "subtypeField", null), r([m({ type: [a8], json: Q2({ name: "layerDefinition.templates" }) })], K.prototype, "templates", void 0), r([o("service", "templates", ["geometryType", "subtypeField", "subtypes", "type"])], K.prototype, "readTemplatesFromService", null), r([m({ type: String, json: Q2() })], K.prototype, "title", void 0), r([o("service", "title", ["subtypes"])], K.prototype, "readTitleFromService", null), r([m({ readOnly: true, json: { read: false } })], K.prototype, "url", null), r([m({ readOnly: true })], K.prototype, "userHasUpdateItemPrivileges", null), r([m({ type: Boolean, nonNullable: true, json: Q2({ name: "visibility", spatialOnly: true }) })], K.prototype, "visible", void 0), K = r([a3("esri.layers.support.SubtypeSublayer")], K);
var X = (e3, t4, r4) => {
  if (!r4) return t4.createQuery();
  const i4 = R.from(r4);
  return i4.where = Y2(i4.where, e3.subtypeField, t4.subtypeCode), i4;
};
var Y2 = (e3, t4, r4) => {
  const i4 = new RegExp(`${t4}\\s*=\\s*\\d+`), o2 = `${t4}=${r4}`, n3 = e3 ?? "";
  return i4.test(n3) ? n3.replace(i4, o2) : r3(o2, n3);
};
var Z = (e3) => new s("subtype-sublayer:parent-missing", `This sublayer must have a parent SubtypeGroupLayer in order to use ${e3}`);

// node_modules/@arcgis/core/layers/SubtypeGroupLayer.js
var ae = "SubtypeGroupLayer";
function ne(e3, t4) {
  return new s("layer:unsupported", `Layer (${e3.title}, ${e3.id}) of type '${e3.declaredClass}' ${t4}`, { layer: e3 });
}
function ue(e3, t4) {
  const r4 = [];
  for (const s3 of e3) {
    const e4 = new K();
    e4.read(s3, t4), r4.push(e4);
  }
  return r4;
}
var le = s2();
function pe() {
  return { name: "layerType", read: { enabled: true }, write: { enabled: true, ignoreOrigin: true, isRequired: true } };
}
var ye = class extends k2(a6(F(p2(c2(t2(f2(l2(b(j2(S(e2(i2(a5.ClonableMixin(h2)))))))))))))) {
  constructor(...e3) {
    super(...e3), this._sublayerLookup = /* @__PURE__ */ new Map(), this.fields = null, this.fieldsIndex = null, this.outFields = null, this.sublayers = new (V2.ofType(K))(), this.useUniqueColorsForSublayers = true, this.supportedSourceTypes = /* @__PURE__ */ new Set(["Feature Layer", "Table"]), this.timeInfo = null, this.title = "Layer", this.type = "subtype-group", this._debouncedSaveOperations = k((async (e4, t4, r4) => {
      const { save: s3, saveAs: i4 } = await import("./featureLayerUtils-2BYAEBFM.js");
      switch (e4) {
        case A3.SAVE:
          return s3(this, t4);
        case A3.SAVE_AS:
          return i4(this, r4, t4);
      }
    })), this.addHandles(l((() => this.sublayers), ((e4, t4) => this._handleSublayersChange(e4, t4)), U));
  }
  destroy() {
    this.source?.destroy();
  }
  normalizeCtorArgs(e3, t4) {
    return "string" == typeof e3 ? { url: e3, ...t4 } : e3;
  }
  load(e3) {
    const t4 = null != e3 ? e3.signal : null, r4 = this.loadFromPortal({ supportedTypes: ["Feature Service"] }, e3).catch(a2).then((async () => {
      if (!this.url) throw new s("subtype-grouplayer:missing-url-or-source", "SubtypeGroupLayer must be created with either a url or a portal item");
      if (null == this.layerId) throw new s("subtype-grouplayer:missing-layerid", "layerId is required for a SubtypeGroupLayer created with url");
      return this._initLayerProperties(await this.createGraphicsSource(t4));
    })).then((() => H(this, "load", e3)));
    return this.addResolvingPromise(r4), Promise.resolve(this);
  }
  get createQueryVersion() {
    return this.commitProperty("definitionExpression"), this.commitProperty("timeExtent"), this.commitProperty("timeOffset"), this.commitProperty("geometryType"), this.commitProperty("gdbVersion"), this.commitProperty("historicMoment"), this.commitProperty("returnZ"), this.commitProperty("capabilities"), this.commitProperty("returnM"), (this._get("createQueryVersion") ?? 0) + 1;
  }
  get editingEnabled() {
    return this.loaded && null != this.capabilities && this.capabilities.operations.supportsEditing && this.userHasEditingPrivileges;
  }
  get effectiveEditingEnabled() {
    return Y(this);
  }
  get operationalLayerType() {
    return this.isTable ? "SubtypeGroupTable" : "SubtypeGroupLayer";
  }
  get parsedUrl() {
    const e3 = I(this.url);
    return null != e3 && null != this.layerId && (e3.path = V(e3.path, this.layerId.toString())), e3;
  }
  set source(e3) {
    this._get("source") !== e3 && this._set("source", e3);
  }
  readTitleFromService(e3, { name: t4 }) {
    return this.url ? w(this.url, t4) : t4;
  }
  async addAttachment(e3, t4) {
    const r4 = await F2(this, e3, t4, ae);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r4;
  }
  async updateAttachment(e3, t4, r4) {
    const s3 = await P(this, e3, t4, r4, ae);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), s3;
  }
  async applyEdits(e3, t4) {
    return q2(this, e3, t4);
  }
  on(e3, t4) {
    return super.on(e3, t4);
  }
  async createGraphicsSource(e3) {
    const { default: t4 } = await h(import("./FeatureLayerSource-ZO2IUMXY.js"), e3);
    return new t4({ layer: this, supportedSourceTypes: this.supportedSourceTypes }).load({ signal: e3 });
  }
  createQuery() {
    const e3 = R2(this), t4 = this.sublayers.map(((e4) => e4.subtypeCode));
    return e3.where = r3(`${this.subtypeField} IN (${t4.join(",")})`, this.definitionExpression), e3;
  }
  async deleteAttachments(e3, t4) {
    const r4 = await v(this, e3, t4, ae);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r4;
  }
  async fetchRecomputedExtents(e3) {
    return O(this, e3, ae);
  }
  findSublayerForFeature(e3) {
    const t4 = this.fieldsIndex.get(this.subtypeField), r4 = e3.attributes[t4.name];
    return this.findSublayerForSubtypeCode(r4);
  }
  findSublayerForSubtypeCode(e3) {
    return this._sublayerLookup.get(e3);
  }
  getFieldDomain(e3, t4) {
    if (!t4?.excludeImpliedDomains) {
      const t5 = U2(this, e3);
      if (t5) return t5;
    }
    const r4 = Q(this, t4?.feature);
    if (r4) {
      const t5 = r4.domains?.[e3];
      return "inherited" === t5?.type ? this._getLayerDomain(e3) : t5;
    }
    return this._getLayerDomain(e3);
  }
  loadAll() {
    return t(this, ((e3) => {
      e3(this.sublayers);
    }));
  }
  async queryAttachments(e3, t4) {
    return A(this, e3, t4, ae);
  }
  async queryFeatures(e3, t4) {
    const r4 = await this.load(), s3 = R.from(e3) ?? r4.createQuery(), i4 = s3.outFields ?? [];
    i4.includes(this.subtypeField) || (i4.push(this.subtypeField), s3.outFields = i4);
    const o2 = await r4.source.queryFeatures(s3, t4);
    if (o2?.features) for (const a10 of o2.features) a10.layer = a10.sourceLayer = this.findSublayerForFeature(a10);
    return o2;
  }
  async queryObjectIds(e3, t4) {
    return (await L(this, e3, t4, ae)).filter(n2);
  }
  async queryFeatureCount(e3, t4) {
    return E(this, e3, t4, ae);
  }
  async queryExtent(e3, t4) {
    return D(this, e3, t4, ae);
  }
  async queryRelatedFeatures(e3, t4) {
    return T(this, e3, t4, ae);
  }
  async queryRelatedFeaturesCount(e3, t4) {
    return C(this, e3, t4, ae);
  }
  async save(e3) {
    return this._debouncedSaveOperations(A3.SAVE, e3);
  }
  async saveAs(e3, t4) {
    return this._debouncedSaveOperations(A3.SAVE_AS, t4, e3);
  }
  write(e3, t4) {
    const { origin: r4, layerContainerType: i4, messages: o2 } = t4;
    if (this.isTable) {
      if ("web-scene" === r4 || "web-map" === r4 && "tables" !== i4) return o2?.push(ne(this, "using a table source cannot be written to web scenes and web maps")), null;
    } else if (this.loaded && "web-map" === r4 && "tables" === i4) return o2?.push(ne(this, "using a non-table source cannot be written to tables in web maps")), null;
    return this.sublayers?.length ? super.write(e3, t4) : (o2?.push(new s("web-document-write:invalid-property", `Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' has invalid value for 'sublayers' property. 'sublayers' collection should contain at least one sublayer`, { layer: this })), null);
  }
  serviceSupportsSpatialReference(e3) {
    return !!this.loaded && t3(this, e3);
  }
  async getFeatureTitle(e3, t4) {
    const r4 = this.findSublayerForFeature(e3);
    return r4 ? await r4.getFeatureTitle(e3, t4) : this._getFeatureTitleForUnknownSublayer(e3);
  }
  async getFeatureTitles(e3, t4) {
    const r4 = /* @__PURE__ */ new Map(), s3 = /* @__PURE__ */ new Map(), i4 = [s3];
    e3.forEach(((e4) => {
      const t5 = this.findSublayerForFeature(e4);
      if (t5) u(r4, t5, (() => [])).push(e4);
      else {
        const t6 = e4.getObjectId() ?? e4.attributes[this.objectIdField];
        s3.set(t6, this._getFeatureTitleForUnknownSublayer(e4));
      }
    }));
    const a10 = await Promise.all(Array.from(r4).map((([e4, r5]) => e4.getFeatureTitles(r5, t4))));
    return a10.forEach(((e4) => i4.push(e4))), new Map(i4.flatMap(((e4) => [...e4])));
  }
  get featureTitleFields() {
    const e3 = /* @__PURE__ */ new Set();
    for (const t4 of this.sublayers) {
      const r4 = t4.featureTitleFields;
      for (const t5 of r4) e3.add(t5);
    }
    return [...e3];
  }
  _getLayerDomain(e3) {
    const t4 = this.fieldsIndex.get(e3);
    return t4 ? t4.domain : null;
  }
  async _initLayerProperties(e3) {
    this._set("source", e3);
    const { sourceJSON: t4 } = e3;
    if (t4 && (this.sourceJSON = t4, this.read(t4, { origin: "service", url: this.parsedUrl })), !this.subtypes?.length) throw new s("subtype-grouplayer:missing-subtypes", "SubtypeGroupLayer must be created using a layer with subtypes");
    this._verifyFields(), I2(this.timeInfo, this.fieldsIndex);
  }
  async hasDataChanged() {
    return B(this);
  }
  _verifyFields() {
    const e3 = this.parsedUrl?.path ?? "undefined";
    this.objectIdField || console.log("SubtypeGroupLayer: 'objectIdField' property is not defined (url: " + e3 + ")"), this.isTable || -1 !== e3.search(/\/FeatureServer\//i) || this.fields?.some(((e4) => "geometry" === e4.type)) || console.log("SubtypeGroupLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " + e3 + ")");
  }
  _handleSublayersChange(e3, t4) {
    t4 && (t4.forEach(((e4) => {
      e4.parent = null;
    })), this.removeHandles("sublayers-owner"), this._sublayerLookup.clear()), e3 && (e3.forEach(((e4) => {
      e4.parent = this, this._sublayerLookup.set(e4.subtypeCode, e4);
    })), this.addHandles([e3.on("after-add", (({ item: e4 }) => {
      e4.parent = this, this._sublayerLookup.set(e4.subtypeCode, e4);
    })), e3.on("after-remove", (({ item: e4 }) => {
      e4.parent = null, this._sublayerLookup.delete(e4.subtypeCode);
    }))], "sublayers-owner"));
  }
  _getFeatureTitleForUnknownSublayer(e3) {
    const { displayField: t4, fieldsIndex: r4, objectIdField: s3 } = this;
    if (t4 && r4.has(t4)) return e3.attributes[r4.get(t4).name] ?? "";
    const i4 = e3.getObjectId();
    return null != i4 ? i4.toString() : s3 && r4.has(s3) ? e3.attributes[r4.get(s3).name] ?? "" : "";
  }
};
r([m({ readOnly: true })], ye.prototype, "createQueryVersion", null), r([m({ readOnly: true })], ye.prototype, "editingEnabled", null), r([m({ readOnly: true })], ye.prototype, "effectiveEditingEnabled", null), r([m({ ...le.fields, readOnly: true, json: { origins: { service: { read: true } }, read: false } })], ye.prototype, "fields", void 0), r([m(le.fieldsIndex)], ye.prototype, "fieldsIndex", void 0), r([m(u7)], ye.prototype, "id", void 0), r([m({ type: ["show", "hide", "hide-children"], json: { origins: { "portal-item": { read: false, write: false } } } })], ye.prototype, "listMode", void 0), r([m({ type: ["SubtypeGroupLayer", "SubtypeGroupTable"], json: { ...pe(), origins: { "web-document": pe(), "portal-item": pe() } } })], ye.prototype, "operationalLayerType", null), r([m(le.outFields)], ye.prototype, "outFields", void 0), r([m({ readOnly: true })], ye.prototype, "parsedUrl", null), r([m({ clonable: false })], ye.prototype, "source", null), r([m({ type: V2.ofType(K), json: { origins: { service: { read: { source: "subtypes", reader(e3, t4, s3) {
  let i4 = null;
  if (this.useUniqueColorsForSublayers) {
    const r4 = c4(t4, s3);
    i4 = r4 ? a9(e3.length, r4) : null;
  }
  const o2 = e3.map((({ code: e4 }, r4) => {
    const o3 = new K({ subtypeCode: e4 });
    o3.read(t4, s3);
    const a10 = i4?.[r4];
    return a10 && o3.read({ drawingInfo: { renderer: a10.toJSON() } }, s3), o3;
  }));
  return new (V2.ofType(K))(o2);
} } } }, read: { source: ["layers", "tables"], reader(e3, t4, s3) {
  let i4;
  return "SubtypeGroupLayer" === t4.layerType && t4.layers?.length ? i4 = ue(t4.layers, s3) : "SubtypeGroupTable" === t4.layerType && t4.tables?.length && (i4 = ue(t4.tables, s3)), new (V2.ofType(K))(i4);
} }, write: { ignoreOrigin: true, writer(e3, t4, r4, s3) {
  const i4 = [];
  for (const o2 of e3) {
    const e4 = o2.write({}, s3);
    i4.push(e4);
  }
  this.isTable ? t4.tables = i4 : t4.layers = i4;
} } } })], ye.prototype, "sublayers", void 0), r([m()], ye.prototype, "useUniqueColorsForSublayers", void 0), r([m({ type: u5 })], ye.prototype, "timeInfo", void 0), r([m({ json: { origins: { "portal-item": { write: { enabled: true, ignoreOrigin: true, writerEnsuresNonNull: true } } } } })], ye.prototype, "title", void 0), r([o("service", "title", ["name"])], ye.prototype, "readTitleFromService", null), r([m({ json: { read: false } })], ye.prototype, "type", void 0), r([m({ clonable: false, readOnly: true })], ye.prototype, "featureTitleFields", null), ye = r([a3("esri.layers.SubtypeGroupLayer")], ye);
var de = ye;
export {
  de as default
};
//# sourceMappingURL=SubtypeGroupLayer-YXL25KBN.js.map
