import {
  i as i2,
  o
} from "./chunk-4LBEEPO7.js";
import "./chunk-AJW4U775.js";
import "./chunk-NYQFXO4S.js";
import "./chunk-M4WI67SO.js";
import {
  t
} from "./chunk-YKE7YQGP.js";
import "./chunk-CRVQAW6F.js";
import "./chunk-3KDNHMA3.js";
import {
  E,
  y as y3
} from "./chunk-BUFMNTUX.js";
import "./chunk-37USNU2Q.js";
import "./chunk-YERTKO74.js";
import {
  A
} from "./chunk-VFKFSI5B.js";
import "./chunk-SZ4I37ZN.js";
import {
  y as y2
} from "./chunk-WHNSSW5C.js";
import "./chunk-RHVCSVQD.js";
import "./chunk-MJTI6OYZ.js";
import "./chunk-3YBQQHIP.js";
import "./chunk-OJQCHQYS.js";
import {
  a as a3
} from "./chunk-OUBBZ23V.js";
import "./chunk-TOD32WVA.js";
import "./chunk-DTPLSS5W.js";
import "./chunk-HPADPQJ7.js";
import "./chunk-PHSQVJNW.js";
import "./chunk-KFNWBWN4.js";
import "./chunk-K55CXVYD.js";
import "./chunk-3JKWT76Y.js";
import "./chunk-LOLNWH3R.js";
import {
  i,
  n,
  r as r2
} from "./chunk-MC5GPFEL.js";
import "./chunk-UZ3YWBWC.js";
import "./chunk-2EOHKZLO.js";
import {
  u
} from "./chunk-5ZA2FFGW.js";
import {
  f
} from "./chunk-E3X3R7JS.js";
import "./chunk-5J3DOLRD.js";
import "./chunk-ITDL4YVK.js";
import {
  L as L2
} from "./chunk-LDDUMPNU.js";
import "./chunk-CCQBS25D.js";
import "./chunk-PXNA3G6N.js";
import "./chunk-OUR2XGMQ.js";
import "./chunk-TSHXWKM2.js";
import "./chunk-KZ2G7XW2.js";
import "./chunk-YIVJSMJO.js";
import {
  Z
} from "./chunk-QMUTCCDX.js";
import {
  ut
} from "./chunk-24S6C5S6.js";
import "./chunk-7Y4U2JD3.js";
import {
  s as s2
} from "./chunk-GCTSCKPO.js";
import "./chunk-6U4EGJOK.js";
import "./chunk-W7U4L72B.js";
import "./chunk-OXO3GGCE.js";
import "./chunk-BOPGQCAL.js";
import "./chunk-C4HV45QS.js";
import "./chunk-FB53UFVR.js";
import "./chunk-UICDKBDP.js";
import "./chunk-HRIEIPLV.js";
import "./chunk-RWNJO2QP.js";
import "./chunk-3M6ALZOH.js";
import "./chunk-QPV4BKBC.js";
import "./chunk-DDDZPNGZ.js";
import "./chunk-XVEUTBL6.js";
import "./chunk-LQQCPLIT.js";
import "./chunk-4O46EK5T.js";
import "./chunk-4R7TSTKL.js";
import "./chunk-UO2UKPG5.js";
import "./chunk-EMULKSUV.js";
import "./chunk-AY3JR4QM.js";
import "./chunk-OTT43TRS.js";
import "./chunk-UNPFUYVY.js";
import "./chunk-3ZX4Y274.js";
import "./chunk-WX3VZIBK.js";
import "./chunk-A2AZM62Y.js";
import "./chunk-2RL34CVC.js";
import "./chunk-BNQMKYX6.js";
import "./chunk-B6C2GOG6.js";
import "./chunk-K3VYMAVM.js";
import {
  h as h3
} from "./chunk-FPALEK52.js";
import "./chunk-LQYJLB4P.js";
import "./chunk-D6GGPM6D.js";
import "./chunk-FQY65CBA.js";
import "./chunk-HH4Q2NN5.js";
import {
  g as g2
} from "./chunk-S5G7D7MX.js";
import "./chunk-6BZTNQVP.js";
import "./chunk-IR4HVW2K.js";
import "./chunk-OT2P27SF.js";
import "./chunk-XJOLJK3F.js";
import "./chunk-3CFYBBSV.js";
import "./chunk-ZVNJ2S2Z.js";
import "./chunk-KPGNM4LZ.js";
import "./chunk-AACFCXAP.js";
import "./chunk-P5DG4SNT.js";
import "./chunk-BPI4BR4E.js";
import {
  d
} from "./chunk-YVMULGDJ.js";
import {
  L,
  O,
  Q
} from "./chunk-CJDZN5K5.js";
import "./chunk-N77BULFI.js";
import "./chunk-6TZIEYTZ.js";
import "./chunk-UMUW6RKM.js";
import "./chunk-XRTNDGK2.js";
import "./chunk-7WPGDYQW.js";
import "./chunk-QDOFETFN.js";
import "./chunk-A6R2FXH6.js";
import "./chunk-H6ZVHKNF.js";
import "./chunk-YAXW2DL6.js";
import "./chunk-MSSQA3XK.js";
import "./chunk-7HS3ESHX.js";
import "./chunk-2CS746FZ.js";
import "./chunk-NEI5HAVK.js";
import "./chunk-RCOFAQFP.js";
import "./chunk-CO2J5JPW.js";
import "./chunk-CHAHOTAY.js";
import {
  y
} from "./chunk-RZGBA4KS.js";
import "./chunk-FSYN2HHU.js";
import "./chunk-7I4TWCTW.js";
import "./chunk-W5UOLFE2.js";
import "./chunk-AZ2S2PYZ.js";
import "./chunk-SCMB64VM.js";
import "./chunk-FOPBVVXE.js";
import "./chunk-R7YP6EQJ.js";
import "./chunk-QUZZIDFR.js";
import "./chunk-CBCDVQSA.js";
import "./chunk-74GULGYB.js";
import "./chunk-RKF6WUZT.js";
import {
  P
} from "./chunk-RMRI4NYS.js";
import "./chunk-YYLIW24Q.js";
import "./chunk-B7BH33JH.js";
import "./chunk-BLBN3L5Q.js";
import "./chunk-5EWIWLNU.js";
import "./chunk-TOCH3L2K.js";
import "./chunk-CBXZL53X.js";
import {
  a as a2,
  h as h2,
  l
} from "./chunk-HYAO4PVV.js";
import "./chunk-SRNKPAJX.js";
import "./chunk-MOMLPET6.js";
import "./chunk-VNQUG2TO.js";
import "./chunk-EULNFFHG.js";
import "./chunk-SDIBXPSJ.js";
import "./chunk-LPCUYJ2B.js";
import "./chunk-3QHX4R4B.js";
import "./chunk-SMO33YG7.js";
import "./chunk-LCBAL6ER.js";
import "./chunk-6JCZVSRM.js";
import "./chunk-LLGOMKTE.js";
import "./chunk-ZB6KRLRI.js";
import "./chunk-67AKDROO.js";
import "./chunk-CM3TIXEV.js";
import "./chunk-2AYGXVZI.js";
import "./chunk-OUZJZB6I.js";
import "./chunk-WO5FLTVY.js";
import "./chunk-MGA7XBRB.js";
import "./chunk-XNUSHDFN.js";
import "./chunk-4AKMPOG7.js";
import "./chunk-2CJBZZN7.js";
import "./chunk-APMQAZ5Z.js";
import "./chunk-ZJQPHR3K.js";
import "./chunk-NJZD7WM5.js";
import "./chunk-CL7VLXUR.js";
import "./chunk-FCX4ZA3Z.js";
import {
  b,
  m2 as m
} from "./chunk-2ZPU5IZX.js";
import {
  a2 as a
} from "./chunk-S62CSPIH.js";
import "./chunk-X26VPODZ.js";
import "./chunk-XNYPRDKK.js";
import "./chunk-JNYZ3I5R.js";
import {
  r
} from "./chunk-Y4BWIIWH.js";
import "./chunk-TTJIKWMC.js";
import "./chunk-CMEG2CKL.js";
import "./chunk-VHPBXBDE.js";
import "./chunk-6ACTD4UJ.js";
import "./chunk-5REYU5G2.js";
import {
  g,
  h,
  s
} from "./chunk-N626Y23H.js";
import "./chunk-TJPLHZCD.js";
import {
  S
} from "./chunk-KLFJ5V5G.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var z = "graphics-collections";
var O2 = class extends b {
  get updating() {
    return this._updatingHandles.updating;
  }
  get _hasZ() {
    const e = this.view;
    return null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type;
    if (!o2 || "map-notes" === t2.type) return i();
    const r3 = async (o3, r4) => (await h(e.whenLayerView(t2), r4)).elevationAlignPointsInFeatures(o3, r4);
    return i(o2, { elevationInfo: t2.elevationInfo, alignPointsInFeatures: r3 });
  }
  get _snappingElevationFilter() {
    const { view: e } = this, t2 = null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
    return r2(t2);
  }
  get _symbologySnappingFetcher() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type, r3 = this._extrudedPolygonSymbolsCount > 0;
    return o2 && "map-notes" !== t2.type && r3 ? n(r3, (async (o3, r4) => {
      const s3 = await e.whenLayerView(t2);
      return s(r4), s3.queryForSymbologySnapping({ candidates: o3, spatialReference: e.spatialReference }, r4);
    })) : n();
  }
  constructor(e) {
    super(e), this.availability = 1, this._sources = { multipoint: null, point: null, polygon: null, polyline: null }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0, this._updatingHandles = new h3(), this._memoizedMakeGetGroundElevation = t(i2);
  }
  destroy() {
    for (const e of this._pendingAdds) e.task.abort();
    this._pendingAdds.length = 0, this._mapSources(((e) => this._destroySource(e))), this._updatingHandles.destroy();
  }
  initialize() {
    this._updatingHandles.add((() => this.getGraphicsLayers()), ((e2) => {
      this._updatingHandles.removeHandles(z);
      for (const t3 of e2) this._addMany(t3.graphics.toArray()), this.addHandles([t3.on("graphic-update", ((e3) => this._onGraphicUpdate(e3))), this._updatingHandles.addOnCollectionChange((() => t3.graphics), ((e3) => this._onGraphicsChanged(e3)))], z);
    }), h2);
    const { view: e } = this, { layer: t2 } = this.layerSource;
    null != e && "3d" === e.type && "map-notes" !== t2.type && e.elevationProvider && this.addHandles([e.elevationProvider.on("elevation-change", (({ context: e2 }) => {
      y2(e2, t2.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    })), l((() => t2.elevationInfo), (() => this._snappingElevationAligner.notifyElevationSourceChange()), h2), a2((() => t2), ["edits", "apply-edits", "graphic-update"], (() => this._symbologySnappingFetcher.notifySymbologyChange()))]);
  }
  async fetchCandidates(e, t2) {
    const { point: o2, coordinateHelper: { spatialReference: r3 } } = e, s3 = await g(this._mapSources(((o3) => this._fetchCandidatesForSource(o3, e, t2))));
    s(t2);
    const a4 = this._memoizedMakeGetGroundElevation(this.view, r3), p = s3.flat().map(((e2) => o(e2, a4)));
    return E(o2, p), p;
  }
  async _fetchCandidatesForSource(e, t2, o2) {
    const r3 = y3({ parameters: t2, mode: this.view?.type ?? "2d" }), s3 = await u(e.queryEngine, r3, o2);
    s(o2);
    const n2 = await this._snappingElevationAligner.alignCandidates(s3.candidates, t2.coordinateHelper.spatialReference, o2);
    s(o2);
    const a4 = await this._symbologySnappingFetcher.fetch(n2, o2);
    s(o2);
    const p = 0 === a4.length ? n2 : [...n2, ...a4];
    return this._snappingElevationFilter.filter(r3, p);
  }
  refresh() {
  }
  _onGraphicUpdate(e) {
    if (this.getGraphicsLayers().some(((t2) => t2.graphics.includes(e.graphic)))) switch (e.property) {
      case "geometry":
      case "visible":
        this._remove(e.graphic), this._addMany([e.graphic]);
    }
  }
  _onGraphicsChanged(e) {
    for (const t2 of e.removed) this._remove(t2);
    this._addMany(e.added);
  }
  _addMany(e) {
    const t2 = [], o2 = /* @__PURE__ */ new Map();
    for (const r3 of e) null != r3.geometry && (this._needsInitializeProjection(r3.geometry.spatialReference) ? (t2.push(r3.geometry.spatialReference), o2.set(r3.uid, r3)) : this._add(r3));
    this._createPendingAdd(t2, o2);
  }
  _createPendingAdd(e, t2) {
    if (!e.length) return;
    const s3 = d((async (o2) => {
      await Q(e.map(((e2) => ({ source: e2, dest: this.spatialReference }))), { signal: o2 }), this._markLoadedSpatialReferences(e);
      for (const e2 of t2.values()) this._add(e2);
    }));
    this._updatingHandles.addPromise(s3.promise);
    const i3 = { task: s3, graphics: t2 }, n2 = () => S(this._pendingAdds, i3);
    s3.promise.then(n2, n2), this._pendingAdds.push(i3);
  }
  _markLoadedSpatialReferences(e) {
    for (const t2 of e) {
      null != t2.wkid && this._loadedWkids.add(t2.wkid);
      const e2 = t2.wkt2 || t2.wkt;
      e2 && this._loadedWkts.add(e2);
    }
  }
  _add(e) {
    if (null == e.geometry || !e.visible) return;
    let t2 = e.geometry;
    if ("mesh" === t2.type) return;
    "extent" === t2.type && (t2 = P.fromExtent(t2));
    const o2 = this._ensureSource(t2.type);
    if (null == o2) return;
    const r3 = this._createOptimizedFeature(e.uid, t2);
    null != r3 && (o2.featureStore.add(r3), A(e.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e) {
    if (null != e.wkid && this._loadedWkids.has(e.wkid)) return false;
    const t2 = e.wkt2 || e.wkt;
    return (!t2 || !this._loadedWkts.has(t2)) && !L(e, this.spatialReference);
  }
  _createOptimizedFeature(e, t2) {
    const o2 = O(a3(t2), this.spatialReference);
    if (!o2) return null;
    const r3 = this._ensureGeometryHasZ(o2), s3 = ut(r3, this._hasZ, false);
    return new s2(s3, { [Z2]: e }, null, e);
  }
  _ensureGeometryHasZ(e) {
    if (!this._hasZ) return e;
    const t2 = (e2) => {
      for (; e2.length < 3; ) e2.push(0);
    }, o2 = e.clone();
    switch (o2.hasZ = true, o2.type) {
      case "point":
        o2.z = o2.z ?? 0;
        break;
      case "multipoint":
        o2.points.forEach(t2);
        break;
      case "polyline":
        o2.paths.forEach(((e2) => e2.forEach(t2)));
        break;
      case "polygon":
        o2.rings.forEach(((e2) => e2.forEach(t2)));
    }
    return o2;
  }
  _ensureSource(e) {
    const t2 = this._sources[e];
    if (null != t2) return t2;
    const o2 = this._createSource(e);
    return this._sources[e] = o2, o2;
  }
  _createSource(e) {
    const t2 = y.toJSON(e), o2 = this._hasZ, r3 = new f({ geometryType: t2, hasZ: o2, hasM: false });
    return { featureStore: r3, queryEngine: new L2({ featureStore: r3, fieldsIndex: Z.fromLayerJSON({ fields: [{ name: Z2, type: "esriFieldTypeOID", alias: Z2 }] }), geometryType: t2, hasM: false, hasZ: o2, featureIdInfo: { type: "object-id", fieldName: Z2 }, spatialReference: this.spatialReference, priority: g2.SNAPPING, scheduler: null != this.view && "3d" === this.view.type ? this.view.resourceController.scheduler : null }), type: e };
  }
  _remove(e) {
    this._mapSources(((t2) => this._removeFromSource(t2, e)));
    for (const t2 of this._pendingAdds) t2.graphics.delete(e.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e, t2) {
    const o2 = t2.uid;
    e.featureStore.has(o2) && (e.featureStore.removeById(t2.uid), A(t2.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e) {
    e.queryEngine.destroy(), this._sources[e.type] = null;
  }
  _mapSources(e) {
    const { point: t2, polygon: o2, polyline: r3, multipoint: s3 } = this._sources, i3 = [];
    return null != t2 && i3.push(e(t2)), null != o2 && i3.push(e(o2)), null != r3 && i3.push(e(r3)), null != s3 && i3.push(e(s3)), i3;
  }
};
r([m()], O2.prototype, "getGraphicsLayers", void 0), r([m({ constructOnly: true })], O2.prototype, "layerSource", void 0), r([m({ constructOnly: true })], O2.prototype, "spatialReference", void 0), r([m({ constructOnly: true })], O2.prototype, "view", void 0), r([m({ readOnly: true })], O2.prototype, "updating", null), r([m({ readOnly: true })], O2.prototype, "availability", void 0), r([m()], O2.prototype, "_hasZ", null), r([m()], O2.prototype, "_snappingElevationAligner", null), r([m()], O2.prototype, "_snappingElevationFilter", null), r([m()], O2.prototype, "_symbologySnappingFetcher", null), r([m()], O2.prototype, "_extrudedPolygonSymbolsCount", void 0), O2 = r([a("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], O2);
var Z2 = "OBJECTID";
export {
  O2 as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-BKS2QZ7C.js.map
