import { isEsriInternalEnv } from "@arcgis/toolkit/error";
const controllerSymbol = Symbol.for("controller");
const isController = (value) => typeof value === "object" && value !== null && (controllerSymbol in value || "hostConnected" in value || "hostDisconnected" in value || "hostUpdate" in value || "hostUpdated" in value);
const isPromise = (arg) => typeof arg?.then === "function";
const getControllersCount = (component) => component.M.length;
let ambientComponent;
const setAmbientComponent = (component) => {
  if (ambientComponent === component) {
    return;
  }
  ambientComponent = component;
  queueMicrotask(() => ambientComponent === component ? ambientComponent = void 0 : 0);
};
const retrieveComponent = (name) => {
  if (process.env.NODE_ENV !== "production" && ambientComponent === void 0) {
    throw new Error(
      [
        `Unable to find out which component ${name || "this"} controller `,
        "belongs to. Possible causes:\n",
        "- You might have multiple versions of ",
        "@arcgis/lumina package installed\n",
        ...isEsriInternalEnv() ? [
          "- You tried to create controller outside the component (in ",
          "non-component class or in global scope).",
          "- You accidentally defined the controller using const a = ",
          "makeController(...); rather than const a = () => ",
          "makeController(...);",
          "- You tried to create a controller inside an async function. ",
          "This is not allowed without calling controller.use(). Make ",
          "sure you use it like `await controller.use(useController())`."
        ] : []
      ].join("")
    );
  }
  return ambientComponent;
};
let ambientControllers = [];
const setParentController = (controller) => {
  if (controller === void 0) {
    ambientControllers = [];
    return;
  }
  const index = ambientControllers.indexOf(controller);
  ambientControllers = index === -1 ? [...ambientControllers, controller] : ambientControllers.slice(0, index + 1);
  queueMicrotask(() => ambientControllers = []);
};
const retrieveParentControllers = () => ambientControllers;
let ambientChildController;
const setAmbientChildController = (controller) => {
  if (ambientChildController === controller) {
    return;
  }
  ambientChildController = controller;
  queueMicrotask(() => ambientChildController === controller ? ambientChildController = void 0 : 0);
};
const retrieveAmbientChildController = () => {
  const controller = ambientChildController;
  ambientChildController = void 0;
  return controller;
};
const use = async (value, watchExports) => {
  const controller = useRefSync(value);
  if (controller === void 0) {
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && typeof watchExports === "function") {
      throw new Error(
        `Unable to resolve a controller from the provided value, so can't watch it's exports. The value you passed is not a controller and not a controller exports. If your controller exports a literal value, try making your controller export an object instead`
      );
    }
    return value;
  }
  await controller.ready;
  if (typeof watchExports === "function") {
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && controller.watchExports === void 0) {
      throw new Error(`The controller must implement watchExports method to support watching exports`);
    }
    const unsubscribe = controller.watchExports(
      (exports) => watchExports(exports, unsubscribe)
    );
  }
  return controller.exports;
};
const useRef = async (value) => {
  const controller = useRefSync(value);
  if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && controller === void 0) {
    throw new Error(
      `Unable to resolve a controller from the provided value. The value you passed is not a controller and not a controller exports. If your controller exports a literal value, try making your controller export an object instead`
    );
  }
  await controller.ready;
  return controller;
};
const useRefSync = (value) => {
  const component = retrieveComponent();
  const controller = component.manager.X(value);
  if (controller !== void 0) {
    return controller;
  }
  if (isController(value)) {
    return value;
  }
  const ambientChildController2 = retrieveAmbientChildController();
  if (ambientChildController2 !== void 0) {
    return ambientChildController2;
  }
  return void 0;
};
let shouldBypassReadOnly = false;
const bypassReadOnly = (callback) => {
  shouldBypassReadOnly = true;
  try {
    return callback();
  } finally {
    shouldBypassReadOnly = false;
  }
};
const bypassSetter = bypassReadOnly;
export {
  shouldBypassReadOnly as a,
  setParentController as b,
  controllerSymbol as c,
  retrieveParentControllers as d,
  bypassSetter as e,
  bypassReadOnly as f,
  isController as g,
  getControllersCount as h,
  isPromise as i,
  setAmbientChildController as j,
  useRef as k,
  useRefSync as l,
  retrieveComponent as r,
  setAmbientComponent as s,
  use as u
};
