import { nil } from '@arcgis/toolkit/type';
import { Properties as CssProperties } from 'csstype';
import { ClassInfo, ClassMapDirective } from 'lit/directives/class-map.js';
import { DirectiveResult, DirectiveClass, ElementPart, PartInfo, Directive } from 'lit/directive.js';
import { StyleMapDirective } from 'lit/directives/style-map.js';
import { noChange } from 'lit';
import { CustomAttributes } from './baseTypes';
import { RefDirective } from 'lit/directives/ref.js';
/**
 * You likely won't have to import this directly. It will be added during
 * _JSX to lit-html_ conversion.
 *
 * @remarks
 * In JSX we allow both of the following:
 * ```tsx
 * const myString = "foo";
 * const myObject = { foo: true, bar: false };
 * render(<p class={myString} />);
 * render(<p class={myObject} />);
 * ```
 *
 * One of the above needs to call `classMap` directive, the other must not.
 *
 * To keep the build fast, and to guard against types being possibly incorrect,
 * we are not relying on the TypeScript type-checker to check if the provided
 * variable is a string or an object.
 * Instead, if the prop value is a object definition, variable reference,
 * ternary expression or etc, the `safeClassMap` will be called, which will
 * determine at runtime if directive should be called
 *
 * @private
 */
export declare const safeClassMap: (parameters: ClassInfo | nil | string) => DirectiveResult<typeof ClassMapDirective> | nil | string;
/**
 * You likely won't have to import this directly. It will be added during
 * _JSX to lit-html_ conversion.
 *
 * @remarks
 * In JSX we allow both of the following:
 * ```tsx
 * const myString = "font-size:'2px'";
 * const myObject = { fontSize: "2px" };
 * render(<p style={myString} />);
 * render(<p style={myObject} />);
 * ```
 *
 * One of the above needs to call `styleMap` directive, the other must not.
 *
 * To keep the build fast, and to guard against types being possibly incorrect,
 * we are not relying on the TypeScript type-checker to check if the provided
 * variable is a string or an object.
 * Instead, if the prop value is a object definition, variable reference,
 * ternary expression or etc, the `safeStyleMap` will be called, which will
 * determine at runtime if directive should be called
 *
 * @private
 */
export declare const safeStyleMap: (parameters: CssProperties | nil | string) => DirectiveResult<typeof StyleMapDirective> | nil | string;
declare class DeferLoad extends Directive {
    update(part: ElementPart): void;
    render(): typeof noChange;
}
/**
 * @private
 * Do not use this directive directly. Use the `deferLoad` JSX prop instead.
 * [Documentation](https://qawebgis.esri.com/components/lumina/jsx#deferring-web-component-load)
 */
export declare const deferLoad: DirectiveResult<typeof DeferLoad>;
/**
 * @private
 * Do not use this directly. Use the `deferLoad` JSX prop instead.
 * [Documentation](https://qawebgis.esri.com/components/lumina/jsx#deferring-web-component-load)
 */
export declare const deferredLoaders: Map<string, () => Promise<unknown>>;
declare class StabilizedRef extends Directive {
    #private;
    constructor(partInfo: PartInfo);
    render(refValue: CustomAttributes<Element>["ref"]): DirectiveResult<typeof RefDirective>;
}
/**
 * Because of how Lit's ref() works, there are two requirements on ref
 * function:
 * - It must be stable between re-renders (else Lit will call it twice on each
 *   render() - with undefined and then with element)
 * - Each element must have a unique instance of this function - if two
 *   elements share the same ref function, on each render Lit will call
 *   it multiple times (undefined, element1, undefined, element2)
 *
 * The `stabilizedRef` directive resolves both of these requirements by creating
 * a stable wrapper function for the ref callback.
 *
 * @private
 * Lumina will insert this directive automatically when the `ref` JSX prop is
 * authored in a way that clearly creates a new function on each render:
 * ```tsx
 * <my-component ref={(el) => this.myComponent = el} />
 * <my-component ref={this.callback.bind(this, index)} />
 * ```
 * @deprecated See https://discord.com/channels/1012791295170859069/1047015641225371718
 */
export declare const stabilizedRef: <T extends Element>(refValue: CustomAttributes<T>["ref"]) => DirectiveResult<typeof StabilizedRef>;
/**
 * Creates a user-facing directive function from a Directive class. This
 * function has the same parameters as the directive's render() method.
 *
 * @remarks
 * This is equivalent to Lit's native "directive()", but has return type
 * "never" to allow it be set as a value for any JSX attribute.
 */
export declare const directive: <C extends DirectiveClass>(c: C) => (...values: Parameters<InstanceType<C>["render"]>) => never;
/**
 * Checks binding values against live DOM values, instead of previously bound
 * values, when determining whether to update the value.
 *
 * @see https://lit.dev/docs/templates/directives/#live
 *
 * @remarks
 * This is equivalent to Lit's native "directive()", but has return type
 * "never" to allow it be set as a value for any JSX attribute.
 */
export declare const live: (value: unknown) => never;
export {};
