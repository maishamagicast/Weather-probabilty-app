/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{ForwardLinearDepth as e}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{Offset as o}from"../views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js";import{isColorOrColorEmission as r}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as i}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as a}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{InstancedDoublePrecision as l}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js";import{NormalAttribute as t}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js";import{SymbolColor as s}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js";import{TextureCoordinateAttribute as n}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js";import{VertexColor as d}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js";import{VerticalOffset as c}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js";import{DefaultMaterialAuxiliaryPasses as g}from"../views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js";import{EvaluateAmbientOcclusion as m}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js";import{EvaluateSceneLighting as v,addAmbientBoostFactor as b,addLightingGlobalFactor as w}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightDirection as p,addMainLightIntensity as u}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{PhysicallyBasedRendering as h}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js";import{PBRMode as f,PhysicallyBasedRenderingParameters as x}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadShadowMapPass as y,ReadShadowMapDraw as C}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as L}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{VisualVariables as j}from"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js";import{DiscardOrAdjustAlphaPass as O}from"../views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlpha.glsl.js";import{MixExternalColor as M}from"../views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js";import{addProjViewLocalOrigin as P,addCameraPosition as S}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float3PassUniform as A}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{Float4PassUniform as E}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as D}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{If as F,glsl as $}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DPassUniform as N}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{SnowCover as I}from"../views/3d/webgl-engine/effects/weather/SnowCover.glsl.js";import{VertexAttribute as T}from"../views/3d/webgl-engine/lib/VertexAttribute.js";import{outputColorHighlightOID as V}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";import{ShaderBuilder as B}from"../views/webgl/ShaderBuilder.js";import{alphaCutoff as R}from"../webscene/support/AlphaCutoff.js";function _(_){const z=new B,{attributes:k,vertex:G,fragment:U,varyings:W}=z,{output:H,offsetBackfaces:q,instancedColor:J,pbrMode:K,snowCover:Q,spherical:X,hasBloom:Y}=_,Z=K===f.Normal||K===f.Schematic;if(P(G,_),k.add(T.POSITION,"vec3"),W.add("vpos","vec3",{invariant:!0}),z.include(j,_),z.include(l,_),z.include(c,_),z.include(L,_),!r(H))return z.include(g,_),z;S(z.vertex,_),z.include(t,_),z.include(a,_),q&&z.include(o),J&&z.attributes.add(T.INSTANCECOLOR,"vec4"),W.add("vNormalWorld","vec3"),W.add("localvpos","vec3",{invariant:!0}),z.include(n,_),z.include(e,_),z.include(s,_),z.include(d,_),G.uniforms.add(new E("externalColor",(e=>e.externalColor))),W.add("vcolorExt","vec4"),G.main.add($`
    forwardNormalizedVertexColor();
    vcolorExt = externalColor;
    ${F(J,"vcolorExt *= instanceColor * 0.003921568627451;")}
    vcolorExt *= vvColor();
    vcolorExt *= getSymbolColor();
    forwardColorMixMode();

    bool alphaCut = vcolorExt.a < ${$.float(R)};
    vpos = getVertexInLocalOriginSpace();
    localvpos = vpos - view[3].xyz;
    vpos = subtractOrigin(vpos);
    vNormalWorld = dpNormal(vvLocalNormal(normalModel()));
    vpos = addVerticalOffset(vpos, localOrigin);
    vec4 basePosition = transformPosition(proj, view, vpos);

    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
    forwardLinearDepth();
    forwardTextureCoordinates();

    gl_Position = alphaCut ? vec4(1e38, 1e38, 1e38, 1.0) :
    ${F(q,"offsetBackfacingClipPosition(basePosition, vpos, vNormalWorld, cameraPosition);","basePosition;")}
  `);const{hasColorTexture:ee,hasColorTextureTransform:oe,receiveShadows:re}=_;return z.include(v,_),U.include(m,_),z.include(O,_),z.include(_.instancedDoublePrecision?y:C,_),U.include(i,_),z.include(V,_),S(U,_),p(U),b(U),w(U),U.uniforms.add(G.uniforms.get("localOrigin"),G.uniforms.get("view"),new A("ambient",(e=>e.ambient)),new A("diffuse",(e=>e.diffuse)),new D("opacity",(e=>e.opacity)),new D("layerOpacity",(e=>e.layerOpacity))),ee&&U.uniforms.add(new N("tex",(e=>e.texture))),z.include(x,_),U.include(h,_),U.include(M),U.include(I,_),u(U),U.main.add($`
    discardBySlice(vpos);
    discardByTerrainDepth();
    vec4 texColor = ${ee?`texture(tex, ${oe?"colorUV":"vuv0"})`:" vec4(1.0)"};
    ${F(ee,`${F(_.textureAlphaPremultiplied,"texColor.rgb /= texColor.a;")}\n      discardOrAdjustAlpha(texColor);`)}
    vec3 viewDirection = normalize(vpos - cameraPosition);
    applyPBRFactors();
    float ssao = evaluateAmbientOcclusionInverse();
    ssao *= getBakedOcclusion();

    float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
    vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
    float shadow = ${re?"max(lightingGlobalFactor * (1.0 - additionalAmbientScale), readShadowMap(vpos, linearDepth))":X?"lightingGlobalFactor * (1.0 - additionalAmbientScale)":"0.0"};
    vec3 matColor = max(ambient, diffuse);
    ${_.hasVertexColors?$`vec3 albedo = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
            float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));`:$`vec3 albedo = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
            float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));`}
    ${F(Q,"albedo = mix(albedo, vec3(1), 0.9);")}
    ${$`vec3 shadingNormal = normalize(vNormalWorld);
            albedo *= 1.2;
            vec3 viewForward = vec3(view[0][2], view[1][2], view[2][2]);
            float alignmentLightView = clamp(dot(viewForward, -mainLightDirection), 0.0, 1.0);
            float transmittance = 1.0 - clamp(dot(viewForward, shadingNormal), 0.0, 1.0);
            float treeRadialFalloff = vColor.r;
            float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);
            additionalLight += backLightFactor * mainLightIntensity;`}
    ${F(Z,`vec3 normalGround = ${X?"normalize(vpos + localOrigin)":"vec3(0.0, 0.0, 1.0)"};`)}
    ${Z?$`float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
                ${F(Q,$`mrr = applySnowToMRR(mrr, 1.0);`)}
          vec4 emission = ${Q||Y?"vec4(0.0)":"getEmissions(albedo)"};
          vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);`:$`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
    vec4 finalColor = vec4(shadedColor, opacity_);
    outputColorHighlightOID(finalColor, vpos, albedo ${F(Q,", 1.0")});`),z.include(g,_),z}const z=Object.freeze(Object.defineProperty({__proto__:null,build:_},Symbol.toStringTag,{value:"Module"}));export{z as R,_ as b};
