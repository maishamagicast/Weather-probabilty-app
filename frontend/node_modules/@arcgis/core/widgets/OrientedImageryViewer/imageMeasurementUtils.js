/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{rad2deg as t}from"../../core/mathUtils.js";import{throwIfAborted as e}from"../../core/promiseUtils.js";import{formatArea as n,formatLength as r}from"../../core/quantityFormatUtils.js";import{createArea as a,createLength as o}from"../../core/quantityUtils.js";import{set as i,determinant as s}from"../../core/libs/gl-matrix-2/math/mat3.js";import{create as c}from"../../core/libs/gl-matrix-2/factories/mat3f64.js";import{zeros as u,fromValues as l}from"../../core/libs/gl-matrix-2/factories/vec3f64.js";import{distance as f}from"../../core/libs/gl-matrix-2/math/vec2.js";import{i as m,h as p,a as h}from"../../chunks/vec32.js";import y from"../../geometry/Point.js";import g from"../../geometry/Polygon.js";import x from"../../geometry/Polyline.js";import{projectWithZConversion as w,project as M}from"../../geometry/projectionUtils.js";import R from"../../geometry/SpatialReference.js";import{e as z}from"../../chunks/areaOperator.js";import{l as d,e as P}from"../../chunks/geodeticAreaOperator.js";import{l as v,e as j}from"../../chunks/geodeticDensifyOperator.js";import{l as b,e as O}from"../../chunks/geodeticLengthOperator.js";import{e as E}from"../../chunks/lengthOperator.js";import{execute as W}from"../../geometry/operators/projectOperator.js";import{e as k}from"../../chunks/simplifyOperator.js";import{isSupported as L,geodesicLengths as q,geodesicAreas as I}from"../../geometry/support/geodesicUtils.js";import{imageToWorldPanoramic as G,imageToWorld as A}from"../../layers/orientedImagery/transformations/imageToWorld.js";import{convertSphereVertexToPixelLocation as D,scaleWithFactor as U}from"../../layers/orientedImagery/transformations/utils.js";import{worldToImagePanoramic as S,worldToImage as B}from"../../layers/orientedImagery/transformations/worldToImage.js";const F=1e5,T="meters",H="square-meters";function V(t,e){let n=180*Math.atan2(-t.y+e.y,t.x-e.x)/Math.PI;return n<0&&(n+=180),n*Math.PI/180}function C(t,e){let n=180*Math.atan2(-t.y+e.y,t.x-e.x)/Math.PI;return n<0&&(n+=180),n*Math.PI/180}function J(t,e,n){if(!t?.length||!e?.length||!n)return;const[r,a]=t,[,o]=e,i=o-a;return[r+i*Math.cos(n),a+i*Math.sin(n)]}async function K(t,e,n){if(await v(),L(t)){const t=q([e],T)[0];return{area:I([n],H)[0],perimeter:t}}const r=R.WGS84,a=M(e,r),o=M(n,r);let i=j(o,F);if(i=i?k(i):null,!i)return null;const s=q([a],T)[0];return{area:I([i],H)[0],perimeter:s}}async function N(t,n,r,a,o=!1,i){if(n.length<2||!a||!r||!t)return null;const s=vt(r,t);if(!s)return null;const c=n.map((t=>[t.x,t.y])),u=c.at(0),l=c.at(-1);if(!u||!l)return null;const f=s.map((e=>Lt([u,l],e,t,o,!1))),m=await Promise.all(f);e(i);let p=0;for(const e of m){if(!e)return null;const t=Math.abs(e-a);p=Math.max(t,p)}return p}async function Q(t,n,r,a,o,i=!1,s){if(n.length<2||!a||!r||!t)throw new Error("Missing parameters");const c=jt(r,t),u=n.map((t=>[t.x,t.y])),l=u.at(0),f=u.at(-1),m=c.map((e=>qt([l,f],e,t,o,i,!1))),p=await Promise.all(m);e(s);let h=0;for(const e of p){if(!e)return 0;const t=Math.abs(e-a);h=Math.max(t,h)}return h}function X(t,e,n=1){const r=dt(t,!1);if(!r?.length)return;return 20*f([r[0].x,r[0].y],[r.at(-1).x,r.at(-1).y])*n/e}async function Y(t){await b();const e=t.spatialReference;if(e.isGeographic){if(L(e))return q([t],T)[0];const n=M(t,R.WGS84);return q([n],T)[0]}return e.isWebMercator?O(t,{unit:T}):E(t,{unit:T})}function Z(t){if(!t?.length)throw new Error("Invalid deviations array");const[e,n,r]=[0,1,2].map((e=>t.map((t=>t[e])).filter((t=>null!==t)))).map((t=>t.length?Et(t):0));return[e,n,r]}function $(t,e){const n=k(e);if(!n)return null;const r=E(t,{unit:T});return{area:z(n,{unit:H}),perimeter:r}}function _(t,e){return[(t[1][0]-t[0][0])/e,(t[1][1]-t[0][1])/e,(t[1][2]-t[0][2])/e]}async function tt(t,e){await Promise.all([d(),v(),b()]);let n=j(e,F);if(n=n?k(n):null,!n)return null;const r=O(t,{unit:T});return{area:P(n,{unit:H}),perimeter:r}}async function et(t,n,r){if(!n||!t)throw new Error("Missing required parameters");const a=await A(t,n);e(r);const o=a.clone();o.z?o.z+=20:o.z=20;const{averageElevation:i,cameraPitch:s,cameraRoll:c,farDistance:u,...l}=n;return B(o,l)}async function nt(t,n,r,a){const{attributes:o}=r,{location:i}=o,{updateElevationProps:s,...c}=n;if(!t||!n)throw new Error("Missing parameters");let u=i.clone();u.spatialReference.isGeographic&&(u=await w(u,R.WebMercator));const l=await G(t,{...c,cameraLocation:u},s);e(a);const f=l.clone();return f.z?f.z+=20:f.z=20,S(f,c)}function rt(t,e,n,r,a=0,o=1,i){const{averageElevation:s,cameraPitch:c,cameraRoll:u,farDistance:l,...m}=r;if(a>=5||o<=.1){return{value:t*kt(r.cameraLocation.spatialReference)}}const p=new y({x:e.x,y:e.y,z:e.z?e.z+t:t,spatialReference:r.cameraLocation.spatialReference}),h=B(p,m),g=f([n[0].x,n[0].y],[h.x,h.y]),x=n.at(0),w=n.at(-1);if(!x||!w)return null;const M=f([x.x,x.y],[w.x,w.y])*t/g;return rt(M,e,n,r,a+1,Math.abs(t-M))}function at(t,e,n,r,a=0,o=1,i){const{averageElevation:s,horizontalFieldOfView:c,verticalFieldOfView:u,farDistance:l,...m}=r;if(a>=5||o<=.1){return{value:t*kt(r.cameraLocation.spatialReference)}}const p=new y({x:e.x,y:e.y,z:e.z?e.z+t:t,spatialReference:r.cameraLocation.spatialReference}),h=S(p,m),g=f([n[0].x,n[0].y],[h.x,h.y]),x=n.at(0),w=n.at(-1);if(!x||!w)return null;const M=f([x.x,x.y],[w.x,w.y])*t/g;return at(M,e,n,r,a+1,Math.abs(t-M))}function ot(t,e,n){return new x({paths:[[[t.x,t.y,t.z??0],[e.x,e.y,e.z??0]]],spatialReference:n})}function it(t){return 1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*t/6378137)))}function st(t,e){return Math.sqrt((Math.sqrt((t[0][0]-t[1][0])**2+(t[0][1]-t[1][1])**2)/e)**2+(t[0][2]-t[1][2])**2)}function ct(t,e,n){return Math.sqrt((t.z??0-(e.z??0))**2+(Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2)/n)**2)*n}function ut(t,e,n,r){return Tt(Ft([t.x,t.y,t.z??0],[e.x,e.y,e.z??0]),1/n,1/r)}function lt(t,e){return Math.sqrt((t[0][0]-t[1][0])**2+(t[0][1]-t[1][1])**2)/e}function ft(e){return t(Math.atan((e[1][2]-e[0][2])/Math.sqrt((e[1][0]-e[0][0])**2+(e[1][1]-e[0][1])**2)))}function mt(e){let n=90-t(Math.atan2(e[1][1]-e[0][1],e[1][0]-e[0][0]));return n<0&&(n+=360),n}function pt(t,e){return new y({x:(t.pointOnA[0]+t.pointOnB[0])/2,y:(t.pointOnA[1]+t.pointOnB[1])/2,z:(t.pointOnA[2]+t.pointOnB[2])/2,spatialReference:e})}async function ht(t){if(2===t?.length){const e=[];let n=1;const[r,a]=t,o=r.camera.spatialReference,{measurePoints:i}=r;for(let t=0;t<i.length;t++){const i=ot(r.camera,r.measurePoints[t],o),s=ot(a.camera,a.measurePoints[t],o),c=await Ut(i,s);if(!c)return null;const u=pt(c,o);u.spatialReference.isWebMercator&&(n=it(u.y)),e.push([u.x,u.y,u.z??0])}if(e?.length>1){return{distance:st(e,n),horizontalDistance:lt(e,n),verticalDistance:Math.abs(e[0][2]-e[1][2]),slope:ft(e),aspect:mt(e)}}}return null}async function yt(t){const e=t[0].camera.spatialReference;if(2!==t?.length)return null;const[n,r]=t,{camera:a,measurePoints:o}=n,{camera:i,measurePoints:s}=r,c=ot(a,o[0],e),u=ot(i,s[0],e),l=await Ut(c,u);return l?pt(l,e)??null:null}async function gt(t,e){if(!t?.length)return null;const n=[],r=t[0],a=t[1],o=r.camera.spatialReference,{measurePoints:i}=r;for(let l=0;l<i.length;l++){const t=ot(r.camera,r.measurePoints[l],o),e=ot(a.camera,a.measurePoints[l],o),i=await Ut(t,e);if(!i)return null;const s=pt(i,o);n.push([s.x,s.y,s.z??0])}if(n?.length<2)return null;const s=new x({paths:[n],spatialReference:e}),c=new g({rings:[n],spatialReference:e});if(e.isGeographic){const t=await K(e,s,c);return t?.area??null}if(e.isWebMercator){const t=await tt(s,c);return t?.area??null}const u=$(s,c);return u?.area??null}function xt(t,e){if(!t)return null;const n=e.geometry.clone(),r=Array.isArray(t)?t:[t],a=[];return r.forEach((t=>{let e=!1;t.spatialReference.isWGS84&&(t=W(t,new R({wkid:3857})),e=!0);const r=t.spatialReference.isWebMercator?it(t.y):1,o=ct(t,n,r),i=ut(t,n,o,r),s=((t.z??0)-(n.z??0))/i[2]*r;let c=new y({spatialReference:t.spatialReference,x:n.x+s*i[0],y:n.y+s*i[1],z:(n.z??0)+s*i[2]/r});e&&(c=W(c,new R({wkid:4326}))),a.push(c)})),{camera:n,measurePoints:r,tempMeasurePoints:a}}async function wt(t,e){const{updateElevationProps:n,...r}=e;return await A(t,r,n)}async function Mt(t,e){const{updateElevationProps:n,...r}=e;return G(t,r,n)}function Rt(t){navigator.clipboard.writeText(t).catch((t=>{throw t}))}function zt(t){const e=t.map((t=>[t.x,t.y])),n=t[0].spatialReference;return new x({paths:[e],spatialReference:n})}function dt(t,e){return t.map((t=>({x:e?.5+t[0]:t[0],y:e?.5-t[1]:t[1]})))}function Pt(t,e,n,a,i){const s="measurement"===t?e:n;if(i&&s)return r(a,o(s,T),i,3)||null}function vt(t,e){const{cameraPitch:n,cameraRoll:r,cameraLocation:a}=t,{x:o,y:i,z:s,spatialReference:c}=a;if(e.every((t=>0===t))||!e||!e.length)return null;const[u,l,,f,m]=e,p=[-f,0,f],h=[-m,0,m],g=[-u,0,u],x=[-l,0,l],w=[];for(const M of p)for(const e of h)for(const a of g)for(const u of g)for(const l of x){const f={...t};f.cameraPitch=n+M,f.cameraRoll=r+e,f.cameraLocation=new y({x:o+a,y:i+u,z:s?s+l:0,spatialReference:{wkid:c.wkid}}),w.push(f)}return w}function jt(t,e){const{cameraHeading:n,cameraLocation:r}=t,{x:a,y:o,z:i,spatialReference:s}=r;if(e.every((t=>0===t))||!e||!e.length)throw new Error("Invalid parameters");const[c,u,l]=e,f=l>0?[-l,0,l]:[],m=c>0?[-c,0,c]:[],p=u>0?[-u,0,u]:[],h=[];for(const g of f)for(const e of m)for(const r of m)for(const c of p){const u={...t};u.cameraHeading=n+g,u.cameraLocation=new y({x:a+e,y:o+r,z:i?i+c:0,spatialReference:{wkid:s.wkid}}),h.push(u)}return h}function bt(t,e,n,a,i){const s="measurement"===t?e:Et(n);if(i&&s)return r(a,o(s,T),i,3)||null}function Ot(t,e,r,o,i){const s="measurement"===t?e:r;if(i&&s)return n(o,a(s,H),i,3)||null}function Et(t){return Math.sqrt(t.reduce(((t,e)=>t+e**2),0))}function Wt(t,e,n){if("default"===e)return t;const r={x:t[0],y:t[1],z:t[2]},a=D(r,n[0],n[1]);return[a.x,a.y]}function kt(t){return t.metersPerUnit}async function Lt(t,n,r,a=!1,o=!1,i){if(!t||!n||t.length<2)return null;const s=dt(t,a);if(!s||s.length<2)return null;const[c,u]=[s[0],s.at(-1)];if(!u)return null;const l=[c],m=await A(c,n);e(i);const p=m.clone();p.z?p.z+=20:p.z=20;const{averageElevation:h,cameraPitch:y,cameraRoll:g,farDistance:x,...w}=n,M=B(p,w),R=f([c.x,c.y],[M.x,M.y]),z=V(c,M);if(!z)return;const d=J([c.x,c.y],[u.x,u.y],z);if(!d?.length)return;l.push({x:d[0],y:d[1]});const P=20*f([l[0].x,l[0].y],[l[1].x,l[1].y])*kt(n.cameraLocation.spatialReference)/R;if(!o)return P;const v=rt(P,m,l,n,0,1);return v?.value}async function qt(t,n,r,a,o=!1,i=!1,s){const{attributes:c}=a,{location:u}=c,{updateElevationProps:l,...m}=n;if(!t||!n||t.length<2)throw new Error("Invalid parameters");const p=dt(t,o),[h,y]=[p[0],p.at(-1)],g=[h];let x=u.clone();x.spatialReference.isGeographic&&(x=await w(x,R.WebMercator));const M=await G(h,{...m,cameraLocation:x},l);e(s);const z=M.clone();z.z?z.z+=20:z.z=20;const d=S(z,m),P=f([h.x,h.y],[d.x,d.y]),v=V(h,d);if(!v)return;const j=J([h.x,h.y],[y.x,y.y],v);if(!j?.length)return;g.push({x:j[0],y:j[1]});const b=20*f([g[0].x,g[0].y],[g[1].x,g[1].y])*kt(n.cameraLocation.spatialReference)/P;if(!i)return b;const O=at(b,M,g,n,0,1);return O?.value}async function It(t,e,n=!1){if(t.length<3)return null;const r=dt(t,n),a=await wt(r,e),o=a.map((({x:t,y:e})=>[t,e]));t.push(t[0]),o.push(o[0]);const i=a[0].spatialReference,s=new x({paths:[o],spatialReference:i}),c=new g({rings:[o],spatialReference:i});return i.isGeographic?K(i,s,c):i.isWebMercator?tt(s,c):$(s,c)}async function Gt(t,n,r=!1,a){if(t.length<3)return null;const o=dt(t,r),i=await Mt(o,n);e(a);const s=i.map((({x:t,y:e})=>[t,e]));t.push(t[0]),s.push(s[0]);const c=i[0].spatialReference,u=new x({paths:[s],spatialReference:c}),l=new g({rings:[s],spatialReference:c});return c.isGeographic?K(c,u,l):c.isWebMercator?tt(u,l):$(u,l)}async function At(t,e,n=!1){const r=dt(t,n);return Y(zt(await wt(r,e)))}async function Dt(t,n,r=!1,a){const o=dt(t,r),i=await Mt(o,n);e(a);return Y(zt(i))}async function Ut(t,e){const n=c(),r=t.paths[0][0],a=e.paths[0][0];let o,u;t.spatialReference.isWGS84||t.spatialReference.isWebMercator?(await b(),o=O(t),u=O(e)):(o=E(t),u=E(e));const l=_(t.paths[0],o),f=_(e.paths[0],u),m=St(l,f),[p,h,y]=l,[g,x,w]=f.map((t=>-t)),[M,R,z]=m,[d,P,v]=[a[0]-r[0],a[1]-r[1],a[2]-r[2]];i(n,p,g,M,h,x,R,y,w,z);const j=s(n);if(0===j)return null;i(n,d,g,M,P,x,R,v,w,z);const W=s(n);i(n,p,d,M,h,P,R,y,v,z);const k=s(n);i(n,p,g,d,h,x,P,y,w,v);const L=W/j,q=k/j,I=s(n)/j;return{distance:Math.abs(I/Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2])),pointOnA:Bt(r,L,l),pointOnB:Bt(a,q,f)}}function St(t,e){const n=u(),r=m(u(),t[0],t[1],t[2]),a=m(u(),e[0],e[1],e[2]),o=p(n,r,a);return[o[0],o[1],o[2]]}function Bt(t,e,n){return[t[0]+e*n[0],t[1]+e*n[1],t[2]+e*n[2]]}function Ft(t,e){const n=l(t[0],t[1],t[2]),r=l(e[0],e[1],e[2]);return h(u(),n,r)}function Tt(t,e,n){const r=U(t,e,n);return[r[0],r[1],r[2]]}export{V as calculateAngle,C as calculateAnglePano,J as calculateCorrectedPixel,N as calculateHeightAccuracy,Q as calculateHeightAccuracyPanoramic,X as calculateHeightFromTemporaryDistance,Z as calculateLocationAccuracyFromDeviations,nt as calculateReferenceImagePointPanoramic,et as calculateTempImagePoint,rt as computeHeightIteratively,at as computeHeightIterativelyPanoramic,gt as computeTriangulatedAreaMeasurement,ht as computeTriangulatedDistanceMeasurement,yt as computeTriangulatedPoint,xt as computeTriangulatedVector,Rt as copyToClipboard,dt as formatPixels,vt as generateCombinations,jt as generateCombinationsPanoramic,Ot as getConvertedArea,bt as getConvertedDistance,Pt as getConvertedHeight,Wt as getModeCorrectedPoint,Et as getRootOfSumOfSquaredErrors,kt as getUnitRateFromSpatialReference,Lt as heightMeasurement2D,qt as heightMeasurementPanoramic,It as pixelAreaMeasurement2D,Gt as pixelAreaMeasurementPanoramic,At as pixelDistanceMeasurement2D,Dt as pixelDistanceMeasurementPanoramic,Tt as scale,Ut as solveSkewLinesIntersection,Ft as subtract};
