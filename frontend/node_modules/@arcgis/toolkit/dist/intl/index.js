import { getElementAttribute, observeAncestorsMutation } from "../dom/index.js";
const supportedLocalesArray = "ar,bg,bs,ca,cs,da,de,el,en,es,et,fi,fr,he,hr,hu,id,it,ja,ko,lt,lv,nl,nb,no,pl,pt-BR,pt-PT,ro,ru,sk,sl,sr,sv,th,tr,uk,vi,zh-CN,zh-HK,zh-TW".split(
  ","
);
const supportedLocales = (
  //#endregion supportedLocales
  /* @__PURE__ */ new Set(supportedLocalesArray)
);
const defaultLocale = "en";
const localeEquivalencies = {
  //#region localeEquivalencies
  // We use `pt-PT` as it will have the same translations as `pt`, which has no corresponding bundle
  pt: "pt-PT",
  // We support both 'nb' and 'no' (BCP 47) for Norwegian but only `no` has corresponding bundle
  nb: "no",
  // We support both 'nn' and 'no' (BCP 47) for Norwegian but only `no` has corresponding bundle
  // See https://devtopia.esri.com/WebGIS/arcgis-web-components/issues/4667
  nn: "no",
  // We use `zh-CN` as base translation for chinese locales which has no corresponding bundle.
  zh: "zh-CN"
  //#endregion localeEquivalencies
};
const fetchT9nStringsBundle = async (locale, assetsPath, prefix = "") => {
  const path = `${assetsPath}/${prefix}`;
  const filePath = `${path}${locale}.json`;
  t9nStringsCache[filePath] ?? (t9nStringsCache[filePath] = fetchBundle(locale, path));
  return await t9nStringsCache[filePath];
};
const t9nStringsCache = {};
const fetchBundle = async (locale, path) => {
  const filePath = `${path}${locale}.json`;
  try {
    const response = await fetch(filePath);
    if (response.ok) {
      return await response.json();
    }
  } catch (error) {
    if (process.env.NODE_ENV !== "production") {
      const is404ViteFallback = String(error).includes(`Unexpected token '<', "<!doctype "... is not valid JSON`);
      if (is404ViteFallback) {
        console.error(`[404] Localization strings not found at ${filePath}`);
      } else {
        console.error(`Error fetching localization strings at ${filePath}`, error);
      }
    } else {
      console.error(error);
    }
    return {};
  }
  if (locale === defaultLocale) {
    return {};
  }
  return await fetchBundle(defaultLocale, path);
};
const getElementLocale = (element) => {
  const lang = getElementAttribute(element, "lang", globalThis.navigator?.language || defaultLocale);
  return { lang, t9nLocale: normalizeLocale(lang) };
};
const normalizeLocale = (lang) => {
  const [rawLanguageCode, regionCode] = lang.split("-");
  const languageCode = rawLanguageCode.toLowerCase();
  let normalizedLocale = languageCode;
  if (regionCode) {
    normalizedLocale = `${languageCode}-${regionCode.toUpperCase()}`;
  }
  normalizedLocale = localeEquivalencies[normalizedLocale] ?? normalizedLocale;
  if (supportedLocales.has(normalizedLocale)) {
    return normalizedLocale;
  }
  if (regionCode) {
    return normalizeLocale(languageCode);
  }
  return defaultLocale;
};
const startLocaleObserver = (element, getAssetsPath, onUpdated, assetName) => {
  let result = void 0;
  const callback = () => updateComponentLocaleState(element, getAssetsPath(), assetName).then((newResult) => {
    if (result?.lang !== newResult.lang || result.t9nLocale !== newResult.t9nLocale || result.t9nStrings !== newResult.t9nStrings) {
      onUpdated(newResult);
    }
    result = newResult;
  }).catch(console.error);
  queueMicrotask(callback);
  return observeAncestorsMutation(element, ["lang"], callback);
};
const updateComponentLocaleState = async (element, assetsPath, assetName = element.localName.split("-").slice(1).join("-")) => {
  const { lang, t9nLocale } = getElementLocale(element);
  const t9nAssetsPath = `${assetsPath}/${assetName}/t9n`;
  const prefix = `messages.`;
  const t9nStrings = (
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    assetName === null ? {} : await fetchT9nStringsBundle(t9nLocale, t9nAssetsPath, prefix)
  );
  return { lang, t9nLocale, t9nStrings };
};
export {
  defaultLocale,
  fetchT9nStringsBundle,
  getElementLocale,
  normalizeLocale,
  startLocaleObserver,
  supportedLocales
};
