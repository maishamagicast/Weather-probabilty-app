import { nil } from '../type';
export * from './slots';
/**
 * Combine multiple class names into a single string.
 *
 * @remarks
 * This function is less necessary in Lumina packages as the `class` JSX prop
 * accepts `Record<string, boolean>` objects.
 */
export declare const classes: (...classes: (nil | Record<string, boolean> | string[] | string | false)[]) => string;
/**
 * Observe the element and its ancestors for attribute mutations.
 * If the attributes have been changed in the ancestor tree then the callback
 * will be invoked.
 *
 * @param element The element on which to observe the attribute mutations.
 * @param attributeFilter The list of attributes to observe.
 * @param callback The callback to invoke when the attributes have been changed.
 * @returns A callback to unsubscribe from the observer.
 *
 * @example
 * ```ts
 * observeAncestorsMutation(
 *   element,
 *   ["dir", "lang"],
 *   () => console.log(getElementAttribute(element, "dir", "ltr"))
 * );
 * ```
 */
export declare const observeAncestorsMutation: (element: Node, attributeFilter: string[], callback: () => void) => (() => void);
/**
 * Find the closest element that matches the selector.
 * It will traverse the element's ancestors to find the target element.
 * Shadow DOM boundaries are also taken into account.
 * @param base The element to start the search from.
 * @param selector The selector to match.
 * @returns The closest element that matches the selector or null if not found.
 *
 * @remarks
 * This is similar to [Element.closest()](https://developer.mozilla.org/en-US/docs/Web/API/Element/closest),
 * but the DOM's utility only looks up until the first shadow boundary.
 *
 * @example
 * ```ts
 * const hostElement = getClosestElement(element, "arcgis-map, arcgis-scene");
 * ```
 */
export declare const getClosestElement: <T = Element>(base: Element, selector: string) => T | undefined;
/**
 * Use the closest Calcite mode class name to determine the
 * theme of the element. It will traverse the element's
 * ancestors to find the theme. Shadow DOM boundaries are also
 * taken into account.
 *
 * @param base The element to start the search from.
 * @returns The theme of the element ("light" or "dark"). "light" is the default.
 *
 * @remarks
 * It is advised to consider alternative solutions before using this utility:
 * - Calcite CSS variables. Benefits: makes styles more consistent,
 *   and variables are updated automatically to match dark/light theme.
 * - Detect dark mode using CSS selectors and apply styles in CSS.
 *   Benefit: styles update automatically when the theme changes.
 */
export declare function unsafeGetCalciteModeName(el: HTMLElement): "dark" | "light";
/**
 * Get direction property of the closest element.
 *
 * @param el The element to start the search from.
 * @returns The direction of the element ("ltr" | "rtl"). "ltr" is the default.
 *
 * @remarks
 * Do not set the `dir` property on the element itself. Do not set the `dir`
 * attribute on the components you are rendering. The `dir` attribute is only
 * meant to be set by the consumers of your component. Your component is
 * expected to respect what was set by the consumer.
 *
 * @remarks
 * Prefer [useDirection()](https://qawebgis.esri.com/components/lumina/controllers/useDirection)
 * to ensure your component is responsive to direction changes.
 */
export declare const unsafeGetElementDirection: (el: HTMLElement) => "ltr" | "rtl";
/**
 * Get the attribute value from the element or closest ancestor.
 * Shadow DOM boundaries are also taken into account.
 * If the attribute is not found then the fallback value is returned.
 *
 * @example
 * ```ts
 * const dir = getElementAttribute(element, "dir", "ltr");
 * ```
 */
export declare const getElementAttribute: (el: Element, attributeName: string, fallbackValue: string) => string;
/**
 * Focus the element if it is focusable.
 * @returns A promise that resolves once the focus is set.
 */
export declare const focusElement: (el: FocusableElement | undefined) => Promise<void>;
export interface FocusableElement extends HTMLElement {
    setFocus?: () => Promise<void>;
}
/**
 * Set the focus on the element that matches the selector.
 * It will traverse the element's ancestors to find the target element.
 * Shadow DOM boundaries are also taken into account.
 * If the element is not found then the focus is not set.
 * Example: `setFocusOnElement(element, "[role='menuitem']");`
 * @param ref The element to start the search from.
 * @param selector The selector to match.
 * @returns Returns true if the focus is set on the element.
 *
 * @deprecated This function is doing too much. Import from `focusElement(getClosestElement())` from `@arcgis/toolkit/dom` instead.
 */
export declare const setFocusOnElement: (ref: (Element & {
    componentOnReady?: () => Promise<void>;
}) | null | undefined, selector: string) => void;
