"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
function slotChangeHasContent(event) {
  return slotChangeHasAssignedElement(event) || slotChangeHasTextContent(event);
}
function slotChangeGetTextContent(event) {
  return slotChangeGetAssignedNodes(event).filter((node) => node.nodeType === Node.TEXT_NODE).map((node) => node.textContent).join("").trim();
}
function slotChangeHasTextContent(event) {
  return slotChangeGetTextContent(event).length > 0;
}
function slotChangeHasAssignedNode(event) {
  return slotChangeGetAssignedNodes(event).length > 0;
}
function slotChangeGetAssignedNodes(event) {
  return event.currentTarget.assignedNodes({
    flatten: true
  });
}
function slotChangeHasAssignedElement(event) {
  return slotChangeGetAssignedElements(event).length > 0;
}
function slotChangeGetAssignedElements(event, selector) {
  return getSlotAssignedElements(event.target, selector);
}
function getSlotAssignedElements(slot, selector) {
  const assignedElements = slot.assignedElements({
    flatten: true
  });
  return selector ? assignedElements.filter((element) => element.matches(selector)) : assignedElements;
}
const classes = (...classes2) => {
  const effectiveClasses = [];
  for (let i = 0; i < classes2.length; i++) {
    const arg = classes2[i];
    if (typeof arg === "string") {
      effectiveClasses.push(arg);
    } else if (Array.isArray(arg)) {
      effectiveClasses.push.apply(effectiveClasses, arg);
    } else if (typeof arg === "object") {
      for (const prop in arg) {
        if (arg[prop]) {
          effectiveClasses.push(prop);
        }
      }
    }
  }
  const className = effectiveClasses.join(" ");
  effectiveClasses.length = 0;
  return className;
};
const inTargetElement = (element, targetElement) => {
  let currentElement = element;
  while (currentElement) {
    if (currentElement === targetElement) {
      return true;
    }
    if (!currentElement.parentNode) {
      return false;
    }
    if (currentElement.parentNode instanceof ShadowRoot) {
      currentElement = currentElement.parentNode.host;
    } else {
      currentElement = currentElement.parentNode;
    }
  }
  return false;
};
const observeAncestorsMutation = (element, attributeFilter, callback) => {
  const subscribe = observe(attributeFilter).subscribe;
  return subscribe((mutations) => {
    const matched = mutations.some((mutation) => inTargetElement(element, mutation.target));
    if (matched) {
      callback();
    }
  });
};
const observers = {};
const observe = (attributeFilter) => {
  const attributes = attributeFilter.join(",");
  const previousObserver = observers[attributes];
  if (previousObserver !== void 0) {
    return previousObserver;
  }
  const subscribers = /* @__PURE__ */ new Set();
  const mutationObserver = new MutationObserver((mutations) => subscribers.forEach((callback) => callback(mutations)));
  if (globalThis.document) {
    mutationObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter,
      subtree: true
    });
  }
  const observer = {
    subscribe: (callback) => {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
        if (subscribers.size === 0) {
          mutationObserver.disconnect();
          observers[attributes] = void 0;
        }
      };
    }
  };
  observers[attributes] = observer;
  return observer;
};
const getClosestElement = (base, selector) => {
  let currentElement = base;
  while (currentElement) {
    const element = currentElement.closest?.(selector);
    if (element) {
      return element;
    }
    const rootElement = currentElement.getRootNode?.();
    if (rootElement === globalThis.document) {
      return;
    }
    currentElement = rootElement.host;
  }
  return;
};
function unsafeGetCalciteModeName(el) {
  const closestElWithMode = getClosestElement(el, `.calcite-mode-dark, .calcite-mode-light, .calcite-mode-auto`);
  return closestElWithMode?.classList.contains("calcite-mode-dark") || closestElWithMode?.classList.contains("calcite-mode-auto") && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}
const unsafeGetElementDirection = (el) => (
  //#endregion unsafeGetElementDirection
  getElementAttribute(el, "dir", "ltr")
);
const getElementAttribute = (el, attributeName, fallbackValue) => {
  const closest = getClosestElement(el, `[${attributeName}]`);
  return closest?.getAttribute(attributeName) ?? fallbackValue;
};
const focusElement = async (el) => {
  if (el == null) {
    return;
  }
  if (hasSetFocus(el)) {
    await el.setFocus();
  } else {
    el.focus();
  }
};
const hasSetFocus = (ref) => typeof ref.setFocus === "function";
const setFocusOnElement = (ref, selector) => {
  if (!ref?.shadowRoot) {
    return;
  }
  if (ref.hasAttribute("hydrated") || ref.hasAttribute("calcite-hydrated")) {
    setFocus(ref, selector);
    return;
  }
  void Promise.resolve(ref.componentOnReady?.()).then(() => setFocus(ref, selector));
};
const isElement = (ref) => ref.nodeType === Node.ELEMENT_NODE;
const setFocus = (ref, selector = "") => {
  if (!isElement(ref)) {
    return false;
  }
  if (ref.matches(selector)) {
    if (hasSetFocus(ref)) {
      setTimeout(() => void ref.setFocus(), 0);
    }
    return true;
  }
  for (const child of ref.children) {
    if (setFocus(child, selector)) {
      return true;
    }
  }
  const shadowRoot = ref.shadowRoot;
  if (shadowRoot) {
    for (const child of shadowRoot.children) {
      if (setFocus(child, selector)) {
        return true;
      }
    }
  }
  return false;
};
exports.classes = classes;
exports.focusElement = focusElement;
exports.getClosestElement = getClosestElement;
exports.getElementAttribute = getElementAttribute;
exports.getSlotAssignedElements = getSlotAssignedElements;
exports.observeAncestorsMutation = observeAncestorsMutation;
exports.setFocusOnElement = setFocusOnElement;
exports.slotChangeGetAssignedElements = slotChangeGetAssignedElements;
exports.slotChangeGetAssignedNodes = slotChangeGetAssignedNodes;
exports.slotChangeGetTextContent = slotChangeGetTextContent;
exports.slotChangeHasAssignedElement = slotChangeHasAssignedElement;
exports.slotChangeHasAssignedNode = slotChangeHasAssignedNode;
exports.slotChangeHasContent = slotChangeHasContent;
exports.slotChangeHasTextContent = slotChangeHasTextContent;
exports.unsafeGetCalciteModeName = unsafeGetCalciteModeName;
exports.unsafeGetElementDirection = unsafeGetElementDirection;
