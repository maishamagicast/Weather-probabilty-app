"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const kebabToPascal = (string) => (
  //#endregion kebabToPascal
  string.split("-").map(capitalize).join("")
);
const camelToKebab = (string) => (
  //#endregion camelToKebab
  string.replace(upperBeforeLower, (upper, remainder) => `${remainder === 0 ? "" : "-"}${upper.toLowerCase()}`)
);
const upperBeforeLower = /[A-Z]+(?![a-z])|[A-Z]/gu;
const camelToHuman = (string) => (
  //#endregion camelToHuman
  capitalize(string.replace(upperBeforeLower, (upper, remainder) => `${remainder === 0 ? "" : " "}${upper}`))
);
const capitalize = (string) => (
  //#endregion capitalize
  string.charAt(0).toUpperCase() + string.slice(1)
);
const uncapitalize = (string) => (
  //#endregion uncapitalize
  string.charAt(0).toLowerCase() + string.slice(1)
);
const doubleQuote = '"';
const singleQuote = "'";
const repeatString = (value, n) => new Array(n + 1).join(value);
const quoteString = (value) => {
  let quote = doubleQuote;
  let alternateQuote = singleQuote;
  const avoidEscape = value.includes(quote) && !value.includes(alternateQuote);
  if (avoidEscape) {
    alternateQuote = doubleQuote;
    quote = singleQuote;
  }
  const alternateEscape = new RegExp(`(^|[^\\\\])((?:\\\\{2})*)((?:\\\\${alternateQuote})+)`, "gu");
  value = value.replace(
    alternateEscape,
    (_, boundaryChar, leadingEscapedSlashes, escapedQuoteChars) => (
      // We divide the escapedQuoteChars by 2 since there are 2 characters in each escaped part ('\\"'.length === 2)
      boundaryChar + leadingEscapedSlashes + repeatString(alternateQuote, escapedQuoteChars.length / 2)
    )
  );
  const quoteEscape = new RegExp(`(^|[^\\\\])((?:\\\\{2})*)(${quote}+)`, "gu");
  value = value.replace(
    quoteEscape,
    (_, boundaryChar, leadingEscapedSlashes, quoteChars) => boundaryChar + leadingEscapedSlashes + repeatString(`\\${quote}`, quoteChars.length)
  );
  return quote + value + quote;
};
const createFilterExpression = (filterWord) => {
  const sanitizedWord = filterWord ? filterWord.replaceAll(/[-[\]/{}()*+?.\\^$|]/gu, "\\$&") : "^.*$";
  return new RegExp(sanitizedWord, "i");
};
const addLtrMark = (value) => (
  // Make sure the string value is LTR. This prevent issues with RTL language used in LTR containers.
  `‎${value ?? ""}‎`
);
const hasRandomUUID = "randomUUID" in crypto;
const generateGuid = () => {
  if (hasRandomUUID) {
    return crypto.randomUUID();
  }
  const values = crypto.getRandomValues(new Uint16Array(8));
  values[3] = values[3] & 4095 | 16384;
  values[4] = values[4] & 16383 | 32768;
  const p = (i) => values[i].toString(16).padStart(4, "0");
  return `${p(0) + p(1)}-${p(2)}-${p(3)}-${p(4)}-${p(5)}${p(6)}${p(7)}`;
};
const getMinorVersion = (version) => {
  const [major, minor] = version.split(".");
  return `${major}.${minor}`;
};
const getPreamble = (version) => (
  //#endregion getPreamble
  `All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/${getMinorVersion(version)}/esri/copyright.txt for details.
v${version}`
);
const setValuesInString = (message, values = {}) => (message ?? "").replace(/\{(?<valueName>.*?)\}/gu, (match, valueName) => values[valueName] ?? match);
exports.addLtrMark = addLtrMark;
exports.camelToHuman = camelToHuman;
exports.camelToKebab = camelToKebab;
exports.capitalize = capitalize;
exports.createFilterExpression = createFilterExpression;
exports.generateGuid = generateGuid;
exports.getMinorVersion = getMinorVersion;
exports.getPreamble = getPreamble;
exports.kebabToPascal = kebabToPascal;
exports.quoteString = quoteString;
exports.setValuesInString = setValuesInString;
exports.uncapitalize = uncapitalize;
